# プログラミング演習3.14  
  
## 課題内容  
ディレクトリ内の全てのファイルをコピーしなければならなくなることが時々ある。  
一連のファイルのバックアップを作らなければならない時などだ。  
そこで第２章のcp1.cプログラムを書き換え、引数として２つのディレクトリ名を指定した場合には、  
第１のディレクトリの全てのファイルを第２のディレクトリにコピーするようにしなさい。  
コピーのファイル名は、元のファイル名と同じにすること。  
  
### cp1.cを確認。  
  
```  
#include <fcntl.h>  
#include <stdio.h>  
#include <stdlib.h>  
#include <unistd.h>  
  
#define BUFFERSIZE 4096  
#define COPYMODE 0644  
  
void oops(char *, char *);  
  
int main(int ac, char *av[]) {  
  
  int in_fd, out_fd, n_chars;  
  char buf[BUFFERSIZE];  
  
  if (ac != 3) {  
    fprintf(stderr, "usage: %s source desination\n", *av);  
    exit(1);  
  }  
  
  if ((in_fd = open(av[1], O_RDONLY)) == -1)  
    oops("Cannot open ", av[1]);  
  if ((out_fd = creat(av[2], COPYMODE)) == -1)  
    oops("Cannot creat ", av[2]);  
  
  while ((n_chars = read(in_fd, buf, BUFFERSIZE)) > 0)  
    if (write(out_fd, buf, n_chars) != n_chars)  
      oops("Write error to ", av[2]);  
  
  if (n_chars == -1)  
    oops("Read error from ", av[1]);  
  
  if (close(in_fd) == -1 || close(out_fd) == -1)
    oops("Error closing files", "");  
}  
  
void oops(char *s1, char *s2) {  
  fprintf(stderr, "Error : %s ", s1);  
  perror(s2);  
  exit(1);  
  
  
}  
  
```  
  
  
### 改善案  
まず、第１引数と第２引数の名前でstatを行い、それがディレクトリであるかどうかを判断する。  
両方がディレクトリである場合に、課題の内容の処理を書く。  
処理の最後にリターンをし、通常のCPが走らないようにプログラムを終了させる。というのが大まかな流れ。  
  
両方がディレクトリであったら、第１引数のディレクトリに対しopendirとreaddirを行い全てのエントリをstatで確認。  
そのファイル名が. または .. であるか、そのエントリがディレクトリであったらreaddirをしてるループをcontinueで抜けて次のファイルへ飛ぶ。  
コピー可能なファイルであれば、そのままコピーする処理を追加。  
  
課題にはコピー元のディレクトリの中にあるファイルをコピーすると書いてあり、ディレクトリはコピーすると書いていないため、今回はディレクトリがあった場合は無視する。  
  
  
  
### cp_allfile.cを作成  
  
第１引数と第２引数が両方ともディレクトリの場合、第１引数のディレクトリの中にあるファイルをすべて第２引数のディレクトリにコピーする機能を追加したもの。  
第１引数と第２引数のどちらかがディレクトリでない場合、普通のcpのように動作します。  
なお、このバージョンではコピー元ディレクトリの中にあるファイルはコピー先にコピーされますが、  
コピー元ディレクトリの中にあるディレクトリはコピーされません。  
  
```  
#include <dirent.h>  
#include <fcntl.h>  
#include <stdio.h>  
#include <stdlib.h>  
#include <string.h>  
#include <sys/stat.h>  
#include <unistd.h>  
  
#define BUFFERSIZE 4096  
#define COPYMODE 0644  
  
void oops(char *, char *);  
  
int main(int ac, char *av[]) {  
  
  int in_fd, out_fd, n_chars;  
  char buf[BUFFERSIZE];  
  struct stat source;  
  struct stat target;  
  struct dirent *entry;  
  DIR *dp;  
  
  if (ac != 3) {  
    fprintf(stderr, "usage: %s source desination\n", *av);  
    exit(1);  
  }  
  
  if (stat(av[1], &source) == -1) {  
    oops("Cannot stat ", av[1]);  
  }  
  
  if (stat(av[2], &target) == -1) {  
    oops("Cannot stat ", av[2]);  
  }  
  
  if (S_ISDIR(source.st_mode) && S_ISDIR(target.st_mode)) {  
    dp = opendir(av[1]);  
    if (dp == NULL)  
      oops("Can't open dir", av[1]);  
  
    while ((entry = readdir(dp)) != NULL) {  
      struct stat checkstat;  
  
      char src_path[255] = "";  
      snprintf(src_path, sizeof(src_path), "%s/%s", av[1], entry->d_name);  
  
      if (stat(src_path, &checkstat) == -1) {  
        oops("Cannot stat ", entry->d_name);  
      }  
  
      if (S_ISDIR(checkstat.st_mode) || strcmp(entry->d_name, ".") == 0 ||
          strcmp(entry->d_name, "..") == 0)  
        continue;  
  
      if ((in_fd = open(src_path, O_RDONLY)) == -1)  
        oops("Cannot open ", av[1]);  
  
      char out_path[255] = "";  
      snprintf(out_path, sizeof(out_path), "%s/%s", av[2], entry->d_name);  
  
      if ((out_fd = creat(out_path, COPYMODE)) == -1)  
        oops("Cannot creat ", av[2]);  
  
      while ((n_chars = read(in_fd, buf, BUFFERSIZE)) > 0)  
        if (write(out_fd, buf, n_chars) != n_chars)  
          oops("Write error to ", av[2]);  
  
      if (n_chars == -1)  
        oops("Read error from ", av[1]);  
  
      if (close(in_fd) == -1 || close(out_fd) == -1)
        oops("Error closing files", "");  
    }  
  
    if (closedir(dp) == -1)  
      oops("Error closing directory", "");  
    return 0;  
  }  
  
  if ((in_fd = open(av[1], O_RDONLY)) == -1)  
    oops("Cannot open ", av[1]);  
  if ((out_fd = creat(av[2], COPYMODE)) == -1)  
    oops("Cannot creat ", av[2]);  
  
  while ((n_chars = read(in_fd, buf, BUFFERSIZE)) > 0)  
    if (write(out_fd, buf, n_chars) != n_chars)  
      oops("Write error to ", av[2]);  
  
  if (n_chars == -1)  
    oops("Read error from ", av[1]);  
  
  if (close(in_fd) == -1 || close(out_fd) == -1)
    oops("Error closing files", "");  
}  
  
void oops(char *s1, char *s2) {  
  fprintf(stderr, "Error : %s ", s1);  
  perror(s2);  
  exit(1);  
}  
```  
