# プログラミング課題4.19
## 課題内容
新ファイル作成の説明では、４つの主要な処理を示した。
ファイルをファイルシステムに正しく追加するためには、これら４つの処理がすべて成功して完了していなければならない。
この処理シーケンスの途中で、コンピューターの電源が落ちたらどうなるだろうか。
例えば、データ領域にデータは格納されているが、inodeはまだ割り当てられていない場合にはどうなるのか？

(a) これら４つの主要処理の処理順を選択しなさい。また、選択の根拠を説明しなさい。

(b)あなたの(a)に対する解答を使って、システムを構築したものとする。
手続きの２つのステップの間で、システムがクラッシュしたらどうなるか？
例えば、手続きに４つのステップがあるとすると、ステップとステップの間が３つあることになる。
３つのポイントのそれぞれでシステムクラッシュが発生したときに、ファイルシステムのどの部分で不一致が発生するか説明しなさい。

(3) Unixコマンドfsckの説明を読み、fsckが探すもののリストと(b)の部分に対するあなたの答えがどのくらい似ているのかを説明しなさい。

## 4つの主要操作とは何か？
### プロパティの格納
ファイルはプロパティを持っている。カーネルはinodeにプロパティを記録する。

### データの格納
ファイルには内容があり、そのデータを格納する。

### 確保したブロックの記録
ファイルの内容は幾つかのブロックに格納されており、このブロック番号のシーケンスをinodeのディスクブロック割り当てリストに記録する。

### ディレクトリへのファイル名の追加
新しく作ったファイルのファイル名をディレクトリエントリに追加する。

## (a) これら４つの主要処理の処理順はどうなるか？
どの順番が合理的か考えてみようと思ったが、どの順番でもできなくはなさそうなので、実際のファイルを作るシステムコールを調査することにした。
今回はcreatシステムコールを追うことにする。

### creatシステムコールの定義
```
SYSCALL_DEFINE2(creat, const char __user *, pathname, umode_t, mode)
{
	int flags = O_CREAT | O_WRONLY | O_TRUNC;

	if (force_o_largefile())
		flags |= O_LARGEFILE;
	return do_sys_open(AT_FDCWD, pathname, flags, mode);
}

```

creatは実際はdo_sys_openに渡すフラグを確定して、modeとpathnameと一緒に渡しているだけのようだ。
AT_FDCWDは現在の作業ディレクトリを意味する特別な疑似ファイルディスクリプタ。
do_sys_openを見てみよう。

### do_sys_open関数

```
int do_sys_open(int dfd, const char __user *filename, int flags, umode_t mode)
{
	struct open_how how = build_open_how(flags, mode);
	return do_sys_openat2(dfd, filename, &how);
}
```

do_sys_open関数の呼び方から推測すると、第１引数dfdの内容は基準となるディレクトリだと思われる。
do_sys_open関数は flags,modeをもとに、open_how構造体を作っている。おそらく、どういう風に新しいファイルを開くかという情報が入った構造体だろう。
それをdo_sys_openat2(dfd,filename,&how)関数に渡している。

### do_sys_openat2関数

```
static int do_sys_openat2(int dfd, const char __user *filename,
			  struct open_how *how)
{
	struct open_flags op;
	struct filename *tmp;
	int err, fd;

	err = build_open_flags(how, &op);
	if (unlikely(err))
		return err;

	tmp = getname(filename);
	if (IS_ERR(tmp))
		return PTR_ERR(tmp);

	fd = get_unused_fd_flags(how->flags);
	if (likely(fd >= 0)) {
		struct file *f = do_filp_open(dfd, tmp, &op);
		if (IS_ERR(f)) {
			put_unused_fd(fd);
			fd = PTR_ERR(f);
		} else {
			fd_install(fd, f);
		}
	}
	putname(tmp);
	return fd;
}
```

この関数でファイルディスクリプタを返しているようだ。
ファイルディスクリプタを作る過程で、どのような関数を読んで作っているだろうか？

ざっとコードを読む感じ、先ほどのhow構造体を、build_ipen_flags(how,&op)に渡している。
op構造体はこの関数の中で宣言されている　open_flags型の構造体なので、おそらくopにhowで得た情報からopen_flags構造体の内容を書き込む関数と思われる。
errはその際に返す実行結果のコードで、エラーなら-1とかを返すものと推測できる。

この関数のメイン処理は do_file_open関数だろう。
do_file_open関数の中身を見てみよう。


### do_filp_open関数
namei.c　ファイルにある関数である。

```
struct file *do_filp_open(int dfd, struct filename *pathname,
		const struct open_flags *op)
{
	struct nameidata nd;
	int flags = op->lookup_flags;
	struct file *filp;

	set_nameidata(&nd, dfd, pathname, NULL);
	filp = path_openat(&nd, op, flags | LOOKUP_RCU);
	if (unlikely(filp == ERR_PTR(-ECHILD)))
		filp = path_openat(&nd, op, flags);
	if (unlikely(filp == ERR_PTR(-ESTALE)))
		filp = path_openat(&nd, op, flags | LOOKUP_REVAL);
	restore_nameidata();
	return filp;
}

```

明らかにpath_openat関数がnameidataを使って何かをやっている。
set_nameidataは名前からしてfile名とinodeを結びつけていそうな内容である。
これはディレクトリエントリの追加にあたるのだろうか？

filpを返している path_openatは何をやっているのだろうか？
restore_nameidata()は何をやっているのか？

### set_nameidata関数

```

static void __set_nameidata(struct nameidata *p, int dfd, struct filename *name)
{
	struct nameidata *old = current->nameidata;
	p->stack = p->internal;
	p->depth = 0;
	p->dfd = dfd;
	p->name = name;
	p->pathname = likely(name) ? name->name : "";
	p->path.mnt = NULL;
	p->path.dentry = NULL;
	p->total_link_count = old ? old->total_link_count : 0;
	p->saved = old;
	current->nameidata = p;
}


```
nameidata 構造体には基準となるディレクトリ、ファイル名、リンク数などを格納しているようだ。
ここではどうやらinodeと結びつけてはいないらしいが、ディレクトリとファイル名は結びついていそうだ。

```
struct nameidata {
	struct path	path;
	struct qstr	last;
	struct path	root;
	struct inode	*inode; /* path.dentry.d_inode */
	unsigned int	flags, state;
	unsigned	seq, next_seq, m_seq, r_seq;
	int		last_type;
	unsigned	depth;
	int		total_link_count;
	struct saved {
		struct path link;
		struct delayed_call done;
		const char *name;
		unsigned seq;
	} *stack, internal[EMBEDDED_LEVELS];
	struct filename	*name;
	const char *pathname;
	struct nameidata *saved;
	unsigned	root_seq;
	int		dfd;
	vfsuid_t	dir_vfsuid;
	umode_t		dir_mode;
} __randomize_layout;
```

nameidata構造体自体は、inode情報も持っているようだ。

### path_openat関数

```

static struct file *path_openat(struct nameidata *nd,
			const struct open_flags *op, unsigned flags)
{
	struct file *file;
	int error;

	file = alloc_empty_file(op->open_flag, current_cred());
	if (IS_ERR(file))
		return file;

	if (unlikely(file->f_flags & __O_TMPFILE)) {
		error = do_tmpfile(nd, flags, op, file);
	} else if (unlikely(file->f_flags & O_PATH)) {
		error = do_o_path(nd, flags, file);
	} else {
		const char *s = path_init(nd, flags);
		while (!(error = link_path_walk(s, nd)) &&
		       (s = open_last_lookups(nd, file, op)) != NULL)
			;
		if (!error)
			error = do_open(nd, file, op);
		terminate_walk(nd);
	}
	if (likely(!error)) {
		if (likely(file->f_mode & FMODE_OPENED))
			return file;
		WARN_ON(1);
		error = -EINVAL;
	}
	fput_close(file);
	if (error == -EOPENSTALE) {
		if (flags & LOOKUP_RCU)
			error = -ECHILD;
		else
			error = -ESTALE;
	}
	return ERR_PTR(error);
}
```

ここまでで大体イメージはできてきた。
creat関数はinodeとpathnameを結びつける作業を行っている。
creat時点ではデータの格納は行っていない（writeするデータがわかっていないのでできない)なので、まず行っているのはinodeの作成とディレクトリエントリ登録と、その後のプロパティの設定と思われる。

### 新ファイルの出力はどのシステムコールでできるのか？
基本的にファイルを作るときはcreat → (read) → write → closeの順でシステムコールを呼ぶ。
creatはinodeとpathnameを結びつける作業をしているとすれば
write部分でデータの格納とinodeに割り当てたデータブロックの情報を書いているだろう。

おそらく、何データブロックを確保するかは、最後まで書き込まないとわからないため
以下の順番で行われると考えられる。

書き込めるデータブロックがないので、まずはデータブロックを確保し、inodeに記録する。
↓
そのブロックに順次データを書き込む
↓
書きこみきれない場合、新たなデータブロックを確保しinodeに場所を記録する。

という流れがいいだろう。
おそらくバッファリングの推奨サイズがデータブロックになっていることが多いのは、
ブロックごとにバッファリングをすることにより、次のデータブロックを確保するかの判定回数が最少で済むのも関係していると考えれば、writeシステムコールがこのような作業を行っている根拠となる。


### (a)についての回答
順番は以下の通りに行われる。

----ここからcreat ------------

プロパティの格納（inodeの確保・初期化)

ディレクトリエントリに追加

-----ここまでcreat--ここからwrite---

データブロックの確保

データの書き込み

-----ここまでwrite-----

データブロックの確保とデータの書き込みに関しては、データの書き込みが終了するまでループしているようなイメージになると思われる。



### (b)についての回答

プロパティの格納とディレクトリエントリの追加の時点でクラッシュした場合、
どのディレクトリエントリにもinodeが記載されていないにもかかわらず、ファイル名や基準パスなどが入っているinodeが残ってしまうと思われる。

ディレクトリエントリに追加とデータブロックの確保までの間にクラッシュした場合、
データブロックが確保されていないinodeが残るようになると思われる。つまりinodeとディレクトリエントリはあるものの、データの参照先がなく開くことができないようない（壊れているファイル？）が残ってしまうのではないだろうか？

データブロックの確保とデータの書き込みの間にクラッシュが発生した場合、ファイル自体は作成されてるように見えているがデータが途中で途切れているようなファイルが残ると思われる。

### (c)についての回答
Manページで確認したところ、fsckは単なるフロントエンドに過ぎないので、実際の挙動は各ファイルシステムごとのfsckを確認する必要があるとのこと。
今回はe2fsckというext2/3/4に対応したfsckを確認したところ、-Cオプションとfdでファイルシステムチェックの進行状況を確認できるよウなので実行してみることにする。


```
taichi84@DESKTOP-LFCUOR7:~/learning/unix_linux_programing/chapter4/question/4.19$ sudo debugfs -w /dev/loop0 -R "dirty"
debugfs 1.46.5 (30-Dec-2021)
taichi84@DESKTOP-LFCUOR7:~/learning/unix_linux_programing/chapter4/question/4.19$ sudo e2fsck -v -C 0 /dev/loop0
e2fsck 1.46.5 (30-Dec-2021)
/dev/loop0 was not cleanly unmounted, check forced.
Pass 1: Checking iノードs, blocks, and sizes
Pass 2: Checking ディレクトリ structure
Pass 3: Checking ディレクトリ connectivity
Pass 4: Checking reference counts
Pass 5: Checking グループ summary information
```

いろいろあるけど、破壊されたループデバイスを作成し、e2fsck -v -C 0 /dev/loop0 を実行した。


- Pass 1: Checking iノードs, blocks, and sizes
- Pass 2: Checking ディレクトリ structure
- Pass 3: Checking ディレクトリ connectivity
- Pass 4: Checking reference counts
- Pass 5: Checking グループ summary information

以上の項目がチェックされるようだ。

inodeのチェックはやはり行われるようだ。
その他、ディレクトリ構成と、孤立しているディレクトリがないか（ディレクトリエントリの作成中などにクラッシュすると孤立したディレクトリが発生する可能性がある？）
また、リンク数がおかしくないか等がチェックされているようである。

inodeのチェックが行われているという意味では、途中で落ちた場合、破損したinodeがないかは調べているのは確実だ。
他はエントリだけ作って実体のないものではないかとかはChecking reference counts等で調べているのだろう。（リファレンスが0のinodeなどが使用中になっていたら明らかにおかしい)
ファイルが書き込み途中かどうだったかを調べるのは難しいのか、その項目はないように見える。




