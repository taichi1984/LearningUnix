# プログラミング課題7.17
## 課題内容
本文で作り始めたピンポンゲームを完成させなさい。
スコア、マルチプレイヤー、バンパーなど、プレイ、コーディングしておもしろそうなものを考えつく限り追加しなさい。

## この課題について
ピンポンゲームについては最低限のものを作れるようになっており、シグナルなどの機能はすべて理解している。
あとは実装していくだけで、Linux理解には関係ないので、最低限のものを作ることにする。
課題、7.11.3で指定された、ラケット、ボールをサーブするためのロジック、ラケットでボールを跳ね返すロジック、ボールが打ち返せなかったことを判定するロジックを追加したものを貼っておく

## bounce2d.c
bounce2d.c
```

/* bounce2d 1.0
 * 文字(デフォルトは'Q')を画面の端で弾ませる。
 * 動きは複数のパラメータによって定義される。
 * ユーザー入力 :w ラケットを上に動かす
 *               s ラケットを下に動かす
 *               スペース　サーブを打つ（１回のみ）
 *               Q 終了
 *
 *               キーボード読み出しでブロックされるが、タイマチックはSIGALRMを送り、それはball_moveにキャッチされる。
 *
 * コンパイル方法: gcc bounce2d.c set_ticker.c -lcurses -o bounce2d
 */

#include "bounce.h"
#include <curses.h>
#include <signal.h>

struct ppball the_ball;
struct racket the_racket;
void set_up();
void wrap_up();
void set_ticker(int);
void ball_move(int);
int bounce_or_lose(struct ppball *bp, struct racket *rk);
/** メインループ **/

int main() {
  int c;
  int served = 0;
  set_up();

  while ((c = getchar()) != 'Q') {
    if (c == 'w') {
      if (the_racket.y_pos > TOP_ROW) {
        the_racket.y_pos--;
        mvaddch(the_racket.y_pos + 1, RIGHT_EDGE + 1, BLANK);
        mvaddch(the_racket.y_pos, RIGHT_EDGE + 1, the_racket.symbol);
        if (served == 0) {
          the_ball.y_pos = the_racket.y_pos;
          mvaddch(the_ball.y_pos + 1, the_ball.x_pos, BLANK);
          mvaddch(the_ball.y_pos, the_ball.x_pos, the_ball.symbol);
        }
      }
    } else if (c == 's') {
      if (the_racket.y_pos < BOT_ROW) {
        the_racket.y_pos++;
        mvaddch(the_racket.y_pos - 1, RIGHT_EDGE + 1, BLANK);
        mvaddch(the_racket.y_pos, RIGHT_EDGE + 1, the_racket.symbol);
        if (served == 0) {
          the_ball.y_pos = the_racket.y_pos;
          mvaddch(the_ball.y_pos - 1, the_ball.x_pos, BLANK);
          mvaddch(the_ball.y_pos, the_ball.x_pos, the_ball.symbol);
        }
      }
    } else if (c == ' ' && served == 0) {
      signal(SIGALRM, ball_move);
      set_ticker(1000 / TICKS_PER_SEC);
      served = 1;
    }
    refresh();
  }

  wrap_up();
}
void set_up_wall() {
  /*上側の壁*/
  for (int i = LEFT_EDGE; i < RIGHT_EDGE; i++)
    mvaddch(TOP_ROW - 1, i, UNDER_WALL_SYMBOL);
  /*下側の壁*/
  for (int i = LEFT_EDGE; i < RIGHT_EDGE; i++)
    mvaddch(BOT_ROW + 1, i, UNDER_WALL_SYMBOL);
  /*左側の壁*/
  for (int i = TOP_ROW; i <= BOT_ROW + 1; i++)
    mvaddch(i, LEFT_EDGE - 1, SIDE_WALL_SYMBOL);
  /*右側の壁、ラケットを置くために開ける。*/
  //  for (int i = TOP_ROW; i <= BOT_ROW + 1; i++)
  //   mvaddch(i, RIGHT_EDGE + 1, SIDE_WALL_SYMBOL);
}

void set_up()
/*
 * 構造体、その他のものを初期化する。
 */
{

  the_racket.y_pos = TOP_ROW + 2;
  the_racket.symbol = RACKET_SYMBOL;
  the_ball.y_pos = the_racket.y_pos;
  the_ball.x_pos = X_INIT;
  the_ball.y_ttg = the_ball.y_ttm = Y_TTM;
  the_ball.x_ttg = the_ball.x_ttm = X_TTM;
  the_ball.y_dir = 1;
  the_ball.x_dir = 1;
  the_ball.symbol = DFL_SYMBOL;

  initscr();
  noecho();
  crmode();

  signal(SIGINT, SIG_IGN);
  mvaddch(the_racket.y_pos, RIGHT_EDGE + 1, the_racket.symbol);
  mvaddch(the_ball.y_pos, the_ball.x_pos, the_ball.symbol);
  set_up_wall();

  refresh();
  // signal(SIGALRM, ball_move);
  // set_ticker(1000 / TICKS_PER_SEC);
}

void wrap_up() {
  set_ticker(0);
  endwin();
}
void racket_move(int c) {}

void ball_move(int signum) {
  int y_cur, x_cur, moved;

  signal(SIGALRM, SIG_IGN);

  y_cur = the_ball.y_pos;
  x_cur = the_ball.x_pos;
  moved = 0;

  if (the_ball.y_ttm > 0 && the_ball.y_ttg-- == 1) {
    the_ball.y_pos += the_ball.y_dir;
    the_ball.y_ttg = the_ball.y_ttm;
    moved = 1;
  }

  if (the_ball.x_ttm > 0 && the_ball.x_ttg-- == 1) {
    the_ball.x_pos += the_ball.x_dir;
    the_ball.x_ttg = the_ball.x_ttm;
    moved = 1;
  }

  if (moved) {
    // mvaddch(y_cur, x_cur, BLANK);
    mvaddch(y_cur, x_cur, BLANK);
    mvaddch(the_ball.y_pos, the_ball.x_pos, the_ball.symbol);
    if (bounce_or_lose(&the_ball, &the_racket) == -1) {
      move(BOT_ROW + 5, LEFT_EDGE + 5);
      addstr("LOST_BALL");
    }

    move(LINES - 1, COLS - 1);
    refresh();
  }
  signal(SIGALRM, ball_move);
}

int bounce_or_lose(struct ppball *bp, struct racket *rk) {
  int return_val = 0;
  if (bp->y_pos == TOP_ROW) {
    bp->y_dir = 1;
    return_val = 1;
  } else if (bp->y_pos == BOT_ROW) {
    bp->y_dir = -1;
    return_val = 1;
  }

  if (bp->x_pos == LEFT_EDGE) {
    bp->x_dir = 1;
    return_val = 1;
  } else if (bp->x_pos == RIGHT_EDGE) {
    if (bp->y_pos == rk->y_pos || bp->y_pos == rk->y_pos - 1 ||
        bp->y_pos == rk->y_pos + 1) { // 判定を甘めに設定
      bp->x_dir = -1;
      return_val = 1;
    } else {
      return_val = -1;
    }
  }

  return return_val;
}
```

bounce.h
```

/* boucne.h */

/* ゲームのための設定 */

#define BLANK ' '
#define DFL_SYMBOL 'o'
#define TOP_WALL_SYMBOL '-'
#define UNDER_WALL_SYMBOL '_'
#define SIDE_WALL_SYMBOL '|'
#define RACKET_SYMBOL 'R'

#define TOP_ROW 5
#define BOT_ROW 20
#define LEFT_EDGE 10
#define RIGHT_EDGE 70
#define X_INIT RIGHT_EDGE - 1
#define Y_INIT 10
#define TICKS_PER_SEC 50

#define X_TTM 5
#define Y_TTM 8

/** ピンポン玉 **/

struct ppball{
  int y_pos, x_pos,
      y_ttm, x_ttm,
      y_ttg, x_ttg,
      y_dir, x_dir;
      char symbol;
  };

struct racket{
  int y_pos,size;
  char symbol;
};
```

set_ticker.c (描画処理のためのticker）
```

#include <sys/time.h>
#include <stddef.h>

/* [from set_ticker.c]
 * set_ticker(number_of_milliseconds)
 * SIGALRMが周期的に発行されるようにインターバルタイマを設定する
 * エラーなら-1、成功なら0を返す。
 * 引数はミリ秒単位なので、秒とマイクロ秒の組み合わせに変換する
 * 注意 : set_ticker(0)とすると、シグナルは送られない
 */

int set_ticker(int n_msecs) {
  struct itimerval new_timeset;
  long n_sec, n_usecs;

  n_sec = n_msecs / 1000;
  n_usecs = (n_msecs % 1000) * 1000L;

  new_timeset.it_interval.tv_sec = n_sec;
  new_timeset.it_interval.tv_usec = n_usecs;
  new_timeset.it_value.tv_sec = n_sec;
  new_timeset.it_value.tv_usec = n_usecs;

  return setitimer(ITIMER_REAL, &new_timeset, NULL);
}
```


