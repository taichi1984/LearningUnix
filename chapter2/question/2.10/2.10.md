# プログラミング問題 2.10      
      
## 課題内容      
** アイデンティティの危機 **  whoのmanページには、コマンドの使い方としてwho am iという形式も可能だと書かれている。      
またwhoami という形式も書かれている。who2.cを書き換えて、who am i という使い方をサポートしなさい。また、whoamiコマンドを試し、      
manページを読みなさい。whoami と who am i は何が違うのか説明しなさい。      
whoamiのように動作するプログラムを書きなさい。      
      
## who am iの仕様の確認      
      
who am i はwho am iというコマンドではなくwhoに二つコマンドライン引数をつけたもの。      
二つのコマンドライン引数は別になんでもよく、who a b とかでも構わない。      
つまり、whoに追加すべき内容は、whoのコマンドライン引数が２つあった場合に、自分のセッションと同一の情報のみ取得するという形になる。      
      
## who am iを書いた      
      
```      
/*whoの最初のバージョン*/      
#include "utmplib.c"      
#include <fcntl.h>      
#include <libgen.h>      
#include <pwd.h>      
#include <stdio.h>      
#include <stdlib.h>      
#include <string.h>      
#include <time.h>      
#include <unistd.h>      
#include <utmp.h>      
      
#define SHOWHOST      
void show_info(struct utmp *utbufp);      
void showtime(long timeval);      
      
int main(int argc, char *argv[]) {      
      
  struct utmp *utbufp;      
  char *username = ttyname(0);      
  if (strncmp(username, "/dev/", 5) == 0) {      
    username += 5;      
  }      
  if (utmp_open(UTMP_FILE) == -1) {      
    perror(UTMP_FILE);      
    exit(1);      
  }      
  if (argc == 3) {      
    while ((utbufp = utmp_next()) != ((struct utmp *)NULL)) {      
      if (strncmp(utbufp->ut_line, username, UT_NAMESIZE) == 0) {      
        show_info(utbufp);      
      }      
    }      
  } else {      
    while ((utbufp = utmp_next()) != ((struct utmp *)NULL))      
      show_info(utbufp);      
  }      
  utmp_close();      
  return 0;      
}      
void show_info(struct utmp *utbufp) {      
  if (utbufp->ut_type != USER_PROCESS)      
    return;      
  printf("%-8.8s", utbufp->ut_name);      
  printf(" ");      
  printf("%-8.8s", utbufp->ut_line);      
  printf(" ");      
  showtime(utbufp->ut_time);      
      
#ifdef SHOWHOST      
  printf("(%s)", utbufp->ut_host);      
#endif      
  printf("\n");      
}      
      
void showtime(long timeval) {      
  time_t t = (time_t)timeval;      
  char *cp = ctime(&timeval);      
  printf("%12.12s", cp + 4);      
}      
```      
      
### 端末の情報とut_lineの比較。      
ttyname(0)で端末の名前を取得した上で、ut_lineと比較する必要がある。      
その際にttynameはttyの全パスを取得するがut_lineは/dev/の部分が省略されているため単純に比較しても一致しない。      
ttynameの/dev/の部分を省略するために、ttynameの最初の5文字が/dev/と一致していたら、ポインタを5バイト後ろにずらすことで対応する。(最初の5文字を無視する。)      
      
      
あとはコマンドライン引数が二つあった場合というifの処理を作り、ut_lineとttynameで取得したusernameを比較して一致していたレコードのみを表示すればよい。      
      
### 実際に作って学んだ注意点。      
wslでログインした場合、ttynameが空欄になってしまうことがある。(wslはログインまわりが上手くできておらず、ttyname(0)がNULLを返すことがある)　そのため、segmentation faultが発生し上手く動かない場合があるので、リモートの実機などでSSHログインして確認する必要がある。      
      
## whoamiについて      
      
whoamiはwhoコマンドとは実は関係なく、別のコマンドである。      
現在のユーザーidを表示するだけのプログラム。      
      
## whoamiを書いてみる。      
      
```      
      
#include <pwd.h>      
#include <stdio.h>      
#include <stdlib.h>      
#include <unistd.h>      
      
int main() {      
  struct passwd *pw = getpwuid(getuid());      
  if (pw) {      
      
    printf("%s\n", pw->pw_name);      
  } else {      
    perror("getpwuid");      
    return 1;      
  }      
  return 0;      
}      
```      
      
getpwuid(getuid())で返ってくる構造体からpw_nameを表示すればいいだけ。      
これだけの機能なので、たいして難しくはない。      
      
## この課題で学んだ関数    
    
### ttyname(int fd)    
    
ファイルディスクリプタに対応する端末の名前（パス）を返す関数    
    
例：/dev/pts/2 みたいなのが返ってくる    
    
よく使うのは ttyname(0)（標準入力）で、自分のターミナルを調べる    
    
NULLが返ることもあるので NULLチェックは必須。    
    
### strncmp(const char *s1, const char *s2, size_t n)    
    
n文字分だけ文字列を比較する関数    
    
完全一致ではなく、先頭nバイトの比較（なので、utmpの固定サイズ比較に便利）    
    
戻り値：    
    
0：一致    
    
<0 / >0：辞書順で前後してる    
    
### getpwuid(uid_t uid)    
    
ユーザーIDからpasswd構造体へのポインタを返す    
    
よく使う組み合わせ：    
getpwuid(getuid())->pw_name → 今のログインユーザー名    
    
ログイン情報表示とかwhoamiの再現で使う    
    
## C言語におけるファイルディスクリプタとstdin等の予約語について    
unix/linuxでは、全ての入出力はファイルとして扱われる。    
ターミナルやソケットもファイルディスクリプタ(整数)で表される。    
    
| 番号 | 意味      | C言語での名前  | 説明                                |
| -- | ------- | -------- | --------------------------------- |
| 0  | 標準入力    | `stdin`  | キーボード入力など（`scanf` や `fgets` が読む元） |
| 1  | 標準出力    | `stdout` | 普通の `printf` が出力する先（通常は画面）        |
| 2  | 標準エラー出力 | `stderr` | エラー系 `fprintf(stderr, ...)` の出力先  |
    
ttyname(0)の意味は標準入力がどのデバイスとつながっているかを調べることになる。    
    
### 引数0よりstdinのほうがよくない？っていう疑問について    
ttyname() の引数は「ファイルディスクリプタ（int）」じゃないといけません。    
    
でも stdin は実際には以下のように定義されている：    
    
```    
#define stdin ((FILE *)__stdin)    
```    
    
つまり：    
    
stdin は FILE * 型（ポインタ）    
    
ttyname() の引数には int 型（fd）を渡す必要がある    
    
➡ ttyname(stdin) は「型が違う」から、コンパイルはできるかもしれないけど未定義動作になります（最悪セグフォ）。    
    
    
一応 fileno(stdin)でfdは取れるが、UNIXの世界ではttyname(0)が主流。    
お作法だと思っておくといい模様。    
    
    
