# プログラミング課題　2.12  
  
## 課題内容  
** ファイル対API ** 私たちは処理効率を上げるためにutmplib.cを作ったが、実はこれには副産物がある。  
その副産物とは、データファイルを関数セット(API)に置き換えたということだ。このAPIはログインユーザーを表すものでは  
ないものも含め、全てのutmp構造体を返す。しかし、whoコマンドが必要とするものは、アクティブセッションを表すレコードだけである。  
アクティブセッションを表すレコードだけを返すように、utmplib.cを書き換えなさい。  
この変更は、who3.cの他のソースコードファイルにどのような影響を与えるか説明しなさい。  
このような変更はそもそも良い考えだといえるか。結論と理由を述べなさい。  
  
## utmplib.cとwho3.c の改良  
  
```  
  
/* utmpファイルからの読み出しをバッファリングするための関数*  
 *  含まれる関数は次の通り  
 *  
 *  utmp_open( file_name ) ファイルをオープンする。  
 *   ファイルをオープンする。エラーの時には-1を返す。  
 *  utmp_next( ) - 次の構造体を指すポインタを返す。  
 *    eofのときにはNULLを返す。  
 *   utmp_close() - ファイルを閉じる  
 *  
 *   一度の読み出しでNRECS個の構造体を読み出し、バッファから構造体を１つずつ提供する。*/  
  
#include <fcntl.h>  
#include <stdio.h>  
#include <sys/types.h>  
#include <unistd.h>  
#include <utmp.h>  
  
#define NRECS 16  
#define NULLUT ((struct utmp *)NULL)  
#define UTSIZE (sizeof(struct utmp))  
  
static char  
    utmpbuf[NRECS *  
            UTSIZE]; // メモリ領域、NRECS個の構造体を一次保存するバッファ  
static int num_recs;     //格納してある個数  
static int cur_rec;      // 次のレコード番号  
static int fd_utmp = -1; //読み出し先  
  
int utmp_reload();  
  
int utmp_open(char *filename) {  
  fd_utmp = open(filename, O_RDONLY);  
  cur_rec = num_recs = 0;  
  return fd_utmp;  
}  
  
struct utmp *utmp_next() {  
  struct utmp *recp;  
  
  while (  
      1) { // ここにループを追加することによって、USER_PROCESSを発見するか、全てのutmpを確保するまで、繰り返す(次のレコードを探し続ける。)。  
    if (fd_utmp == -1)  
      return NULLUT;  
    if (cur_rec == num_recs && utmp_reload() == 0)  
      return NULLUT;  
  
    recp = (struct utmp *)&utmpbuf[cur_rec * UTSIZE];  
    cur_rec++;  
  
    if (recp->ut_type ==  
        USER_PROCESS) // USER_PROCESSであればreturnでループから抜けつつ戻り値を返す。  
      return recp;  
  }  
}  
  
int utmp_reload() {  
  int amt_read;  
  
  amt_read = read(fd_utmp, utmpbuf, NRECS * UTSIZE);  
  
  num_recs = amt_read / UTSIZE;  
  cur_rec = 0;  
  return num_recs;  
}  
  
void utmp_close() {  
  if (fd_utmp != -1)  
    close(fd_utmp);  
}  
  
```  
  
who3.c側の改良  
  
```  
/* whoのutmplib.c側でUSER_PROCESSのみ判別させているのバージョン *  
 */  
#include "utmplib.c"  
#include <fcntl.h>  
#include <stdio.h>  
#include <stdlib.h>  
#include <time.h>  
#include <unistd.h>  
#include <utmp.h>  
  
#define SHOWHOST  
void show_info(struct utmp *utbufp);  
void showtime(long timeval);  
  
int main() {  
  
  struct utmp *utbufp;  
  
  if (utmp_open(UTMP_FILE) == -1) {  
    perror(UTMP_FILE);  
    exit(1);  
  }  
  
  while ((utbufp = utmp_next()) != ((struct utmp *)NULL))  
    show_info(utbufp);  
  utmp_close();  
  return 0;  
}  
void show_info(struct utmp *utbufp) {  
 /* if (utbufp->ut_type != USER_PROCESS)  
    return; この部分はutmplib.cが受け持つようになったため不要なので削除*/  
  printf("%-8.8s", utbufp->ut_name);  
  printf("%-8.8s", utbufp->ut_name);  
  printf(" ");  
  printf("%-8.8s", utbufp->ut_line);  
  printf(" ");  
  showtime(utbufp->ut_time);  
  
#ifdef SHOWHOST  
  printf("(%s)", utbufp->ut_host);  
#endif  
  printf("\n");  
}  
  
void showtime(long timeval) {  
  time_t t = (time_t)timeval;  
  char *cp = ctime(&timeval);  
  printf("%12.12s", cp + 4);  
}  
```  
  
show_info()にあったut_typeがUSER_PROCESSであるかを判別する文を削除しても  
きちんとUSER_PROCESSのみ出すようになる。  
  
### この変更はよいと思うか？  
この変更を行ったことにより、utmp_lib.cで出来ることは、ut_typeがUSER_PROCESSのutmpレコードを返すライブラリに機能が変わってしまった。  
この変更によって、使う側は楽になったものの、utmplib.cの機能自体の汎用性は大きく下がったといえる。  
単純にこのように変更するのはあまりよくないと思われる。  
utmp_next()関数の名前もあまりふさわしいとは思えない。  
  
これがC言語ではなく、オブジェクト指向機能のある言語であって、utmpの情報を得るクラスの機能として  
utmpのレコードのリストを返すような関数が、引数によって、USER_PROCESSのもののみのリストを返したり、全部のレコードのリストを返したりとするならば  
いい作りになってるといえるが、次のutmp構造体を探して返すだけの関数に、USER_PROCESSのもののみを返すようなロジックを組み込むのは不自然に見える。  
少なくとも、utmp_next()関数の引数次第で、USER_PROCESSのもののみを返すようにするなどの工夫がないと、utmplib.cの汎用性が損なわれてしまうので、  
非常に不自然に思えて、あまりいい案とは思えない。  
モジュールの責務を分離する観点から見ても、  
基本的にはこのつくりなら、utmp_next()が次の構造体を返すようにしつつ、使う側でどれを表示するかなどを制御するのがスマートに思える。  
そしてその場合、who3.cの25行目のshowinfoをするところで、showinfoをするかどうかをutbufp->ut_type == USER_PROCESS　ならばshowinfo(utbufp)をするのが、切り分け方としては自然と思われる。  
  
  
  
    
  
  
