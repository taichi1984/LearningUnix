# プログラミング課題3.13  
  
## 課題内容  
  
標準のcpユーティリティは、第２引数をディレクトリ名にすることができる。  
その場合、ファイルはディレクトリ内に同じ名前でコピーされる。つまり、次のコードは  
  
$cp file1 /tmp  
  
次のコマンドと同じ効果を持つ  
  
$cp file1 /tmp/file1  
  
このような動作になるように、第２章のcp1.cプログラムを書き換えなさい。  
  
  
## cp1.cをまずは確認  
  
```  
  
#include <fcntl.h>  
#include <stdio.h>  
#include <stdlib.h>  
#include <unistd.h>  
  
#define BUFFERSIZE 4096  
#define COPYMODE 0644  
  
void oops(char *, char *);  
  
int main(int ac, char *av[]) {  
  
  int in_fd, out_fd, n_chars;  
  char buf[BUFFERSIZE];  
  
  if (ac != 3) {  
    fprintf(stderr, "usage: %s source desination\n", *av);  
    exit(1);  
  }  
  
  if ((in_fd = open(av[1], O_RDONLY)) == -1)  
    oops("Cannot open ", av[1]);  
  if ((out_fd = creat(av[2], COPYMODE)) == -1)  
    oops("Cannot creat ", av[2]);  
  
  while ((n_chars = read(in_fd, buf, BUFFERSIZE)) > 0)  
    if (write(out_fd, buf, n_chars) != n_chars)  
      oops("Write error to ", av[2]);  
  
  if (n_chars == -1)  
    oops("Read error from ", av[1]);  
  
  if (close(in_fd) == -1 || close(out_fd) == -1)  
    oops("Error closing files", "");  
}  
  
void oops(char *s1, char *s2) {  
  fprintf(stderr, "Error : %s ", s1);  
  perror(s2);  
  exit(1);  
}  
  
```  
  
シンプルなつくりのcpで引数１を引数２にコピーする。  
引数２のファイル名がない場合は新たに作り、同じファイル名がある場合は上書きする作りになっている。  
このまま第２引数にディレクトリ(dirとする)指定するとCannot Creat : dir is dirrectory   
といったエラーがでてcreatできない。  
  
## 対応プラン  
第２引数であるav[2]をstatし以下の条件でcreatに指定するパスを組みなおす。  
  
stat出来なかった場合⇒　そのようなファイルはないと考えてav[2]でcreatする。  
stat出来てかつディレクトリではなかった場合 ⇒　ディレクトリではないのでav[2]でそのままcreatする。  
stat出来てかつディレクトリだった場合 ⇒　directory/fileのような形で文字列を結合して、creatする。  
  
これでcreat可能なはず。  
  
## 新たに作ったcp3.c  
  
```  
#include <fcntl.h>  
#include <stdio.h>  
#include <stdlib.h>  
#include <string.h>  
#include <sys/stat.h>  
#include <unistd.h>  
  
#define BUFFERSIZE 4096  
#define COPYMODE 0644  
  
void oops(char *, char *);  
  
int main(int ac, char *av[]) {  
  
  int in_fd, out_fd, n_chars;  
  char buf[BUFFERSIZE];  
  struct stat target;  
  char out_path[255] = "";  
  
  if (ac != 3) {  
    fprintf(stderr, "usage: %s source desination\n", *av);  
    exit(1);  
  }  
  
  if ((in_fd = open(av[1], O_RDONLY)) == -1)  
    oops("Cannot open ", av[1]);  
  
  if (stat(av[2], &target) != -1) {  
    if (S_ISDIR(target.st_mode)) {  
      strcat(out_path, av[2]);
      strcat(out_path,"/");
      strcat(out_path,av[1]);
    } else {  
      strcat(out_path, av[2]);  
    }  
  } else {  
    strcat(out_path, av[2]);  
  }  
  
  if ((out_fd = creat(out_path, COPYMODE)) == -1)  
    oops("Cannot creat ", out_path);  
  
  while ((n_chars = read(in_fd, buf, BUFFERSIZE)) > 0)  
    if (write(out_fd, buf, n_chars) != n_chars)  
      oops("Write error to ", av[2]);  
  
  if (n_chars == -1)  
    oops("Read error from ", av[1]);  
  
  if (close(in_fd) == -1 || close(out_fd) == -1)  
    oops("Error closing files", "");  
}  
  
void oops(char *s1, char *s2) {  
  fprintf(stderr, "Error : %s ", s1);  
  perror(s2);  
  exit(1);  
}  
  
```  
  
creatする場所で第２引数をstat()し、処理を分岐させた。  
  
```  
if (stat(av[2], &target) != -1) {  
    if (S_ISDIR(target.st_mode)) {  
      strcat(out_path, strcat(strcat(av[2], "/"), av[1]));  
    } else {  
      strcat(out_path, av[2]);  
    }  
  } else {  
    strcat(out_path, av[2]);  
  }  
  
```  
  
## 動作確認  
```  
$ echo "Hello world" > test  
$ touch aaa  
$ ls  
3.13.md  aaa  cp3  cp3.c  test  testdir  //testdir は空ディレクトリ  
  
/* 空のディレクトリにtestをコピー */  
$ ./cp3 test testdir  
$ ls testdir  
test   //無事コピーできている。  
  
/* 既に存在する空ファイルにコピー */  
$ ./cp3 test aaa  
$ cat aaa  
Hello world   //問題なくコピーできている  
  
/* 存在しないファイル名にコピー */  
$ ./cp3 test abcde  
$ ls  
3.13.md  aaa  abcde  cp3  cp3.c  test  testdir  
$ cat abcde  
Hello world  //問題なくコピーでき、中身も確認できた。  
  
```  
  
  
  
