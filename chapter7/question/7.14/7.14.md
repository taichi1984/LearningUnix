# プログラミング課題7.14
## 課題内容
図 7-14で１個の実クロックで２つの異なるタイマを駆動する仕組みを示したが、この練習問題では、この仕組みをユーザーレベルのプログラムでシミュレーションする。
まず、第６章のOUCHプログラムである、sigdemo1.cをもとに、ouch.cというプログラムを書く。
ouch.cは、コマンド行引数としてシグナルハンドラが出力するメッセージと、
メッセージ出力までにすぐなるハンドラ呼び出しが何回発生しなければならないかを示す数値の２つを受け付ける。

たとえば次のようにすると

$ ouch hello 10 &

SIGINTを１０回受け取るたびに"hello"というメッセージを出力するプログラムがバックグラウンドで実行される。
次にコマンド行引数として、インターバルとプロセスIDのリストを受け付けるmetronome.cというプログラムを書く。
このプログラムは、インターバルタイマを使って、１秒１つずつSIGALRMを生成する。（最初のコマンド行引数として１を指定した場合）。
そしてシグナルハンドラは、killシステムコールを使って、コマンド行で指定された全てのプロおセスにSIGINTを送る。
例えば次のようにすると、

$ metronome 1 3456 7777 2345

3456,7777,2345という３つのプロセスに毎秒１回ずつSIGINTが送られる。
以上の準備が出来たら、毎回異なるメッセージと異なるインターバルでouchのインスタンスを３個バックグラウンドで実行し、
それら３個のプロセスのIDを記録する。
そして、コマンド行引数として、１とこれらの３つのプロセスIDを指定して、metronomeプログラムを実行しなさい。

## プログラムコード
### ouch.c

```

#include <signal.h>
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>

int num = 0;
int print_flag = 0;

int main(int ac, char *av[]) {
  if (ac != 3) {
    fprintf(stderr, "usage : ouch [message] [times] ");
  }

  void f(int);

  int times = atoi(av[2]);

  signal(SIGINT, f);
  while (1) {
    pause();
    if (num % times == 0) {
      printf("%s\n", av[1]);
    }
  }
}

void f(int signum) { num++; }

```

### metronome.c

```
#include <signal.h>
#include <stdlib.h>
#include <unistd.h>

#include <sys/time.h>

int do_sigint = 0;

int main(int ac, char *av[]) {

  int processes[ac - 2];
  int timersec = atoi(av[1]);
  struct itimerval new_timeset;
  void send_sigint(int signum);
  for (int i = 2; i < ac; i++) {
    processes[i - 2] = atoi(av[i]);
  }

  signal(SIGALRM, send_sigint);
  new_timeset.it_interval.tv_sec = timersec;
  new_timeset.it_interval.tv_usec = 0;
  new_timeset.it_value.tv_sec = timersec;
  new_timeset.it_value.tv_usec = 0;

  setitimer(ITIMER_REAL, &new_timeset, NULL);

  while (1) {
    pause();
    if (do_sigint == 1) {
      for (int i = 0; i < ac - 2; i++) {
        kill(processes[i], SIGINT);
      }
      do_sigint = 0;
    }
  }
}

void send_sigint(int signum) { do_sigint = 1; }

```

## 実行結果 

```

$ ./ouch test1 2 &
[5] 21090
$ ./ouch test2 5 &
[6] 21093
$ ./ouch test3 10 &
[7] 21094
$ ./metronome 1 21090 21093 21094
test1
test1
test2
test1
test1
test2
test1
test3
test1
test1
test2
test1
test1
test2
test1
test3
test1
test1
test2
test1
test1
test2
test1
test3
test1
test1
```

同時に表示される１０の倍数時の表示はどのプロセスが先に表示されるかはおそらくOS側のスケジューラに依存していると思われるが、動作自体はしっかり行われているようだ。


