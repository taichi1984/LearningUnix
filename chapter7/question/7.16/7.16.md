# プログラミング課題 7.16
## 課題内容
**反応時間テスター** ユーザーがどれぐらい素早く反応できるかを計測するプログラムを書きなさい。
このプログラムは、ランダムな時間だけ待って、画面に数字を１つ出力する。
ユーザーは、同じ数字をできるだけ早く入力しなければならない。
プログラムは、ユーザーが反応するまでにどれだけの時間がかかったかを記録する。
そのようなテストを１０回実行し、最短、最長、平均反応時間を出力すること。
(ヒント:gettimeofdayのマニュアルページを読むと良い)

## 設計案
### 設定
main関数の最初に端末設定を保存（終了時の復元のため）
端末設定に非カノニカルモードとECHOのオフを追加。
非カノニカルモード時の受付文字数を１に。待ち時間は０に設定する。
O_ASYNCとO_NONBLOCKも指定する。
signal(SIGIO,push_number)でSIGIOを検知したらpush_number（SIGIOが呼ばれたかどうかのフラグを立てる）関数を実行する。

### メインの設計
SIGIOが呼ばれてない場合の処理（ユーザーが反応してキーを押す前の処理）SIGIOが呼ばれた場合の処理（キーを押したあとの処理）、指定回数（今回は１０回）プレイしたときに結果を表示する処理に分ける。

まずSIGIOが呼ばれてないときの処理(pushedフラグが0のときの処理)

まず、rand関数を設定する。
メインループの最初にwait(0~6秒)と、表示する数値(0~9)をランダムに設定
push number!の表示のあとにsleep(wait)で待たせたあとにランダムで設定した数値を表示。
表示した直後の時間を記録しておく。
そこからpause()でメインスレッドを停止する。

SIGIOが呼ばれたあとの処理(pushedフラグが１のときの処理）は以下の通り。
まずSIGIOが呼ばれたことによりpause()が解除される。push_numberハンドラでは、pushed(ボタンが押されたかどうかのフラグ）を１にする。
SIGIOが呼ばれたあとには、入力されたキーが表示されたキーとあっているかを確認。
あっている場合は、そこで時間を計測し、最初に記録した開始時間を引いて、その間にかかった時間を表示する。
そして、プレイした秒数を記録しておくdouble型の配列に記録しておく。
残りプレイ回数を減らし、何回プレイしたかの回数を増やす。そしてボタンが押されたかどうかのフラグを０に戻してループの最初に戻る。

間違っている場合は、wrong_numberと表示し、ボタンが押されたかどうかのフラグを０に戻してループの最初に戻る。

10回プレイしてFinishの処理をしたらループを抜ける。
Finish時の処理は
Finishを表示、
平均時間の表示
最速時間の表示
最遅時間の表示を行う。

平均時間、最速時間、最遅時間の表示は各関数を用意して行う。
計測時間を記録したdouble型の配列のポインタを引数にして、double型の数値を返すようにインターフェースを設計する。


## プログラムコード
```
#define _GNU_SOURCE
#include <fcntl.h>
#include <signal.h>
#include <stdio.h>
#include <stdlib.h>
#include <sys/time.h>
#include <termios.h>
#include <time.h>
#include <unistd.h>

#define TOTAL_PLAYS 10
int remain_plays = TOTAL_PLAYS;
int plays = 0;
int pushed = 0;
void tty_set(int order);
void push_number(int signum);
double average_time(double *seconds_array);
double fastest_time(double *seconds_array);
double slowest_time(double *seconds_array);
int main(void) {
  struct termios ts;
  tty_set(0);
  tcgetattr(STDIN_FILENO, &ts);
  ts.c_lflag &= ~(ICANON | ECHO);
  ts.c_cc[VMIN] = 1;
  ts.c_cc[VTIME] = 0;
  tcsetattr(STDIN_FILENO, TCSANOW, &ts);

  int wait = 0;
  int answer = 0;
  struct timeval before, after, laptime;
  char input;
  srand(time(NULL));

  fcntl(STDIN_FILENO, F_SETOWN, getpid());
  fcntl(STDIN_FILENO, F_SETFL, O_ASYNC | O_NONBLOCK);

  signal(SIGIO, push_number);
  double seconds_array[TOTAL_PLAYS];

  while (1) {
    if (pushed == 0) {
      wait = rand() % 6;
      answer = rand() % 9;

      printf("push number!\n");

      sleep(wait);
      printf("%d\n", answer);
      if (gettimeofday(&before, NULL) == -1) {
        perror("gettimeofday");
        tty_set(1);
        exit(1);
      };

      pause();
    }

    if (pushed == 1) {
      read(STDIN_FILENO, &input, 1);
      printf("%c \n", input);
      if ((input - '0') == answer) {
        if (gettimeofday(&after, NULL) == -1) {
          perror("gettimeofday");
          tty_set(1);
          exit(1);
        };

        laptime.tv_sec = after.tv_sec - before.tv_sec;
        laptime.tv_usec = after.tv_usec - before.tv_usec;
        if (laptime.tv_usec < 0) {
          laptime.tv_usec += 1000000;
          laptime.tv_sec -= 1;
        }
        double seconds = laptime.tv_sec + laptime.tv_usec / 1000000.0;

        seconds_array[plays] = seconds;
        printf("%f\n", seconds);
        pushed = 0;
        remain_plays--;
        plays++;
      } else {
        printf("wrong number\n");
        pushed = 0;
      }
    }

    if (remain_plays == 0) {

      for (int i = 0; i < TOTAL_PLAYS; i++) {
        printf("%d : %f seconds\n", i + 1, seconds_array[i]);
      }

      printf("Finish!\n");
      printf("Avarage time: %f\n", average_time(seconds_array));
      printf("Fastest time: %f\n", fastest_time(seconds_array));
      printf("Slowest time: %f\n", slowest_time(seconds_array));
      break;
    }
  }
  tty_set(1);
}

void push_number(int signum) { pushed = 1; }

double average_time(double *seconds_array) {
  double total_seconds = 0;

  for (int i = 0; i < TOTAL_PLAYS; i++) {
    total_seconds += seconds_array[i];
  }

  return total_seconds / TOTAL_PLAYS;
}

double fastest_time(double *seconds_array) {
  double fastest_time = seconds_array[0];

  for (int i = 1; i < TOTAL_PLAYS; i++) {
    if (fastest_time > seconds_array[i]) {
      fastest_time = seconds_array[i];
    }
  }

  return fastest_time;
}

double slowest_time(double *seconds_array) {
  double slowest_time = seconds_array[0];

  for (int i = 1; i < TOTAL_PLAYS; i++) {
    if (slowest_time < seconds_array[i]) {
      slowest_time = seconds_array[i];
    }
  }

  return slowest_time;
}

void tty_set(int order) {
  static struct termios def;

  if (order == 0) {
    tcgetattr(STDIN_FILENO, &def);
  } else if (order == 1) {
    tcsetattr(STDIN_FILENO, TCSANOW, &def);
  }
}

```

## 実行結果
```

push number!
0
0 
1.045960
push number!
2
2 
0.503671
push number!
4
4 
0.910880
push number!
8
8 
1.040659
push number!
6
6 
1.135859
push number!
4
4 
0.838303
push number!
4
4 
0.584383
push number!
6
6 
1.047837
push number!
5
5 
1.063787
push number!
2
2 
4.832583
1 : 1.045960 seconds
2 : 0.503671 seconds
3 : 0.910880 seconds
4 : 1.040659 seconds
5 : 1.135859 seconds
6 : 0.838303 seconds
7 : 0.584383 seconds
8 : 1.047837 seconds
9 : 1.063787 seconds
10 : 4.832583 seconds
Finish!
Avarage time: 1.300392
Fastest time: 0.503671
Slowest time: 4.832583

```

きちんと動いているようです。

