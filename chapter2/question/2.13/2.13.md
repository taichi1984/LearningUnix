# プログラミング課題 2.13  
## 課題内容  
** バッファリングとシーク** 本文のlogout.tty関数は、lseekを使って１レコード分戻り、レコードを書き戻せるようにしていた。  
logout_ttyは、utmpファイルの読み出しの溜めにバッファリングを使っていないことに注意して欲しい。logout_ttyは、バッファリングを使った方が効率的になるはずだ。  
  
(a) utmplib.c の関数とlseekを併用していたら、どのような問題が起きるかを説明しなさい。  
(b) utmplib.c に、次の関数を追加しなさい。  
  
utmp_seek(record_offset,base)  
  
この関数は、lseekがread呼び出しで使われる現在位置を変更するように、utmp_next()呼び出しで使われる現在位置を変更する。  
baseにはSEEK_SET、SEEK_CUR,SEEK_ENDのどれかを指定でき、そこからrecord_offsetこのレコードの分だけ、現在位置を移動できるようにすること。  
この引数は、バイトではなくutmpレコード１個分が単位である。  
  
(c) このバージョンのutmplib.cを使うようにlogout_ttyを書き換えなさい。  
  
## (a)についての回答  
utmplib.cにはseekする機能は持っておらず、前から順番に読みこんだutmpを前から順に戻す機能しかない。  
無理やり使おうとした場合、位置から後ろに戻そうとするたびに呼ぶたびにread()システムコールでファイルの最初から読み直す形になるので非効率。  
  
またlseekは１バイト単位の操作であるが、utmplib.cでは、utmp構造体毎の操作になるため、粒度がバラバラになりかなりコードも読みずらくなる。  
  
## (b)への回答  
utmplib.cのutmp * recpポインタを、utmp_seekと共用で使えるようにする必要がある。  
その後、seek関数の中でrecpポインタを操作する。  
  
```  
  
/* utmpファイルからの読み出しをバッファリングするための関数*  
 *  含まれる関数は次の通り  
 *  
 *  utmp_open( file_name ) ファイルをオープンする。  
 *   ファイルをオープンする。エラーの時には-1を返す。  
 *  utmp_next( ) - 次の構造体を指すポインタを返す。  
 *    eofのときにはNULLを返す。  
 *   utmp_close() - ファイルを閉じる  
 *  
 *   utmp_seek(record_offset , base) - utmp構造体のリストから基準位置からrecord_offset個先の位置までポインタの位置をずらす。  
 *  
 *   一度の読み出しでNRECS個の構造体を読み出し、バッファから構造体を１つずつ提供する。*/  
  
#include <fcntl.h>  
#include <stdio.h>  
#include <sys/types.h>  
#include <unistd.h>  
#include <utmp.h>  
  
#define NRECS 16  
#define NULLUT ((struct utmp *)NULL)  
#define UTSIZE (sizeof(struct utmp))  
  
static char  
    utmpbuf[NRECS *  
            UTSIZE]; // メモリ領域、NRECS個の構造体を一次保存するバッファ  
static int num_recs;     //格納してある個数  
static int cur_rec;      // 次のレコード番号  
static int fd_utmp = -1; //読み出し先  
static struct utmp *recp;  
  
int utmp_reload();  
  
int utmp_open(char *filename) {  
  fd_utmp = open(filename, O_RDONLY);  
  cur_rec = num_recs = 0;  
  return fd_utmp;  
}  
  
struct utmp *utmp_next() {  
  
  if (fd_utmp == -1)  
    return NULLUT;  
  if (cur_rec == num_recs && utmp_reload() == 0)  
    return NULLUT;  
  
  recp = (struct utmp *)&utmpbuf[cur_rec * UTSIZE];  
  cur_rec++;  
  return recp;  
}  
  
int utmp_reload() {  
  int amt_read;  
  
  amt_read = read(fd_utmp, utmpbuf, NRECS * UTSIZE);  
  
  num_recs = amt_read / UTSIZE;  
  cur_rec = 0;  
  return num_recs;  
}  
  
void utmp_close() {  
  if (fd_utmp != -1){  
    close(fd_utmp);  
    fd_utmp = -1;  
  }  
    
}  
  
off_t utmp_seek(int record_offset, int base) {  
  if (fd_utmp == -1) {  
    perror("ファイルディスクリプタが不正です");  
    return -1;  
  }  
    
  if(base != SEEK_SET && base != SEEK_CUR && base != SEEK_END)  
  {  
    perror("第２引数baseが既定の値ではありません。");  
    return(-1);  
  }  
  
  if(lseek(fd_utmp, UTSIZE * record_offset , base) == -1)  
  {  
    perror("不正なシーク");  
    return -1;  
  }  
    
  
  num_recs = 0;  
  cur_rec = 0;  
  
  return lseek(fd_utmp, 0, SEEK_CUR);  
}  
```  
  
  
## (c)への回答  
  
```  
  
/*  
 * logout_tty(char *line)  
 * utmpレコードにログアウトのマークをつける。  
 * ユーザー名やリモートホストの名を空にしない  
 * エラーの時は-1、成功したときは0を返す  
 *  
 */  
#include "utmplib.c"  
#include <fcntl.h>  
#include <stdlib.h>  
#include <string.h>  
#include <time.h>  
#include <unistd.h>  
#include <utmp.h>  
  
int logout_tty(char *line) {  
  int fd;  
  struct utmp *rec;  
  int len = sizeof(struct utmp);  
  int retval = -1;  
  
  if ((fd = utmp_open(UTMP_FILE)) == -1) {  
    perror("utmp ファイルが開けません");  
    exit(1);  
  }  
  
  /*検索して置換する*/  
  while ((rec = utmp_next()) != NULLUT) {  
    if (strncmp(rec->ut_line, line, sizeof(rec->ut_line)) == 0) {  
      rec->ut_type = DEAD_PROCESS;  
      if (time((time_t *)&rec->ut_time) != -1)  
        if (utmp_seek(-1, SEEK_CUR) != -1)  
          if (write(fd, rec, len) == len)  
            retval = 0;  
      break;  
    }  
  }  
  /* ファイルをクローズする */  
  
  utmp_close();  
  return retval;  
}  
```  
  
  
