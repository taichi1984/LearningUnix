# 研究課題  
## 課題内容  
Linuxのカーネルコードを見て、O_APPENDがどこでチェックされているかを調べなさい。自動シークはどのようにして実装されているか？  
  
## O_APPENDはどこでチェックされているか？  
カーネルのopenシステムコールから追ったところ以下の関数でチェックされている。  
```  
inline int build_open_flags(const struct open_how *how, struct open_flags *op)  
```  
  
この関数の  
  
	if (flags & O_APPEND)  
		acc_mode |= MAY_APPEND;
  
という部分でチェックされている。  
この関数は、open_how構造体でもらったフラグをopen_flags構造体に書き込む内容なので、ここでは実際にはシークの実装は書かれていない。  
  
更に追っていく必要がある。  
  
## 自動シークはどのように実装されているか？  
カーネルソースを追っていくのが大変だが  
vfs_write関数の中のgeneric_write_checks()関数で呼ばれている以下の関数で発見できた。  
```  
int generic_write_checks_count(struct kiocb *iocb, loff_t *count)  
{  
	struct file *file = iocb->ki_filp;  
	struct inode *inode = file->f_mapping->host;  
  
	if (IS_SWAPFILE(inode))  
		return -ETXTBSY;  
  
	if (!*count)  
		return 0;  
  
	if (iocb->ki_flags & IOCB_APPEND)  
		iocb->ki_pos = i_size_read(inode);  
  
	if ((iocb->ki_flags & IOCB_NOWAIT) &&  
	    !((iocb->ki_flags & IOCB_DIRECT) ||
	      (file->f_op->fop_flags & FOP_BUFFER_WASYNC)))  
		return -EINVAL;  
  
	return generic_write_check_limits(iocb->ki_filp, iocb->ki_pos, count);  
}  
```  
  
フラグを追加するのはopenで行っているが、appendフラグをみて強制的にシークする作業はwrite側で行っている。  
fdのposをファイルサイズと一致させて、最後の場所を指すようにしているようだ。  
  
## 調査時の情報について  
chatgptによると、ここらへんのファイルシステムの仕様はちょこちょこ変わっており、  
どこがこの処理を持つかは、vfs側がもったり、ファイルシステム固有の処理になったり、変更が加えられているようだ。  
現在の最新のカーネルではこれらの処理は共通処理としてvfs側で処理するような方針になっており、このような実装になっている。  
  
