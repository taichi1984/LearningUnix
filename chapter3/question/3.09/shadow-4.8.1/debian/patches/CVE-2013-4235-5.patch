[Ubuntu note: minor changes had to be made to the original patch due
 to this version of shadow not including commit e65cc6aeb.]

Backport of:

From e666de721aedf6deae8b11bef2e0701cf110f307 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Christian=20G=C3=B6ttsche?= <cgzones@googlemail.com>
Date: Fri, 5 Aug 2022 17:57:27 +0200
Subject: [PATCH] More robust file content copy in copy_tree()

Bail out on read(2) failure, continue on EINTR, support short writes and
increase chunk size.
---
 libmisc/copydir.c | 58 +++++++++++++++++++++++++++++++++++++++++++----
 1 file changed, 54 insertions(+), 4 deletions(-)

Index: shadow-4.2/libmisc/copydir.c
===================================================================
--- shadow-4.2.orig/libmisc/copydir.c
+++ shadow-4.2/libmisc/copydir.c
@@ -712,6 +712,42 @@ static int copy_special (const char *src
 }
 
 /*
+ * full_write - write entire buffer
+ *
+ * Write up to count bytes from the buffer starting at buf to the
+ * file referred to by the file descriptor fd.
+ * Retry in case of a short write.
+ *
+ * Returns the number of bytes written on success, -1 on error.
+ */
+static ssize_t full_write(int fd, const void *buf, size_t count) {
+	ssize_t written = 0;
+
+	while (count > 0) {
+		ssize_t res;
+
+		res = write(fd, buf, count);
+		if (res < 0) {
+			if (errno == EINTR) {
+				continue;
+			}
+
+			return res;
+		}
+
+		if (res == 0) {
+			break;
+		}
+
+		written += res;
+		buf = (const unsigned char*)buf + res;
+		count -= (size_t)res;
+	}
+
+	return written;
+}
+
+/*
  * copy_file - copy a file
  *
  *	Copy a file from src to dst.
@@ -730,8 +766,6 @@ static int copy_file (const char *src, c
 	int err = 0;
 	int ifd;
 	int ofd;
-	char buf[1024];
-	ssize_t cnt;
 
 	ifd = open (src, O_RDONLY|O_NOFOLLOW);
 	if (ifd < 0) {
@@ -769,8 +803,25 @@ static int copy_file (const char *src, c
 		return -1;
 	}
 
-	while ((cnt = read (ifd, buf, sizeof buf)) > 0) {
-		if (write (ofd, buf, (size_t)cnt) != cnt) {
+	while (true) {
+		char buf[8192];
+		ssize_t cnt;
+
+		cnt = read (ifd, buf, sizeof buf);
+		if (cnt < 0) {
+			if (errno == EINTR) {
+				continue;
+			}
+			(void) close (ofd);
+			(void) close (ifd);
+			return -1;
+		}
+		if (cnt == 0) {
+			break;
+		}
+
+		if (full_write (ofd, buf, (size_t)cnt) < 0) {
+			(void) close (ofd);
 			(void) close (ifd);
 			return -1;
 		}
