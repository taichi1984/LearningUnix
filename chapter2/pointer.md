# ポインタについての基本的な知識  
  
## ポインタとは何か？  
メモリのアドレスを格納する変数。  
ポインタは、ある変数の先頭のメモリアドレスを保持する。  
  
## 宣言の仕方  
```  
int *a; // 変数名の前にアスタリスクをつける。  
  
int* a; //こちらも文法的には間違っていないが、紛らわしくなるので、上の書き方に統一しよう。  
```  
  
## ポインタについての注意点  
### ポインタは宣言した時点では何もさしていない  
  
ポインタは宣言した時点では何もさしていないため  
```  
int *a;  
  
*a = 4;  
```  
  
などとやっても何も指していないところに4を代入しようとしているため、セグメンテーションエラーとなる。  
  
### ポインタそのものを表す場合はポインタの変数名をそのまま表記、ポインタが指し示す場所の値を参照したい場合は*変数名という表記にする。  
  
```  
#include<stdio.h>  
#include<stdlib.h>  
  
int main(){  
  int number = 5;  
  int *a;  
  
  a = &number;  
  
  printf("%d \n", *a);  
}  
```  
  
以上のプログラムで説明すると  
int number = 5はint型の変数  
int *aはint型を格納できるポインタ  
  
a = &number;  
  
でnumberのアドレスをaに格納  
  
printf("%d \n", *a);  
  
の部分で、aに格納されているメモリアドレスに格納されている値を表示する。  
  
## ポインタの型について  
### 宣言時の型指定  
ポインタ変数は宣言時にそのポインタの型を宣言する必要がある。  
```  
int *a;  
char *buf;  
  
```  
などのように、型を書いておく必要がある。  
  
### 型指定することの意味  
ポインタに格納されるアドレスは、該当のメモリ領域の先頭部分のアドレスが格納される。  
*pointerのように参照する場合、参照される先はポインタの型に応じただけのメモリ領域を参照する。  
char *buf ならばchar型は１バイトの領域を確保するので1バイトのメモリを参照する。  
int *number なら int型は4バイトの領域を確保するので、4バイトのメモリを参照する  
  
  
### ポインタの計算  
 pointer = pointer+2;  
とした場合、これはポインタにポインタの型の領域*2バイト分、ポインタの指し示すアドレス位置を増やすという操作になる。-なら逆の操作になる。  
  
  
## 文字列とポインタ  
C言語において文字列はchar型の変数の配列です。  
配列はある領域に変数が並んでいる状態になります。  
  
サンプルコード  
```  
#include<stdio.h>  
  
int main(){  
  char buf[30] = "abcdefg"; //30バイトの長さの領域を用意  
  char *buffer = buf; //bufの先頭アドレスをbufferポインタに格納  
  
  printf("%s \n", buf);  
  printf("%s \n", buffer);  
    
  buffer = "ABCDEFG";  
  
  printf("%s \n", buffer);  
  printf("%s \n", buf);  
}  
```  
  
実行結果  
```  
abcdefg  
abcdefg  
ABCDEFG  
abcdefg  
```  
  
実行結果の１行目は、buf[30]に代入した文字列をそのまま表示した形になる。  
実行結果の２行目は、bufferポインタにbufのアドレスを格納したため、同様の内容になる。  
実行結果の３行目は、bufferポインタに別の文字列リテラル"ABCDEFG"のアドレスを格納したため、bufferの文字列が変化し、ABCDEFGが表示される。  
実行結果の４行目は、元のbufを表示しているのでそのまま"abcdefg"を表示している。  
  
重要なところは３つ目で、buffer = "ABCDEFG"にした場合は、あくまでbufferの指し示す先のものを新しい文字列リテラルのアドレスに書き換えただけでbufferに格納されていたbufのアドレスの指し示す要素を書き換えたわけではないのに注意。  
  
## malloc(sizeof(type))とfree(pointer)について  
  
メモリは手動でも確保できる。  
  
```  
#include<stdio.h>  
#include<stdlib.h>  
  
  
int main(){  
 int *number;  
  
 number = malloc(sizeof(int));  
   
 *number = 20;  
  
 printf("%d",*number);  
  
 free(number);  
  
  
}  
  
```  
  
実行結果  
```  
20  
```  
  
numberポインタを宣言後、*number=20;と代入するとポインタがメモリのどこを指し示しているか指定しないためセグメンテーションエラーとなるが  
malloc(sizeof(type))を使うことにより、安全なメモリ領域を確保し、そのアドレスをポインタ変数に格納することができる。  
  
mallocの戻り値をポインタに代入すれば、確保したメモリのアドレスをnumberが参照していることになるので、  
*number = 20;  
としたときにnumberの指し示す先のアドレスの要素を書き換えることができる。  
  
そのため,正しく20と表示される。  
  
mallocで確保したメモリは明示的に解放しないと、ずっと使ってないメモリを確保し続けてしまうので、free(pointer)で明示的に開放しよう。でないと、大きくメモリを確保した場合にメモリリークの原因や、パフォーマンスの低下の原因となる。  
  
  
