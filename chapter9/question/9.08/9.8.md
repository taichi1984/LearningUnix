# プログラミング課題9.8
## 課題内容
**バックグラウンドプロセス** コマンドをバックグラウンドで実行する&記号を受け付けるようにsmsh1.cを書き換えなさい。
next_cmdにもう１つ変更を加える必要がある。

## smsh1.cのソースコード
exitは実装済のものです。

```

#include "smsh.h"
#include <signal.h> #include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>

#define DFL_PROMPT "> "
int main() {
  char *cmdline, *prompt, **arglist;
  int result;
  char *end;
  void setup();

  prompt = DFL_PROMPT;
  setup();

  while ((cmdline = next_cmd(prompt, stdin)) != NULL) {
    if ((arglist = splitline(cmdline)) != NULL && arglist[0] != NULL) {
      if (strcmp(arglist[0], "exit") == 0) {
        int status = 0;
        if (arglist[1] != NULL) {
          char *end;
          long v;

          int errno = 0;
          v = strtol(arglist[1], &end, 10);
          if (errno != 0 || *end != '\0') {
            fprintf(stderr, "exit: numeric argument required\n");
            continue;
          }
          status = (int)v;
        }
        exit(status);
      }

      result = execute(arglist);
      freelist(arglist);
    }
    free(cmdline);
  }
  return 0;
}

void setup()
/*
 * 目的:シェルの初期化
 * 戻り値：なし、トラブルが起きたらfatal()を呼び出す。
 */
{
  signal(SIGINT, SIG_IGN);
  signal(SIGQUIT, SIG_IGN);
}

void fatal(char *s1, char *s2, int n) {
  fprintf(stderr, "Error: %s,%s\n", s1, s2);
  exit(n);
}
```

splitline.c

```

/* splitline.c - smshのためにコマンドを呼んで解析する関数。
 *
 *   char *next_cmd(char *prompt , FILE *fp)
 *   char **splitline(char *str);
 */

#include "smsh.h"
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

char *next_cmd(char *prompt, FILE *fp)
/*
 * 目的：fpから次のコマンド行を読み出す。
 * 戻り値：コマンド行を保持する動的に確保した文字列。
 * エラー：EOFならNULL(本当はエラーではない)
 *         emalloc()からfatalを呼び出す。
 * メモ  : BUFSIZ単位でメモリを確保する。
 */
{
  char *buf;        /*バッファ*/
  int bufspace = 0; /*サイズ合計*/
  int pos = 0;      /*現在位置*/
  int c;            /*入力文字*/

  printf("%s", prompt); /* ユーザーにプロンプトを出力する */
  while ((c = getc(fp)) != EOF) {
    /* need space ?*/
    if (pos + 1 >= bufspace) {
      if (bufspace == 0)
        buf = emalloc(BUFSIZ);
      else
        buf = erealloc(buf, bufspace + BUFSIZ);
      bufspace += BUFSIZ;
    }
    if (c == '\n')
      break;

    buf[pos++] = c;
  }
  if (c == EOF && pos == 0)
    return NULL;
  buf[pos] = '\0';
  return buf;
}

/**
** splitline( 行を解析して文字列配列に分割する )
**/
#define is_delim(x) ((x) == ' ' || (x) == '\t')

char **splitline(char *line)
/*
 * 目的：行を空白区切りにトークンに分割する。
 * 戻り値: トークンのコピーを指す末尾がNULLのポインタ配列。
 * 　　　　行にトークンが含まれていない場合はNULL
 * 動作  : 配列を準にチェックし、文字列を探してコピーを作る。
 * メモ  :
 * strtok()を使えば簡単だが、あとでクォートに対応するつもりなので、strtok()は使わない。
 */
{
  char *newstr(char *, int);
  char **args;
  int spots = 0;    /*テーブルの要素数*/
  int bufspace = 0; /*テーブルのバイト数*/
  int argnum = 0;   /*使った要素の数*/
  char *cp = line;  /*文字列のpos*/
  char *start;
  int len;

  if (line == NULL)
    return NULL;

  args = emalloc(BUFSIZ);
  bufspace = BUFSIZ;
  spots = BUFSIZ / sizeof(char *);

  while (*cp != '\0') {
    while (is_delim(*cp))
      cp++;
    if (*cp == '\0')
      break;

    /* 配列が充分なスペースを持つようにする(+1はNULLの分) */
    if (argnum + 1 >= spots) {
      args = erealloc(args, bufspace + BUFSIZ);
      bufspace += BUFSIZ;
      spots += (BUFSIZ / sizeof(char *));
    }

    /* 先頭にマークをつけ、単語の末尾を探す。*/
    start = cp;
    len = 1;
    while (*++cp != '\0' && !(is_delim(*cp)))
      len++;
    args[argnum++] = newstr(start, len);
  }
  args[argnum] = NULL;
  return args;
}

/*
 * 目的：文字列のコンストラクタ
 * 戻り値: 文字列、NLにはならない。
 */
char *newstr(char *s, int l) {
  char *rv = emalloc(l + 1);

  rv[l] = '\0';
  strncpy(rv, s, l);
  return rv;
}

void freelist(char **list)
/*
 *  目的:splitlineが返したリストを開放する。
 *  戻り値：なし
 *  動作：リスト内の全ての文字列を開放して、リストを開放する。
 */
{
  char **cp = list;
  while (*cp)
    free(*cp++);
  free(list);
}

void *emalloc(size_t n) {
  void *rv;
  if ((rv = malloc(n)) == NULL)
    fatal("out of memory", "", 1);
  return rv;
}

void *erealloc(void *p, size_t n) {
  void *rv;
  if ((rv = realloc(p, n)) == NULL)
    fatal("realloc() failed", "", 1);
  return rv;
}
```

execute.c
```

/* execute.c - smshがコマンドを実行するために使うコード*/

#include <signal.h>
#include <stdio.h>
#include <stdlib.h>
#include <sys/wait.h>
#include <unistd.h>

int execute(char *argv[])
/*
 * 目的:引数を渡してプログラムを起動する。
 * 戻り値:waitを介して、返された終了ステータス。エラーの場合は-1。
 * エラー:fork()かwait()がエラーを起こしたときには-1
 */
{
  int pid;
  int child_info = -1;

  if (argv[0] == NULL)
    return 0;

  if ((pid = fork()) == -1)
    perror("fork");
  else if (pid == 0) {
    signal(SIGINT, SIG_DFL);
    signal(SIGQUIT, SIG_DFL);
    execvp(argv[0], argv);
    perror("cannot execute command");
    exit(1);
  } else {
    if (wait(&child_info) == -1)
      perror("wait");
  }
  return child_info;
}

```

## どうすればいいのか？
コマンド行の最後のトークンに&があった場合は、バックグラウンドで実行するようにすればよい。
実際にどうすればできるのか？

## 実際のbashで気をつける点を確認。
```

$ ls&
[1] 16869
$ 9.8.md  execute.c  smsh.h  smsh1.c  splitline.c

[1]+  終了                  ls --color=auto
```

lsコマンドをバックグラウンドで実行させた例である。
最後の&はスペースが空いていない場合でも、バックグラウンドでの実行を認めている。
これはNULLの前のトークン==&とするのではなく、行ごとの処理をしたときに最後の文字が&だった場合にバックグラウンドになるということである。
そのため、next_cmdで処理する必要がある。

しかしnext_cmdはbufを返すため、状態を返すことができない。
そのため別のアプローチを取ることにする。
今回は行の末尾に&を見つけたら、それを' ','&',' ' に置換し、その後のsplitlineにトークンと認識させることで対応する。

## バックグラウンドで実行する方法
forkしてexecしてwaitしなければ、親プロセスが止まることはないのでバックグラウンドで動いているように見えるだろう。
まずはそれを試してみる。

### execで受け取るargvのNULLの一つ前（つまりユーザーが入力した最後のトークン)が&だった場合、backgroundで動くようにする。
これには、execute関数の最初でargvを評価する必要がある。
argvは可変長の文字列の配列のため、NULLの１つ前のものが&かどうかの判断をする必要がある。

重要なことは、&はあくまでbackgroundで実行するかどうかの判断を行うだけでexecvpに渡すべきものではない。
そのため、backgroundで処理することを状態として持つことができたら、この&のトークンはNULLに変えておこう。
NULLにしておけば、もともと&があったところを末尾と認識し、その一つあとにあるもともとおいてあったNULLは評価されないので安全である。
以下のようにする。
```
  int pid;
  int child_info = -1;
  int i = 0;
  int background = 0;

  while (argv[i] != NULL) {
    i++;
  }

  if (i > 0 && strcmp(argv[i - 1], "&") == 0) {
    background = 1;
    argv[i - 1] = NULL;
  }

```
その後親プロセスで!backgroundのときのみ、waitをするようにしてやればいい。

```
  if (!background) {
      if (wait(&child_info) == -1)
        perror("wait");
    }   
```



## 改修したsplitline.cとexecute.cのソースコード
### splitline.c
```
/* splitline.c - smshのためにコマンドを呼んで解析する関数。
 *
 *   char *next_cmd(char *prompt , FILE *fp)
 *   char **splitline(char *str);
 */

#include "smsh.h"
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

char *next_cmd(char *prompt, FILE *fp)
/*
 * 目的：fpから次のコマンド行を読み出す。
 * 戻り値：コマンド行を保持する動的に確保した文字列。
 * エラー：EOFならNULL(本当はエラーではない)
 *         emalloc()からfatalを呼び出す。
 * メモ  : BUFSIZ単位でメモリを確保する。
 */
{
  char *buf;        /*バッファ*/
  int bufspace = 0; /*サイズ合計*/
  int pos = 0;      /*現在位置*/
  int c;            /*入力文字*/

  printf("%s", prompt); /* ユーザーにプロンプトを出力する */
  while ((c = getc(fp)) != EOF) {
    /* need space ?*/
    if (pos + 1 >= bufspace) {
      if (bufspace == 0)
        buf = emalloc(BUFSIZ);
      else
        buf = erealloc(buf, bufspace + BUFSIZ);
      bufspace += BUFSIZ;
    }

    if (c == '\n')
      break;

    buf[pos++] = c;

    if (buf[pos - 1] == '&') {
      buf[pos - 1] = ' ';
      buf[pos++] = '&';
      buf[pos++] = ' ';
    }
  }
  if (c == EOF && pos == 0)
    return NULL;
  buf[pos] = '\0';

  return buf;
}

/**
** splitline( 行を解析して文字列配列に分割する )
**/
#define is_delim(x) ((x) == ' ' || (x) == '\t')

char **splitline(char *line)
/*
 * 目的：行を空白区切りにトークンに分割する。
 * 戻り値: トークンのコピーを指す末尾がNULLのポインタ配列。
 * 　　　　行にトークンが含まれていない場合はNULL
 * 動作  : 配列を準にチェックし、文字列を探してコピーを作る。
 * メモ  :
 * strtok()を使えば簡単だが、あとでクォートに対応するつもりなので、strtok()は使わない。
 */
{
  char *newstr(char *, int);
  char **args;
  int spots = 0;    /*テーブルの要素数*/
  int bufspace = 0; /*テーブルのバイト数*/
  int argnum = 0;   /*使った要素の数*/
  char *cp = line;  /*文字列のpos*/
  char *start;
  int len;

  if (line == NULL)
    return NULL;

  args = emalloc(BUFSIZ);
  bufspace = BUFSIZ;
  spots = BUFSIZ / sizeof(char *);

  while (*cp != '\0') {
    while (is_delim(*cp))
      cp++;
    if (*cp == '\0')
      break;

    /* 配列が充分なスペースを持つようにする(+1はNULLの分) */
    if (argnum + 1 >= spots) {
      args = erealloc(args, bufspace + BUFSIZ);
      bufspace += BUFSIZ;
      spots += (BUFSIZ / sizeof(char *));
    }

    /* 先頭にマークをつけ、単語の末尾を探す。*/
    start = cp;
    len = 1;
    while (*++cp != '\0' && !(is_delim(*cp)))
      len++;
    args[argnum++] = newstr(start, len);
  }
  args[argnum] = NULL;
  return args;
}

/*
 * 目的：文字列のコンストラクタ
 * 戻り値: 文字列、NLにはならない。
 */
char *newstr(char *s, int l) { char *rv = emalloc(l + 1); rv[l] = '\0';
  strncpy(rv, s, l);
  return rv;
}

void freelist(char **list)
/*
 *  目的:splitlineが返したリストを開放する。
 *  戻り値：なし
 *  動作：リスト内の全ての文字列を開放して、リストを開放する。
 */
{
  char **cp = list;
  while (*cp)
    free(*cp++);
  free(list);
}

void *emalloc(size_t n) {
  void *rv;
  if ((rv = malloc(n)) == NULL)
    fatal("out of memory", "", 1);
  return rv;
}

void *erealloc(void *p, size_t n) {
  void *rv;
  if ((rv = realloc(p, n)) == NULL)
    fatal("realloc() failed", "", 1);
  return rv;
}
```
### execute.c
```
/* execute.c - smshがコマンドを実行するために使うコード*/

#include <signal.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sys/wait.h>
#include <unistd.h>

int execute(char *argv[])
/*
 * 目的:引数を渡してプログラムを起動する。 戻り値:waitを介して、返された終了ステータス。エラーの場合は-1。
 * エラー:fork()かwait()がエラーを起こしたときには-1
 */
{
  int pid;
  int child_info = -1;
  int i = 0;
  int background = 0;

  while (argv[i] != NULL) {
    i++;
  }

  if (i > 0 && strcmp(argv[i - 1], "&") == 0) {
    background = 1;
    argv[i - 1] = NULL;
  }

  if (argv[0] == NULL)
    return 0;

  if ((pid = fork()) == -1)
    perror("fork");
  else if (pid == 0) {
    signal(SIGINT, SIG_DFL);
    signal(SIGQUIT, SIG_DFL);
    execvp(argv[0], argv);
    perror("cannot execute command");
    exit(1);
  } else {
    if (!background) {
      if (wait(&child_info) == -1)
        perror("wait");
    }
  }

  return child_info;
}
```

## 実行結果
```

$ ./smsh
> ping 127.0.0.1
PING 127.0.0.1 (127.0.0.1) 56(84) bytes of data.
64 bytes from 127.0.0.1: icmp_seq=1 ttl=64 time=0.047 ms
a64 bytes from 127.0.0.1: icmp_seq=2 ttl=64 time=0.060 ms
a /*無理やりコマンドを入れても何も起こらない*/
64 bytes from 127.0.0.1: icmp_seq=3 ttl=64 time=0.183 ms
a
64 bytes from 127.0.0.1: icmp_seq=4 ttl=64 time=0.038 ms
64 bytes from 127.0.0.1: icmp_seq=5 ttl=64 time=0.036 ms
^Z
[8]+  停止                  ./smsh

/*バックグラウンドでpingを実行する*/
$ ./smsh
> ping 127.0.0.1&
> PING 127.0.0.1 (127.0.0.1) 56(84) bytes of data.
64 bytes from 127.0.0.1: icmp_seq=1 ttl=64 time=0.048 ms
64 bytes from 127.0.0.1: icmp_seq=2 ttl=64 time=0.063 ms
ls　/*コマンドを入力すると入力されたコマンドが表示される。*/
9.8.md	execute.c  smsh  smsh.h  smsh1.c  splitline.c
> 64 bytes from 127.0.0.1: icmp_seq=3 ttl=64 time=0.063 ms
ls
9.8.md	execute.c  smsh  smsh.h  smsh1.c  splitline.c
> 64 bytes from 127.0.0.1: icmp_seq=4 ttl=64 time=0.037 ms
4/4 packets, 0% loss, min/avg/ewma/max = 0.037/0.052/0.049/0.063 ms
64 bytes from 127.0.0.1: icmp_seq=5 ttl=64 time=0.039 ms
64 bytes from 127.0.0.1: icmp_seq=6 ttl=64 time=0.035 ms
^Z
[9]+  停止                  ./smsh

```

pingは 末尾に&を入れればきちんとバックグラウンドで動いている様子だ。
シェルがちゃんと動いている。


