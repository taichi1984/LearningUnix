# プログラミング課題 6.6
## 課題内容
行エディタを書いてみよう。非カノニカルモードで動作するプログラムを書くときの問題点の１つは、
入力の編集がないことだ。改訂版のrotate.cを書き換えて、文字、行の編集をサポートするようにしなさい。
特に、プログラムがBSやDLEを受け取ったら、画面からカーソルの直前の文字が消去されるようにしなさい。
文字を消去するには、プログラムはBS,SPACE,BSを順に出力しなければならない。
また、プログラムを書き換えて、端末ドライバのように行削除文字を処理するプログラムを書きなさい。
つまり、現在の行に入力した全ての文字を画面から消去するのである。
さらにドライバの単語削除機能を実装するためには、何をしなければならないかを答えなさい。

## 設計案
### バックスペース（消去)の設計案
BS(0x7f)やDLE(0x10)を受け取ったら
putchar('\b');
putchar(' ');
putchar('\b');

を実行することでバックスペースによる削除を実現する。

### 行削除の設計案
文字入力ごとにlinelen（行ごとの文字数を格納する変数）を１ずつ増やす。
バックスペース時は１減らし、改行時、行削除処理時は０に戻す。
行削除のコマンドが入力されたらlinelenの数だけバックスペースを繰り返す。

### 単語削除の設計案
文字入力ごとにwordlen（行ごとの文字数を格納する変数）を1ずつ増やす。
バックスペース時は1減らし、改行時、行削除処理、単語削除処理時は0に戻す。
単語削除のコマンドが入力されたらwordlenの数だけバックスペースを繰り返す。
linelen -= wordlenで単語の文字数分だけ行の文字数も削除する。


## プログラムコード
```
#include <ctype.h>
#include <fcntl.h>
#include <signal.h>
#include <stdio.h>
#include <stdlib.h>
#include <termios.h>

void tty_mode(int how);
void set_cr_noecho_mode();
void signal_setting();
void keyboard_signal_handler(int);
void backspace();
int main(void) {

  tty_mode(0);
  set_cr_noecho_mode();
  signal_setting();

  int c;
  int linelen = 0;
  int wordlen = 0;
  while ((c = getchar()) != EOF) {
    if (c == '\b' || c == 0x7f || c == 0x10) {
      backspace();
      if (linelen > 0) {
        linelen--;
      }
      if (wordlen > 0) {
        wordlen--;
      }
    } else if (c == 0x15) {
      // 行削除処理
      for (int i = 0; i < linelen; i++) {
        backspace();
      }
      linelen = 0;
    } else if (c == 0x17) {
      // 単語削除処理
      for (int i = 0; i < wordlen; i++) {
        backspace();
      }
      linelen -= wordlen;
      wordlen = 0;

    } else {
      //通常の文字入力
      putchar(c);
      linelen++;
      wordlen++;
      //改行処理
      if (c == ' ') //スペース入力時
        wordlen = 0;
      if(c == '\n' || c == '\r') { //改行時
        wordlen = 0;
        linelen = 0;
      }
    }
  }
  return 0;
}

void tty_mode(int how) {
  static struct termios original_mode;
  static int original_flags;
  if (how == 0) {
    tcgetattr(0, &original_mode);
    original_flags = fcntl(0, F_GETFL);
  } else {
    tcsetattr(0, TCSANOW, &original_mode);
    fcntl(0, F_SETFL, original_flags);
  }
}

void set_cr_noecho_mode() {
  struct termios ttystate;

  tcgetattr(0, &ttystate);
  ttystate.c_lflag &= ~ICANON;
  ttystate.c_lflag &= ~ECHO;
  ttystate.c_cc[VMIN] = 1;
  tcsetattr(0, TCSANOW, &ttystate);
}

void signal_setting() {
  signal(SIGINT, keyboard_signal_handler);
  signal(SIGQUIT, keyboard_signal_handler);
  signal(SIGTSTP, keyboard_signal_handler);
}

void keyboard_signal_handler(int signum) {
  {
    tty_mode(1);
    exit(2);
  }
}

void backspace() {
  putchar('\b');
  putchar(' ');
  putchar('\b');
}

```

## 残った疑問
開発途中でlinelenが行の長さより、より多くなるケースがあったが、
その際にも行削除は前の行まで削除してしまうことなく、現在いる行のみ削除するようになっていた。
これはどういうことなのか？
改行は一文字として扱われないのか？

### 答え
端末は行のはじめでバックスペースキーを押したとしても、その行の先頭に移動するだけで、
上の行の最後に戻るような仕組みにはなっていない。
カーソルを上下に移動させたいに場合は別途

```

printf("\033[A"); // 1行上に移動
printf("\033[B"); // 1行下に移動

```

というような端末制御シーケンスを使う必要がある。

