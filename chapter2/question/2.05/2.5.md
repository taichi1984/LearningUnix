# 研究課題2.5    
    
## 課題内容    
カーネルバッファのディスクへの書き込み　　ディスクにwriteで書きこんだデータが本当にディスクに書き込まれたことをどのようにしたら確認できるか。    
本文で述べたように、カーネルは機械があれば、いつでもディスクにデータをコピーできる。マニュアルを使って、カーネルバッファの内容を確実にディスクにコピーするためにつかわれるシステムコールとプログラムを調べなさい。    
    
## writeシステムコールのmanページとchatgptの解説によると    
write()の行うことはバッファの内容を、カーネルに渡すだけであり、渡したものをカーネルがディスクに書き込むタイミングはカーネルの判断になる。つまり、write()したあとにすぐread()した場合、理論上、readが正しく読めない可能性がある。    
あくまでカーネルに「ディスクにこれを書いてね」というリクエストをするだけで、カーネルがディスクに書き込むことに関しては保障されていない。    
    
Noteの欄に以下の記載あり(chatgpt翻訳によるもの）    
```    
write() が成功して戻ったとしても、データがディスクに書き込まれた（コミットされた）ことは保証されません。    
特定のファイルシステム（たとえば NFS）では、ディスク上の空き領域が予約されたことすら保証されないことがあります。    
この場合、エラーが後の write()、fsync(2)、あるいは close(2) 呼び出しの時点まで遅延して発生することがあります。    
```    
    
この場合ファイルディスクリプタを閉じるか、fsync(2)関数を使うかすることで、write()した内容がディスクに書き込まれていることが保障されている状態にできる模様。    
    
## fsync(2),fdatasync(2)とは?    
ファイルのカーネル内の状態をストレージデバイスと同期する関数。    
    
### 書式    
```    
int fsync(int fd);    
int fdatasync(int fd);    
    
```    
    
ファイルディスクリプタに対応するカーネル内のバッファの内容をストレージと同期することができる。    
    
## 疑問点とChatgptによる回答    
    
### writeをする場合はsyncをするのはワンセットの作業にしたほうがいいのか？    
    
```    
✅ 基本結論：    
「データの永続性が重要なら、write() したら fsync() もセットでやるべき」    
🔍 理由（なぜか？）    
write() した時点では：    
    
データは カーネルのバッファキャッシュ にあるだけ    
    
ディスクにはまだ書かれていないことが多い    
    
停電やクラッシュが起きたら、データが失われる    
    
fsync() を呼ぶことで：    
    
データ＋メタデータがディスクに完全に書き込まれる    
    
ストレージデバイスが「書き込み完了した」と報告するまでブロックする    
    
→ この時点で初めて “永続化された” と言える    
    
🧠 じゃあ全部 fsync したほうがいいの？    
ここがポイント：    
    
◾ するべきケース（安全性重視）：    
ログファイル、トランザクション、DB、設定ファイルなど    
→ 「絶対に失いたくない・壊れたら困る」系    
j    
◾ しなくてもいいケース（性能重視）：    
一時ファイル、キャッシュ、すぐ再生成できるファイル    
→ 性能優先なら fsync() をスキップしてOK    
    
    
```    
    
上記を結論付けると、必要なwriteを全て行ってからfsync()するのが最も安全かつ効率的になる。    
write()だけだと、カーネルがディスクに書き込むタイミングを勝手に決めるので、データの永続化が保障されない。    
マニュアル上ではclose(2)の呼び出しまで遅延すると書いてあるけど、close()がfsync的なことをしてくれてる場合じゃないので明示的にやった方が無難。一応close(2)はカーネルがディスクに書き込みにいく判断基準にはなっているけど、保証はしていない。    
    
    
    
    
    
