# プログラミング演習3.15  
  
## 課題内容  
ファイルリストをソートするようにls1.cを書き換えなさい。標準のlsは、リストを逆順に出力する-rオプションをサポートしているので、その機能も追加しなさい。  
一部のlsは、"高速(quick)" 出力のための-qオプションを持っている。このオプションを指定すると、lsはリストをソートしない。  
ディレクトリに膨大な数のファイルが含まrていて、クイックソートでも時間がかかるような場合には、このオプションは役に立つ。  
  
  
## ls1.cの現在の動作  
  
```  
$ ./ls1 ../3.09/shadow-4.8.1/  
  
NEWS  
src  
ylwrap  
man  
doc  
config.rpath  
contrib  
po  
.pc  
ABOUT-NLS  
config.sub  
etc  
missing  
configure.ac  
ChangeLog  
lib  
depcomp  
config.guess  
Makefile.in  
compile  
configure  
ls1cols.c  
aclocal.m4  
Makefile.am  
libmisc  
ltmain.sh  
debian  
config.h.in  
shadow.spec.in  
acinclude.m4  
..  
COPYING  
README  
install-sh  
.  
TODO  
```  
  
ディレクトリ内のファイルの名前は列挙できているが、順番は特にソートされていない。  
これをファイル名順（またはファイル名の逆順）にソートされるように作り直す必要がある。  
  
## ls1.cのコード  
  
```  
#include <dirent.h>  
#include <stdio.h>  
  
void do_ls(char[]);  
  
int main(int ac, char *av[]) {  
  if (ac == 1) {  
    do_ls(".");  
  } else {  
    while (--ac) {  
      printf("%s: \n", *++av);  
      do_ls(*av);  
    }  
  }  
  return 0;  
}  
  
void do_ls(char dirname[])  
/*  
 *  dirnameというディレクトリのファイルをリストアップする。  
 */  
{  
  DIR *dir_ptr;  
  struct dirent *direntp;  
  
  if ((dir_ptr = opendir(dirname)) == NULL)  
    fprintf(stderr, "ls1: cannot open %s \n", dirname);  
  else {  
    while ((direntp = readdir(dir_ptr)) != NULL)  
      printf("%s\n", direntp->d_name);  
    closedir(dir_ptr);  
  }  
}  
  
```  
  
## コードの修正案  
  
現在はオプションがない場合は、do_lsを実行し、do_ls関数の中で、そのままファイルをプリントしている。  
これだと、ファイル名の順番は決めることができないので、do_ls関数の中で配列に格納した上で、並び替えて出力する。  
  
## 改良したls1.cのコード  
  
```  
/** ls1.c  
 *  目的 : ディレクトリ( 複数の場合も含む) の内容をリストアップする。  
 *  動作 :  
 * 引数がない場合には、"."、そうでなければ引数のディレクトリに含まれるファイルを出力する。  
 *  
 */  
#include <dirent.h>  
#include <stdio.h>  
#include <stdlib.h>  
#include <string.h>  
  
int cmp_str(const void *a, const void *b);  
int cmp_str_desc(const void *a, const void *b);  
  
void do_ls(char[], char[]);  
  
int main(int ac, char *av[]) {  
  if (ac == 1) {  
    do_ls(".", "normal");  
  } else if (ac == 2) {  
    if (strcmp(av[1], "-r") == 0) {  
      do_ls(".", "-r");  
    }  
  }  
  
  else {  
    while (--ac) {  
      printf("%s: \n", *++av);  
      do_ls(*av, "normal");  
    }  
  }  
  
  return 0;  
}  
  
int cmp_str(const void *a, const void *b) {  
  // a, b は "要素へのポインタへのポインタ"  
  const struct dirent *pa = *(const struct dirent **)a;  
  const struct dirent *pb = *(const struct dirent **)b;  
  return strcmp(pa->d_name, pb->d_name); // strcmp をそのまま使える  
}  
int cmp_str_desc(const void *a, const void *b) {  
  // a, b は "要素へのポインタへのポインタ"  
  const struct dirent *pa = *(const struct dirent **)a;  
  const struct dirent *pb = *(const struct dirent **)b;  
  return -strcmp(pa->d_name, pb->d_name); // strcmp をそのまま使える  
}  
  
void do_ls(char dirname[], char option[])  
/*  
 *  dirnameというディレクトリのファイルをリストアップする。  
 */  
{  
  DIR *dir_ptr;  
  struct dirent *entry;  
  struct dirent *direntp[1024];  
  int i = 0;  
  
  if ((dir_ptr = opendir(dirname)) == NULL)  
    fprintf(stderr, "ls1: cannot open %s \n", dirname);  
  else {  
    while ((entry = readdir(dir_ptr)) != NULL) {  
      direntp[i] = malloc(sizeof(struct dirent));  
      memcpy(direntp[i], entry, sizeof(struct dirent));  
      i++;  
    }  
  }  
  
  if (strcmp(option, "-r") == 0)  
    qsort(direntp, i, sizeof(direntp[0]), cmp_str_desc);  
  else if (strcmp(option, "normal") == 0)  
    qsort(direntp, i, sizeof(direntp[0]), cmp_str);  
  
  for (int j = 0; j < i; j++)  
    printf("%s \n", direntp[j]->d_name);  
  
  for(int j = 0; j < i ; j++)  
    free(direntp[j]);  
  
  closedir(dir_ptr);  
}  
```  
  
これで上手く比較した上で保存できるようになったはずだ。  
