# プログラミング課題 5.25
## 課題内容
**リンクとロック２** 前問ではリンクを使ってファイルをロックする方法を示した。
ファイルロックは、ロックをセットしたプログラムがファイルの書き換えを終了したときに取り除く必要がある。
プログラムがロックを開放しなければ、他のプログラムは永遠に待つことになってしまう。
では、プログラムがロックを解放する前に、バグのためにクラッシュしたりユーザーがCtrl+Cを押して強制終了したりした場合には
どうしたらよいだろうか？
例えば、ロックを保持するプログラムはn秒ごとにファイルを書き換えるようにする方法が考えられる。
utimeを使えば良い。ロックを待っているプログラムは、変更日時をチェックしてロックがまだあたたかい華道家を調べる。
ロックが指定された間隔を過ぎても書き換えられていない場合は、他のプログラムはリンクを削除して自分のためにリンクを作成してよいものとする。
引数として秒数を取るlock_passwd関数の新バージョンを書きなさい。
新バージョンは前段で説明したロジックを実装するものとする。

## 課題の内容はどういうことか？
utimeを使ってロックファイルの更新時刻を何秒かごとに書き換えることで、必ず現在時刻から何秒以内に更新されているロックファイルになっていることを保証すれば良い。
ロックするファイルの更新を５秒ごとにするなら、ロックを待っているプログラムはロックファイルの更新時刻が現在時刻-5秒以内ならば、ロックを解除せず、
５秒以上古いならば、それはクラッシュしたファイルなのでロックを消して良いと判断するようにすればよい。


## プログラムを書く

```
#include <errno.h>
#include <stdio.h>
#include <stdlib.h>
#include <sys/stat.h>
#include <time.h>
#include <unistd.h>
#include <utime.h>

int unlock_passwd() {
  if (unlink("/etc/passwd.LCK") == -1) {
    perror("unlink");
    exit(1);
  }
  return 0;
}

int lock_passwd(int seconds) {
  int rv = 0;

  while (1) {
    if (link("/etc/passwd", "/etc/passwd.LCK") == 0)
      return 0;

    if (errno != EEXIST) {
      return 2;
    }

    struct stat st;
    if (stat("/etc/passwd.LCK", &st) == -1) {
      perror("stat");
      return 1;
    }

    time_t now = time(NULL);
    if (now - st.st_mtime > seconds) {
      unlink("/etc/passwd.LCK");
      continue;
    }
    return 1;
  }
}

int main(void) {
  char word[100];
  lock_passwd(5);
  scanf("%s", word);
  printf("%s\n", word);
  unlock_passwd();
  printf("unlockしました\n");

  return 0;
}
```

該当の関数部分は

```
int lock_passwd(int seconds) {
  int rv = 0;

  while (1) {
    if (link("/etc/passwd", "/etc/passwd.LCK") == 0)
      return 0;

    if (errno != EEXIST) {
      return 2;
    }

    struct stat st;
    if (stat("/etc/passwd.LCK", &st) == -1) {
      perror("stat");
      return 1;
    }

    time_t now = time(NULL);
    if (now - st.st_mtime > seconds) {
      unlink("/etc/passwd.LCK");
      continue;
    }
    return 1;
  }
}

```

ここになる。


このプログラムはまだ５秒毎に更新時刻を書き換える処理は書かれていない。
そのため、このプログラムはほぼ毎回ロックファイルを書き換えることになると思われるので、実際には機能していない。
５秒毎に書き換えるためには、やりたい処理と並行して５秒毎に書き換えるプログラムを走らせる必要がある。


### シグナルを追加して、５秒毎の更新もできるようにする。
メインの処理は標準入力に入力した文字を標準出力に出力するだけです。

```

#include <errno.h>
#include <signal.h>
#include <stdio.h>
#include <stdlib.h>
#include <sys/stat.h>
#include <sys/time.h>
#include <time.h>
#include <unistd.h>
#include <utime.h>

void update_locktime() { utime("/etc/passwd.LCK", NULL); }

void start_timer(int seconds) {
  struct itimerval timer;

  signal(SIGALRM, update_locktime);

  timer.it_interval.tv_sec = seconds;
  timer.it_interval.tv_usec = 0;

  timer.it_value.tv_sec = seconds;
  timer.it_value.tv_usec = 0;

  setitimer(ITIMER_REAL, &timer, NULL);
}

int unlock_passwd() {
  if (unlink("/etc/passwd.LCK") == -1) {
    perror("unlink");
    exit(1);
  }
  return 0;
}

int lock_passwd(int seconds) {
  int rv = 0;

  while (1) {
    if (link("/etc/passwd", "/etc/passwd.LCK") == 0)
      return 0;

    if (errno != EEXIST) {
      return 2;
    }

    struct stat st;
    if (stat("/etc/passwd.LCK", &st) == -1) {
      perror("stat");
      return 1;
    }

    time_t now = time(NULL);
    printf("now :%ld \n", now);
    printf("modify : %ld\n", st.st_mtime);
    
    if (now - st.st_mtime > seconds) {
      unlink("/etc/passwd.LCK");
    }
    continue;

    return 1;
  }
}

int main(void) {
  char word[100];
  lock_passwd(5);
  start_timer(5);
  scanf("%s", word);
  printf("%s\n", word);
  unlock_passwd();
  printf("unlockしました\n");

  return 0;
}

```

## 実行結果

プロセスA,Bに両方このプログラムを起動させた結果以下の動きになった。

### プロセスA正常終了時
プロセスAが起動、文字入力待ちになる。
プロセスBを起動、ロックがあるため、現在時刻と更新時刻を表示し続ける。
プロセスAで文字入力をすると入力した文字が表示され、ロックが外れる。
プロセスBが文字入力待ちになる。（この時点で新しいロックが出来ている）
プロセスBで文字入力をすると入力した文字が表示され、ロックが外れる。

### プロセスA強制終了時
プロセスAが起動、文字入力待ちになる。
プロセスBを起動、ロックがあるため、現在時刻と更新時刻を表示し続ける。
プロセスAを強制終了する。
プロセスBが、現在時刻と更新時刻の差が6秒以上になるまで、現在時刻と更新時刻を表示し続ける。
６秒以上になったらプロセスBの時刻表示が止まり入力待ちになる。（時刻の差が６秒を超えた時点で、ロックが解除され、再度新しいロックがかけられる。)
プロセスBで文字入力をすると入力した文字が表示され、ロックが外れる。


## まとめと今後の課題
utimeで更新時間と現在時刻の比較処理を入れて、ロックを制御することにより、強制終了などで落ちてしまった場合もロック時間を確認することで
ロック待ちをする側のプロセスがロックを外せる仕組みを作ることができた。
上記のプログラムは正常に要件を満たしている。

今後の課題としてはシグナルに関しては仕組みを理解していない。（chatgptで出てきたコードをコピペしただけ）
おそらくはOSにこういうシグナルで割り込んでねっていうのを教えるコードがstart_timerであると思われる。
今後の章でシグナルまわりは詳しく理解していく必要がある。



