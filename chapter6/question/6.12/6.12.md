# プログラミング課題 6.12
## 課題内容
**シグナルとウィンドウ** ユーザーは、特定のキーを押すことによって、割り込みを生成できる他、端末のウィンドウのサイズを変えるだけでも割り込みを生成できる。
ウィンドウのサイズが変わるたびに、プロセスにはSIGWINCHが送られる。デフォルトでは、プロセスはSIGWINCHを無視する。画面を"A"という文字で埋め尽くすプログラムを書きなさい。
例えば、ウィンドウが10行２０列なら、このプログラムは200個の"A"で画面を埋め尽くし、ウィンドウがサイズを変更すると、このプログラムは"B"という文字で画面を埋め尽くし、
次にウィンドウサイズが変わったら"C"を使う。そして、ユーザーがQを押したら、画面をクリアしてプログラムを終了する。
ユーザーが他のキーを押したら、画面は再び"A"からスタートするものとする。

## プログラム

画面を埋める関数fill_itを実装して実現した。
表示する文字に関してはグローバル変数として持つことによって、シグナルからの呼び出しにも、通常のプログラムからの呼び出しにも対応するようにした。


```
#include <signal.h>
#include <stdio.h>
#include <stdlib.h>
#include <sys/ioctl.h>
#include <termios.h>

void set_noecho_nocan();
int tty_mode(int how);
void fill_it(int signum);
static int character = 'A';
int main(void) {
  tty_mode(0);
  set_noecho_nocan();
  signal(SIGWINCH, fill_it);
  int c;
  fill_it(0);
  while (1) {
    c = getchar();
    if (c == 'Q' || c == 'q') {
      printf("\033[2J\033[H");
      break;
    } else {
      character = 'A';
      fill_it(0);
    }
  }

  tty_mode(1);
}

void set_noecho_nocan() {
  struct termios ttystate;
  tcgetattr(0, &ttystate);
  ttystate.c_lflag &= ~ECHO;
  ttystate.c_lflag &= ~ICANON;
  tcsetattr(0, TCSANOW, &ttystate);
}

int tty_mode(int how) {
  static struct termios original_mode;
  if (how == 0) {
    tcgetattr(0, &original_mode);
    return 0;
  } else
    return tcsetattr(0, TCSANOW, &original_mode);
}
void fill_it(int signum) {
  struct winsize wbuf;

  if (ioctl(0, TIOCGWINSZ, &wbuf) == -1) {
    perror("ioctl:TIOCGWINSZ");
    tty_mode(1);
    exit(1);
  }

  printf("\033[2J\033[H");
  for (int i = 0; i < wbuf.ws_row; i++) {
    for (int j = 0; j < wbuf.ws_col; j++) {
      putchar(character);
    }
    putchar('\n');
  }
  character++;
}
```

## 実行結果
そのまま張るのは難しいが、ウィンドウサイズが変わるたびに文字コードが１ずつ増えて表示されるようにすることができた。
Qを押すと、画面をクリアして終了。
それ以外を押すとcharacterが 'A'に初期化されfill_it関数が呼ばれるようにしたことで、仕様通りの動きを実現することが出来た。

