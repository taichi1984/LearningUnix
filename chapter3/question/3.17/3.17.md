# 研究課題3.17
## 課題内容
**納屋のカギ閉め**  ファイルの読み出しパーミッションをオフにすると、ファイルを読み出し用にオープンすることができなくなる。
では、既にファイルを読み出し用にオープンしてある時に、他の端末から読み出しパーミッションをオフにするとどうなるか？
その後のreadコールが失敗するかどうかを答えなさい。また、読み出しファイルをオープンし、数バイト読み出してから、sleep(20)を呼び出して20秒待ち
さらに数バイトを読み出すというプログラムを書き、０秒の間にファイルの読み出しを禁止しなさい。
何が起きるか。読み出しパーミッションの本当の意味を説明しなさい。


## 既に読み出し用にオープンしてある時に、他の端末から読み出しパーミッションをオフにするとどうなるか？ 
以下のコードを実行し、sleep中に他の端末でファイルのパーミッションを変更する。

```
#include <fcntl.h>
#include <stdio.h>
#include <sys/stat.h>
#include <unistd.h>

char buf[4000];
int count = 100;

int main(void) {
  int fd;
  if ((fd = open("sampleFile", O_RDONLY)) == -1) {
    perror("open");
    return 1;
  }

  printf("ここからスリープ\n");
  sleep(30);
  printf("ここまでスリープ\n");

  while (read(fd, buf, count) > 0) {
    printf("%s", buf);
  }
}
```

これでスリープ中に他の端末で以下の操作を実行

```
$ chmod 000 sampleFile
$ ls -l

---------- 1 taichi84 taichi84  78 Aug 31 18:54 sampleFile
```

プログラムの実行結果は以下のようになった。

```
ここからスリープ
ここまでスリープ
this is Samplefile
abcdefghijklmnopqrstuvwxyz

no one can ajlkjaassadfasdf:
```

このように何の問題もなくreadできてしまう。
あくまで実行権限が弾いているのはファイルのオープンであり、オープンの方法のようだ。



## 数バイト読み出してからスリープし、その後、全てのファイルを読み出すとどうなるか？
以下のコードを実行する。

```
#include <fcntl.h>
#include <stdio.h>
#include <sys/stat.h>
#include <unistd.h>

char buf[4000];
int count = 100;

int main(void) {
  int fd;
  if ((fd = open("sampleFile", O_RDONLY)) == -1) {
    perror("open");
    return 1;
  }

  read(fd, buf, 10);
  printf("10バイトだけ読む : %s\n", buf);

  printf("ここからスリープ\n");
  sleep(20);
  printf("ここまでスリープ\n");

  while (read(fd, buf, count) > 0) {
    printf("%s", buf);
  }
}
```

スリープ中に
```
$chmod 000 sampleFile　
```

を入力し、読み出し権限をはく奪する。
```
10バイトだけ読む : this is Sa
ここからスリープ
ここまでスリープ
mplefile
abcdefghijklmnopqrstuvwxyz

no one can ajlkjaassadfasdf:

```

それでも問題なく表示できる。

## 読み出しパーミッションの本当の意味は？
読み出しパーミッションの意味はreadを禁止することではなく、open("filename",O_RDONLY)と open("filename",O_RDWR)を弾く仕組みになっている。
パーミッションはファイルのopenを許可するかどうか(fdの割り当てをするかどうか？)の許可をしており、直接read()を実行できなくしているわけではない。

