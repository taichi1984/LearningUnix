# プログラミング課題6.8
## 課題内容
**本気か？** Ctrl+Cが押されたときに、本当にプログラムを強制終了させるつもりかどうかを尋ねるように
sigdemo1.cを書き換えなさい。このプログラムを実行すると、例えば次のようになる。
```
hello
hello
    Interrupted! OK to quit(y/n)? n
hello
hello
    Interrupted! OK to quit(y/n)? y
$

```
プログラムがOK to quit(y/n)?のプロンプトを出して回答を待っているときに
ユーザーがCtrl+cを押すとどうなるか。コードを書いてどうなるかを調べなさい。


## プログラムコード

作成したプログラムは以下になる。

```

#include <alloca.h>
#include <signal.h>
#include <stdio.h>
#include <stdlib.h>
#include <termios.h>
#include <unistd.h>

int main() {
  void f(int);
  int i;

  signal(SIGINT, f);
  for (i = 0; i < 20; i++) {
    printf("hello\n");
    sleep(1);
  }
  return 0;
}

void f(int signum) {
  int c;
  printf("    Interrupted! OK to Quit(y/n)?");
  c = getchar();

  if (c == 'y' || c == 'Y') {
    exit(2);
  }
  signal(SIGINT, f);
}

```

シンプルにSIGINTで割り込まれたら終了するか、どうかを問うだけのプログラム。
y or Y が入力されたら、exit(2)で終了し、それ以外ならsignal(SIGINT,f)で再度シグナルの設定をし直してもとの処理に戻る作りになっている。
実行して、要求仕様通りに動くのは確認できた。

## プロンプトを出して回答を待っているときにCtrl+Cを押すとどうなったか？
### 実行結果 (bash上での動作)
```
hello
^C(ここで割り込み)    Interrupted! OK to Quit(y/n)?^C(ここで割り込み)
    (エンターが押されて以下が表示される)Interrupted! OK to Quit(y/n)?
hello
```

プロンプトが出ている間にSIGINTで割り込んだら、プログラムは終了しない。
Ctrl+Cが押されている事自体は受付されるので、そのままエンターを押すと n扱いになり、プログラムが動き始めるが、
その直後に再度signalが押されたことになり、再度プロンプトが出るような形になる。

おそらく、再度のシグナルによる割り込みは、シグナルにより呼ばれた関数が終了するまで保留されるようになっているようだ。

上記はbashで動作を確認した場合である。

### nvim上の実行環境ではどうなったか。
nvim上の実行環境で動かした場合は　プロンプト表示中にCtrl+Cを押した場合は即割り込みが走り終了するようになった。
これがシグナルによる割り込みであるのかを確認するために以下の書き換えを行った。

```
void f(int signum) {

  signal(SIGINT, f); //signalを呼ぶのをプロンプトの表示より先にする。
  int c;
  printf("    Interrupted! OK to Quit(y/n)?");
  c = getchar();

  if (c == 'y' || c == 'Y') {
    exit(2);
  }
}

```

この場合、プロンプト表示中にCtrl+Cを押すと、そのまますぐに再度プロンプトを表示する形になった。
これはCtrl+Cを押した場合、たしかにシグナルが呼ばれていることと、プロンプト表示中に割り込みがすぐに行われていることを表している。

## 結論
プロンプト表示中に再度signalを呼んだ場合にどうなるかは実行環境に依存している。
このPCの端末環境であるbashでは、シグナルのハンドラに渡した関数が実行され終わってから、再度シグナルが呼ばれる形になるようだ。


## その後の実験と調査で判明した事実
SIGINTなどの割り込みが行われたあと、signal(SIGINT,f)などの設定が保持されるかどうかは環境によるものである。
POSIX準拠の環境では保持されるのが正しい動きになっており、bashはこれにあたる。
つまり、
```
おそらく、再度のシグナルによる割り込みは、シグナルにより呼ばれた関数が終了するまで保留されるようになっているようだ。
```
この１文は間違いであり、getchar()のブロッキングによってシグナルが待たされているだけで、getcharの入力が終わった瞬間にシグナルによる割り込みはかかっている。
bash実行時の挙動を上記のような誤った認識に至ったのは、基本nvimによる実行で動作を確認していたため、端末でしっかり実行した際の挙動に誤解があった。

nvimの環境は１回割り込みがあるとsignalの設定はリセットされてしまうので再度の設定が必要になる。
つまり割り込み後にsignalの設定を保持するかどうかは環境依存となっている。

