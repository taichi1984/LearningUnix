# 研究課題2.9      
      
## 課題内容      
      
** ファイルの末尾を飛び越えるシーク ** lseekは、現在のファイルの末尾よりもうしろに      
現在位置を設定することを認める。例えば、次のようにすると,      
      
```      
lseek(fd,100,SEEK_END)      
```      
      
現在位置はファイルの末尾よりも100バイト先に移る。      
ファイルの末尾よりも後ろのデータを対象としてreadを行うとどうなるのか。      
ファイルの末尾よりも後ろにwriteでデータを書いたらどうなるのか。例えば、ファイルの末尾よりも20000バイト後ろに"hello"と書き込むなど、      
大きな値を試してみよう。そして、ls -lでファイルサイズをチェックし、ls -s でもファイルサイズをチェックする。      
これらの読み書きの時に、何が行われているか説明しなさい。      
      
## 実際に行ってみる。      
      
ファイル末尾から50バイトあとを読み込んでみる。      
      
```      
      
#include<stdio.h>      
#include<unistd.h>      
#include<fcntl.h>      
#include<stdlib.h>      
      
int main()      
{      
  int fd;      
  char buffer[100];      
      
  if((fd = open("sampletext.txt",O_RDONLY)) == -1)      
  {      
    perror("open error");      
    exit(1);      
  }      
        
  lseek(fd,50,SEEK_END);      
      
  if(read(fd,&buffer,20) != 0)      
    printf("%s \n",buffer);      
}      
```      
      
これを実行すると何も表示されない。      
読み込むこと自体は許可されているようだ。      
      
      
このまま書き込んでみる。      
```      
      
#include<stdio.h>      
#include<unistd.h>      
#include<fcntl.h>      
#include<stdlib.h>      
      
int main()      
{      
  int fd;      
  char buffer[100];      
      
  if((fd = open("sampletext.txt",O_RDWR)) == -1)      
  {      
    perror("open error");      
    exit(1);      
  }      
        
  lseek(fd,50,SEEK_END);      
      
  if(read(fd,&buffer,20) != 0)      
    printf("%s \n",buffer);      
      
  lseek(fd,20000,SEEK_END);      
        
  if(write(fd,"testword",9) != 0)      
    printf("書き込み完了\n");      
        
}      
```      
      
書き込み完了が表示される。普通に書き込めてしまっているようだ。      
ls -lでファイルサイズはどうなっているか確認してみよう。      
      
```      
-rw-r--r-- 1 taichi84 taichi84  1415 Jul 27 19:37 2.9.md      
-rwxr-xr-x 1 taichi84 taichi84 16320 Jul 27 19:37 lseek_outside_file      
-rw-r--r-- 1 taichi84 taichi84   410 Jul 27 19:37 lseek_outside_file.c      
-rw-r--r-- 1 taichi84 taichi84 60276 Jul 27 19:37 sampletext.txt      
```      
      
sampletext.txtが60276byteと大きな数値になっている。どうやらファイルは大きく確保されて普通に書き込めたようだ。      
      
moreで確認したところ、もともとのファイルの末尾からかなり後のほうに新しく書き込まれているのが確認できた。      
      
## 疑問点      
オープンされたファイルよりかなりうしろにlseekを設定したのにもかかわらずsegmantation fault等が起こらないのはなぜなのか？      
lseek,read,writeあたりのどこかの関数にファイルの末尾よりあとで実行したときに、その領域をメモリ上に確保した後に書き込む機能などはあるのだろうか？      
      
## 答え     
    
### lseek()に関して    
lseek()、基準位置からのオフセットである整数値が変わるだけなので、特にメモリを読むわけでも書くわけでもない。    
当然segmantation faultなどは発生しない。    
    
### write()に関して    
ファイルの末尾以降に write をした場合、書き込み位置までの間の領域は「hole（穴）」として扱われる。  
この部分には物理的なブロックが割り当てられず、ファイルシステムのメタデータ上で「存在しない領域」として記録される。  
この仕組みにより、見かけ上はゼロが入っているように見えるが、実際にはディスクには何も書かれていない（スパースファイル）。  
これは古いファイルシステムの場合(FAT32などスパースファイル未対応の場合)末尾から書き込んだ場所の間までは0で埋められるようになっている。  
  
### read()に関して    
存在しない領域を読んだ場合、0(EOF)が返るようになっている。(ファイルシステムの仕様)    
このとき、バッファにはなにも書き込まれず、内容は未定義のままとなる。   
    
