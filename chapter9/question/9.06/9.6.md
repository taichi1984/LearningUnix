# プログラミング課題9.6
## 課題内容
**else** if制御構造のelse部をサポートするようにprocess.cを書き換えなさい。

## 元のソースコード
### process.c
```
/* process.c
 * コマンド処理レイヤ
 *
 * process(char **arglist)関数は、メインループから呼び出され、
 * execute()関数の前に位置する。このレイヤは、主として、次の２つの処理を行う。
 * a) 組み込み関数 ( 例えば, exit() , set , = , read など）
 * b) 制御構造 (例えば、 if while ,forなど)
 *
 */

#include "smsh.h"
#include <stdio.h>

int is_control_command(char *);
int do_control_command(char **);
int ok_to_execute();

int process(char **args)
/*
 * 目的:ユーザーコマンドの処理
 * 戻り値:コマンドの処理結果
 * 詳細: 組み込みコマンドなら適切な関数を呼び出す、そうでなければexecute()する。
 * エラー: サブルーチンで処理されたものが上がってくる。
 */
{
  int rv = 0;

  if (args[0] == NULL)
    rv = 0;
  else if (is_control_command(args[0]))
    rv = do_control_command(args);
  else if (ok_to_execute())
    rv = execute(args);
  return rv;
}

```

### controlflow.c

```

/* controlflow.c
 *
 * " if " 処理は、if_stateとif_resultの２個の状態変数を使って行う。
 */

#include "smsh.h"
#include <stdio.h>
#include <string.h>

enum states { NEUTRAL, WANT_THEN, THEN_BLOCK};
enum resalts { SUCCESS, FAIL };

static int if_state = NEUTRAL;
static int if_result = SUCCESS;
static int last_stat = 0;

int syn_err(char *);

int ok_to_execute()
/*
 * 目的 : シェルがコマンドを実行すべきかどうかを判断する。
 * 戻り値: イエスなら１，ノーなら0
 * 詳細 : THEN_BLOCK内にいて、if_resultがSUCCESSならイエス
 *        THEN_BLOCK内にいて、if_resultがFAILならノー
 *        WANT_THENなら構文エラー(shは異なる)
 */
{
  int rv = 1; /*デフォルトは真 */

  if (if_state == WANT_THEN) {
    syn_err("then expected");
    rv = 0;
  } else if (if_state == THEN_BLOCK && if_result == SUCCESS)
    rv = 1;
  else if (if_state == THEN_BLOCK && if_result == FAIL)
    rv = 0;
  return rv;
}

int is_control_command(char *s)
/*
 * コマンドがシェル制御コマンドかどうかを報告するbool関数
 * 戻り値: 0 か 1
 */
{
  return (strcmp(s, "if") == 0 || strcmp(s, "then") == 0 ||
          strcmp(s, "fi") == 0);
}

int do_control_command(char **args)
/*
 * 目的 : "if" , "then " , "fi" を処理する -- 状態を変更するかエラーを検出する。
 * 戻り値 : OK なら１、構文エラーなら-1
 * メモ : I would have put returns all over the place , Barry says "no"
 */
{
  char *cmd = args[0];
  int rv = -1;

  if (strcmp(cmd, "if") == 0) {
    if (if_state != NEUTRAL)
      rv = syn_err("if unexpected");
    else {
      last_stat = process(args + 1);
      if_result = (last_stat == 0 ? SUCCESS : FAIL);
      if_state = WANT_THEN;
      rv = 0;
    }
  } else if (strcmp(cmd, "then") == 0) {
    if (if_state != WANT_THEN)
      rv = syn_err("then unexpected");
    else {
      if_state = THEN_BLOCK;
      rv = 0;
    }
  } else if (strcmp(cmd, "fi") == 0) {
    if (if_state != THEN_BLOCK) {
      rv = syn_err("fi unexpected");
    } else {
      if_state = NEUTRAL;
      rv = 0;
    }
  } else
    fatal("internal error processing:", cmd, 2);
  return rv;
}

int syn_err(char *msg)
/* 目的:制御構造内の構文エラーを処理する。
 *  詳細:状態をNEUTRALにリセットする。
 *  戻り値: 対話的モードなら1、スクリプト内では、fatal呼び出しになる。
 */
{
  if_state = NEUTRAL;
  fprintf(stderr, "syntax error : %s\n", msg);
  return -1;
}

```

## やるべきことは何なのか？
以下の５つがやるべきことになる。
if_state　enmu変数の状態にELSE_BLOCKを追加
ok_to_executeにelse時の条件を追加
is_control_commandにelseをcontrol_commandとみなす処理を追加。
do_control_commandにコマンドがelseだったときの処理とエラー処理を追加。
do_control_commandのfiの処理が可能な条件を修正。

## 修正したcontrolflow.cのソースコード

```

/* controlflow.c
 *
 * " if " 処理は、if_stateとif_resultの２個の状態変数を使って行う。
 */

#include "smsh.h"
#include <stdio.h>
#include <string.h>

enum states { NEUTRAL, WANT_THEN, THEN_BLOCK, ELSE_BLOCK };
enum resalts { SUCCESS, FAIL };

static int if_state = NEUTRAL;
static int if_result = SUCCESS;
static int last_stat = 0;

int syn_err(char *);

int ok_to_execute()
/*
 * 目的 : シェルがコマンドを実行すべきかどうかを判断する。
 * 戻り値: イエスなら１，ノーなら0
 * 詳細 : THEN_BLOCK内にいて、if_resultがSUCCESSならイエス
 *        THEN_BLOCK内にいて、if_resultがFAILならノー
 *        WANT_THENなら構文エラー(shは異なる)
 */
{
  int rv = 1; /*デフォルトは真 */

  if (if_state == WANT_THEN) {
    syn_err("then expected");
    rv = 0;
  } else if (if_state == THEN_BLOCK && if_result == SUCCESS)
    rv = 1;
  else if (if_state == THEN_BLOCK && if_result == FAIL)
    rv = 0;
  else if (if_state == ELSE_BLOCK && if_result == SUCCESS)
    rv = 0;
  else if (if_state == ELSE_BLOCK && if_result == FAIL)
    rv = 1;

  return rv;
}

int is_control_command(char *s)
/*
 * コマンドがシェル制御コマンドかどうかを報告するbool関数
 * 戻り値: 0 か 1
 */
{
  return (strcmp(s, "if") == 0 || strcmp(s, "then") == 0 ||
          strcmp(s, "fi") == 0) ||
         strcmp(s, "else") == 0;
}

int do_control_command(char **args)
/*
 * 目的 : "if" , "then " , "fi" を処理する -- 状態を変更するかエラーを検出する。
 * 戻り値 : OK なら0、構文エラーなら-1
 * メモ : I would have put returns all over the place , Barry says "no"
 */
{
  char *cmd = args[0];
  int rv = -1;

  if (strcmp(cmd, "if") == 0) {
    if (if_state != NEUTRAL)
      rv = syn_err("if unexpBected");
    else {
      last_stat = process(args + 1);
      if_result = (last_stat == 0 ? SUCCESS : FAIL);
      if_state = WANT_THEN;
      rv = 0;
    }
  } else if (strcmp(cmd, "then") == 0) {
    if (if_state != WANT_THEN)
      rv = syn_err("then unexpected");
    else {
      if_state = THEN_BLOCK;
      rv = 0;
    }
  } else if (strcmp(cmd, "else") == 0) {
    if (if_state != THEN_BLOCK) {
      rv = syn_err("else unexpected");
    } else {
      if_state = ELSE_BLOCK;
      rv = 0;
    }
  } else if (strcmp(cmd, "fi") == 0) {
    if (if_state != THEN_BLOCK && if_state != ELSE_BLOCK) {
      rv = syn_err("fi unexpected");
    } else {
      if_state = NEUTRAL;
      rv = 0;
    }
  } else
    fatal("internal error processing:", cmd, 2);
  return rv;
}

int syn_err(char *msg)
/* 目的:制御構造内の構文エラーを処理する。
 *  詳細:状態をNEUTRALにリセットする。
 *  戻り値: 対話的モードなら1、スクリプト内では、fatal呼び出しになる。
 */
{
  if_state = NEUTRAL;
  fprintf(stderr, "syntax error : %s\n", msg);
  return -1;
}

```

## 実行結果
testというファイルまたはディレクトリは存在しないもの（ifの条件を満たさないために用意しない)

### if ls testで if後のコマンドの実行結果を失敗させたケース
```

$ ./smsh
> if ls test
ls: 'test' にアクセスできません: そのようなファイルやディレクトリはありません
> then
> ls
> else
> ls
9.6.md	controlflow.c  execute.c  process.c  smsh  smsh.h  smsh2.c  splitline.c
> fi
> if ls test
ls: 'test' にアクセスできません: そのようなファイルやディレクトリはありません
> then
> ls
> fi

```

最初のls testが失敗したときにはthenでlsしても実行結果を表示しないが
elseでlsすると実行結果を表示する。elseはうまく動いているようだ。

then節でfiを入力してもエラーが出ないのも確認できた。

### if ls でif後のコマンドの実行結果を成功させたケース
```

$ ./smsh
> if ls
9.6.md	controlflow.c  execute.c  process.c  smsh  smsh.h  smsh2.c  splitline.c
> then 
> ls
9.6.md	controlflow.c  execute.c  process.c  smsh  smsh.h  smsh2.c  splitline.c
> else
> ls
> fi

```
then節でのlsは動いているが、else節でのlsは動いていない。
正しく動いているようだ。


