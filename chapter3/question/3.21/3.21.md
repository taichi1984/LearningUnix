# プログラミング課題3.21  
## 課題内容  
ファイルの最終アクセス日時は、役に立つ情報である。ファイルをバックアップするのはよいことだが、  
バックアップ用のファイルを読んでしまうと、ファイルの最終アクセス日時が変わってしまう。  
ファイルをコピーするが、最終アクセス日時情報は変更しないバックアッププログラムがあると便利だ。  
さらにコピーの最終変更日時がオリジナルと同じだとなおよい。  
  
この２つの機能をもつcpを書きなさい。  
  
## 何を実現すればいいのかを考える。  
ファイルをコピーするときに最終アクセス日時と最終変更日時が更新されてしまうなら、  
コピー元のデータの最終アクセス日時と最終変更日時を保存しておいて、コピーした後最終更新日時などを書き開ければいい。  
  
## 設計案  
  
コピー元ファイルをstatして、最終アクセス日時と最終変更日時を保存する。  
実際にコピーを行い、ファイルを複製する。  
コピー元のファイルの最終アクセス日時を保存していた最終アクセス日時に変更する。  
コピー先の最終変更日時を保存していた最終変更日時に変更する。  
  
これだけ行えば実現可能と思われる。  
  
## 実際に作ってみる。  
  
### ソースコード  
```  
#define _POSIX_C_SOURCE 200809L  
#include <fcntl.h>  
#include <stdio.h>  
#include <stdlib.h>  
#include <sys/stat.h>  
#include <sys/types.h>  
#include <time.h>  
#include <unistd.h>  
  
#define BUFFERSIZE 4096  
#define COPYMODE 0644  
  
void oops(char *, char *);  
  
int main(int ac, char *av[]) {  
  
  int in_fd, out_fd, n_chars;  
  char buf[BUFFERSIZE];  
  struct stat source;  
  struct timespec source_times[2];  
  struct timespec target_times[2];  
  
  if (ac != 3) {  
    fprintf(stderr, "usage: %s source desination\n", *av);  
    exit(1);  
  }  
  
  if (stat(av[1], &source) == -1) {  
    perror("stat");  
    return 1;  
  }  
  
  source_times[0] = source.st_atim;  
  source_times[1].tv_nsec = UTIME_OMIT;  
  
  target_times[0].tv_nsec = UTIME_OMIT;  
  target_times[1] = source.st_mtim;  
  
  if ((in_fd = open(av[1], O_RDONLY)) == -1)  
    oops("Cannot open ", av[1]);  
  if ((out_fd = creat(av[2], COPYMODE)) == -1)  
    oops("Cannot creat ", av[2]);  
  
  while ((n_chars = read(in_fd, buf, BUFFERSIZE)) > 0)  
    if (write(out_fd, buf, n_chars) != n_chars)  
      oops("Write error to ", av[2]);  
  
  if (n_chars == -1)  
    oops("Read error from ", av[1]);  
  
  futimens(in_fd, source_times);  
  futimens(out_fd, target_times);  
  
  if (close(in_fd) == -1 || close(out_fd) == -1)
    oops("Error closing files", "");  
}  
  
void oops(char *s1, char *s2) {  
  fprintf(stderr, "Error : %s ", s1);  
  perror(s2);  
  exit(1);  
}  
```  
  
  
### 実行結果  
```  
$ stat 3.21.md  
  File: 3.21.md  
  Size: 1398            Blocks: 8          IO Block: 4096   regular file  
Device: 830h/2096d      Inode: 240245      Links: 1  
Access: (0644/-rw-r--r--)  Uid: ( 1000/taichi84)   Gid: ( 1000/taichi84)  
Access: 2025-09-03 22:10:10.879067953 +0900  
Modify: 2025-09-03 22:10:10.868067964 +0900  
Change: 2025-09-03 22:10:10.871734627 +0900  
 Birth: 2025-09-03 22:10:10.868067964 +0900  
  
  
$ ./mycp 3.21.md target  
  
$ stat target  
  File: target  
  Size: 1398            Blocks: 8          IO Block: 4096   regular file  
Device: 830h/2096d      Inode: 240288      Links: 1  
Access: (0644/-rw-r--r--)  Uid: ( 1000/taichi84)   Gid: ( 1000/taichi84)  
Access: 2025-09-03 22:40:00.152698272 +0900  
Modify: 2025-09-03 22:10:10.868067964 +0900  
Change: 2025-09-03 22:40:00.156364936 +0900  
 Birth: 2025-09-03 22:40:00.152698272 +0900  
  
$ stat 3.21.md  
  File: 3.21.md  
  Size: 1398            Blocks: 8          IO Block: 4096   regular file  
Device: 830h/2096d      Inode: 240245      Links: 1  
Access: (0644/-rw-r--r--)  Uid: ( 1000/taichi84)   Gid: ( 1000/taichi84)  
Access: 2025-09-03 22:10:10.879067953 +0900  
Modify: 2025-09-03 22:10:10.868067964 +0900  
Change: 2025-09-03 22:40:00.156364936 +0900  
 Birth: 2025-09-03 22:10:10.868067964 +0900  
```  
  
## まとめ  
上記の内容で、アクセス時間と、変更時間は意図したとおりに保存しつつ、コピーができている。  
問題なく実装はできた。  
  
### futimens関数  
fdに対応したファイルのatimeとmtimeを変更する関数。  
今回はコピーのためにfdを用意しているのでこの関数を使うのが簡単。  
  
futimens 関数によって、atimeとmtimeの時間を変更する方法。  
このfutimens関数の第２引数であるtimespec構造体配列[2]の内容を把握するのも重要なポイント。  
timespec構造体のメンバはtv_secとtv_nsecの二つのメンバ。  
この構造体の配列で[0]がatime、[1]がmtimeだと把握していれば簡単にコピー可能。  
  
  
  
  
