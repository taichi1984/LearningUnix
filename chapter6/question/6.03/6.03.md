#プログラミング課題6.3
## 課題内容
**若干の遅延モード** ファイルディスクリプタにはブロッキングモードと遅延なし(ノンブロッキング）モードがあるが、
端末ドライバは更に細かい制御を実現している。入力にタイムアウト時間を設定できるのである。
端末ドライバのtermios構造体に含まれている制御文字配列のC_CC[]でVTIMEの位置にある要素は、1/10秒単位でタイムアウトを設定する。
つまり、s.c_cc[VTIME] = 20は、ドライバのタイムアウトを２秒にする。
ファイルディスクリプタをノンブロッキングモードにするのではなく、ドライバのタイムアウト機能を使うように、play_again3.cを書き換えなさい。

## play_again3.cのソースコード
こちらはノンブロッキングモードとsleepを使ってタイムアウトを設定したものになる。

```

#include <ctype.h>
#include <fcntl.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <termios.h>
#include <unistd.h>

#define ASK "Do you want another transaction?"
#define TRIES 3     // 試行回数の上限
#define SLEEPTIME 2 // １回の施行にかける時間
#define BEEP putchar('\a')

int get_response(char *, int maxtries);
void set_cr_noecho_mode();
void tty_mode(int how);
void set_nodelay_mode();
int get_ok_char();

int main() {
  int response;

  tty_mode(0);
  set_cr_noecho_mode();
  set_nodelay_mode();
  response = get_response(ASK, TRIES);
  tty_mode(1);
  return response;
}

int get_response(char *question, int maxtries) {
  int input;
  printf("%s (y/n)?", question);
  fflush(stdout);
  while (1) {
    sleep(SLEEPTIME);
    input = tolower(get_ok_char());
    if (input == 'y')
      return 0;
    if (input == 'n')
      return 1;
    if (maxtries-- == 0)
      return 2;
    BEEP;
  }
}

int get_ok_char() {
  int c;
  while ((c = getchar()) != EOF && strchr("yYnN", c) == NULL)
    ;
  return c;
}

void set_cr_noecho_mode() {
  struct termios ttystate;

  tcgetattr(0, &ttystate);
  ttystate.c_lflag &= ~ICANON;
  ttystate.c_lflag &= ~ECHO;
  ttystate.c_cc[VMIN] = 1;
  tcsetattr(0, TCSANOW, &ttystate);
}

void set_nodelay_mode() {
  int termflags;
  termflags = fcntl(0, F_GETFL);
  termflags |= O_NDELAY;
  fcntl(0, F_SETFL, termflags);
}

void tty_mode(int how) {
  static struct termios original_mode;
  static int original_flags;
  if (how == 0) {
    tcgetattr(0, &original_mode);
    original_flags = fcntl(0, F_GETFL);
  } else {
    tcsetattr(0, TCSANOW, &original_mode);
    fcntl(0, F_SETFL, original_flags);
  }
}

```

これを書き換えることにより端末の機能でタイムアウトする仕組みを作成する。

## 書き換えたコード
get_response関数のsleepとBEEPを削除（コメントアウト)し、
ノンブロッキングモードに入らせないようにするために set_nodelay_mode();をコメントアウト
さらにset_cr_noecho_mode()のttystate.c_ccを以下のように変更した。
``
  ttystate.c_cc[VMIN] = 0;
  ttystate.c_cc[VTIME] = 30;
``

```
#include <ctype.h>
#include <fcntl.h>
#include <stdio.h>
#include <string.h>
#include <termios.h>
#include <unistd.h>

#define ASK "Do you want another transaction?"
#define TRIES 3     // 試行回数の上限
#define SLEEPTIME 2 // １回の施行にかける時間
#define BEEP putchar('\a')

int get_response(char *, int maxtries);
void set_cr_noecho_mode();
void tty_mode(int how);
void set_nodelay_mode();
int get_ok_char();

int main() {
  int response;

  tty_mode(0);
  set_cr_noecho_mode();
  //  set_nodelay_mode();
  response = get_response(ASK, TRIES);
  tty_mode(1);
  return response;
}

int get_response(char *question, int maxtries) {
  int input;
  printf("%s (y/n)?", question);
  fflush(stdout);
  while (1) {
    // sleep(SLEEPTIME);
    input = tolower(get_ok_char());
    if (input == 'y')
      return 0;
    if (input == 'n')
      return 1;
    if (maxtries-- == 0)
      return 2;
    // BEEP;
  }
}

int get_ok_char() {
  int c;
  while ((c = getchar()) != EOF && strchr("yYnN", c) == NULL)
    ;
  return c;
}

void set_cr_noecho_mode() {
  struct termios ttystate;

  tcgetattr(0, &ttystate);
  ttystate.c_lflag &= ~ICANON;
  ttystate.c_lflag &= ~ECHO;
  ttystate.c_cc[VMIN] = 0;
  ttystate.c_cc[VTIME] = 30;
  tcsetattr(0, TCSANOW, &ttystate);
}

void set_nodelay_mode() {
  int termflags;
  termflags = fcntl(0, F_GETFL);
  termflags |= O_NDELAY;
  fcntl(0, F_SETFL, termflags);
}

void tty_mode(int how) {
  static struct termios original_mode;
  static int original_flags;
  if (how == 0) {
    tcgetattr(0, &original_mode);
    original_flags = fcntl(0, F_GETFL);
  } else {
    tcsetattr(0, TCSANOW, &original_mode);
    fcntl(0, F_SETFL, original_flags);
  }
}

```

## 実行結果
実行結果は３秒でタイムアウトが行われるようになった。
```
Do you want another transaction? (y/n)?
[Done] Press any key... //３秒経過で自動表示された。
```

## c_cc[VMIN]とc_cc[VTIME]の挙動について
こちらは興味深い挙動があった。

こちらの設定を操作した結果以下のように動いた

```
[VMIN] == 0 && [VTIME] == 3のときは３秒でタイムアウト 
[VMIN] == 1 && [VTIME] == 3のときはタイムアウトしない 
[VMIN] == 2 && [VTIME] == 3 のときは、タイムアウトしないが１文字打って待機すると３秒でタイムアウト

```

これはVTIMEの挙動の仕様となっている模様。
VMINが設定されていない場合は、ブロッキング開始直後にそのまま待つ
VMINが1以上に設定されている場合は１文字以上入力されてからタイムアウトのカウントが始まるようになっている。
VMINが2の場合は１文字以上打たれている場合はタイムアウトを待てばタイムアウトをするがVMINが１の場合は、１文字入力した瞬間に非カノニカルモードのread()の完了条件を満たすので、read()が返される。よってVTIMEが働く猶予が発生しない。
VMINを設定しない場合はカーネルがもともと持っていた設定値が残るのでVMINを明示設定しないと期待する動作は保証できないようになっている。




