# 研究課題 5.08
## 課題内容
標準ライブラリ関数のfopenは、追加モードでのファイルのオープンをサポートしている。
例えば、fopen("data","a")のようにする。あなたのシステムでは、この追加モードはO_APPENDを有効にしているか、
それともファイルをオープンしてからファイルの末尾に単純にlseekしているだけかを調べなさい。
fopenのソースコードを探すか、同じファイルを２回追加モードでオープンし、２つのストリームに交互に書き込むプログラムを書いて実験しなさい。

## 同じファイルを２回追加モードでオープンし交互に書き込むプログラムを書く

```
#include <stdio.h>

int main() {
  FILE *fp1;
  FILE *fp2;
  fp1 = fopen("testfile", "a");
  fp2 = fopen("testfile", "a");

  fprintf(fp1, "this is fp1\n");
  fprintf(fp2, "this is fp2\n");

  fclose(fp1);
  fclose(fp2);

  return 0;
}
```

以上のプログラムでtestfileという空のファイルに書き込みを行った。
その後、catして実行した結果は以下のようになった。

```
$ cat testfile
this is fp1
this is fp2
```

fopenがopenした時点で単純にファイルの末尾にシークしているとするならば、
何も内容がない状態でfp1もfp2もopenしているので、ファイルポインタはファイルの先頭を指しているはずである。
そこからfprintfでfp1、fp2の順に書き込んだら、fp2で書き込んだタイミングでfp1の書き込みは上書きされて消えてしまうはずである。
ところが、実際は問題なく書き込みが行われている。

これはopenした時点でseekされているわけではなく、O_APPENDフラグつきでopenシステムコールが呼ばれたときの動きである。
書き込みのタイミングでO_APPENDフラグを確認して、ファイルの末尾にシークしてからwriteしている。（このシークとwriteの処理はアトミックである。)

## 実際のソースコードはどうなっているのか？
glibcのソースコードを確認してみよう。
以下はfopenのソースコードを追うと呼ばれている_IO_new_file_open関数である。
```
FILE *
_IO_new_file_fopen (FILE *fp, const char *filename, const char *mode,
		    int is32not64)
{
  int oflags = 0, omode;
  int read_write;
  int oprot = 0666;
  int i;
  FILE *result;
  const char *cs;
  const char *last_recognized;

  if (_IO_file_is_open (fp))
    return 0;
  switch (*mode)
    {
    case 'r':
      omode = O_RDONLY;
      read_write = _IO_NO_WRITES;
      break;
    case 'w':
      omode = O_WRONLY;
      oflags = O_CREAT|O_TRUNC;
      read_write = _IO_NO_READS;
      break;
    case 'a':
      omode = O_WRONLY;
      oflags = O_CREAT|O_APPEND;
      read_write = _IO_NO_READS|_IO_IS_APPENDING;
      break;
    default:
      __set_errno (EINVAL);
      return NULL;
    }
  last_recognized = mode;
  for (i = 1; i < 7; ++i)
    {
      switch (*++mode)
	{
	case '\0':
	  break;
	case '+':
	  omode = O_RDWR;
	  read_write &= _IO_IS_APPENDING;
	  last_recognized = mode;
	  continue;
	case 'x':
	  oflags |= O_EXCL;
	  last_recognized = mode;
	  continue;
	case 'b':
	  last_recognized = mode;
	  continue;
	case 'm':
	  fp->_flags2 |= _IO_FLAGS2_MMAP;
	  continue;
	case 'c':
	  fp->_flags2 |= _IO_FLAGS2_NOTCANCEL;
	  continue;
	case 'e':
	  oflags |= O_CLOEXEC;
	  fp->_flags2 |= _IO_FLAGS2_CLOEXEC;
	  continue;
	default:
	  /* Ignore.  */
	  continue;
	}
      break;
    }

... 以下省略

```

この関数内でO_APPENDなどのフラグ処理が行われている。
fopenが単純にopen時にseekしているわけではなく、O_APPENDを使ってファイルを開いているのがソースコードを見てもわかる。
(openシステムコール自体はここでは呼ばれていないが、openシステムコールを呼ぶ前処理をここで行っている。)

## 結論
fopenのaオプションは、単純にopen時にファイルの末尾までシークしているのではなく、openシステムコールを呼ぶときにO_APPENDフラグを渡している。
これにより、writeシステムコールを読んだときに強制的にファイルの末尾までseekしてからwriteするように動作している。(atomicな処理)
