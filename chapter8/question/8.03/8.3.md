# 研究課題8.3
## 課題内容
psh2.cは、引数リストを保持するために固定サイズの配列を使っている。
ユーザーがコマンドのために入力できる引数の個数を無制限にするためには、プログラムをどのように書き換えればよいか。
このような変更は必要か。つまり、Unixはexecが受け付ける引数の個数か長さに制限を設けていないか。
調べて答えなさい。

## manページを確認
execveのページに以下のような記述あり。

```

引数と環境変数の合計サイズの上限
       ほとんどの UNIX の実装は、新しいプログラムに渡すことができる コマンドライン引数 (argv)  と環境変数 (envp)  の文字列群の合計サイズに何らかの上限を設けている。  POSIX.1  は、
       ARG_MAX 定数を使ってこの上限を決める実装を認めている (ARG_MAX は <limits.h> で定義されるか、実行時に sysconf(_SC_ARG_MAX) の呼び出しで入手できるかのいずれかである)。

       カーネル 2.6.23 より前の Linux では、環境変数と引数の文字列群を 格納するのに使用されるメモリーは 32 ページに制限されていた (32 ページというのはカーネル定数 MAX_ARG_PAGES で
       定義される)。したがって、 ページサイズが 4 kB のアーキテクチャーでは、 最大サイズは 128 kB ということになる。

```

Unixはexecが受け付ける引数の長さに制限を設けている。
個数というより合計の最大のサイズに制限を設けているようだ。


## 引数の個数を無限にしようとしてみる。

### 動的に引数の配列を確保したphs2.cは以下のものになる。

```

/* prompting shell version1
 *     コマンドと引数の入力を促す。
 *     execvp呼び出しのために、引数配列を作る。
 *     execvp()を使い、制御を返さない
 */

#include <signal.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sys/wait.h>
#include <unistd.h>

#define MAXARGS 20
#define ARGLEN 100

void execute(char *arglist[]);
int main() {
  int capacity = 10;
  int numargs = 0;
  char **arglist = malloc(sizeof(char *) * capacity);
  char argbuf[ARGLEN];
  char *makestring(char *buf);
  numargs = 0;

  while (1) {
    printf("Arg[%d] ? ", numargs);
    if (!fgets(argbuf, ARGLEN, stdin) || *argbuf == '\n') {
      break;
    }

    if (numargs + 1 >= capacity) {
      capacity *= 2;
      arglist = realloc(arglist, sizeof(char *) * capacity);
    }

    arglist[numargs++] = makestring(argbuf);
  }
  arglist[numargs] = NULL;
  execute(arglist);

  return 0;
}

void execute(char *arglist[])
/*
 * * execvpを使ってコマンドを起動する。
 * */
{
  int pid, exitstatus;

  pid = fork();
  switch (pid) {
  case -1:
    perror("fork failed");
    exit(1);
  case 0:
    execvp(arglist[0], arglist);
    perror("execvp failed");
    exit(1);
  default:
    while (wait(&exitstatus) != pid)
      ;
    printf("child exited with status %d, %d\n", exitstatus >> 8,
           exitstatus & 0377);
  }
}

char *makestring(char *buf) {
  char *cp;

  buf[strlen(buf) - 1] = '\0';
  cp = malloc(strlen(buf) + 1);
  if (cp == NULL) {
    fprintf(stderr, "no memory\n");
    exit(1);
  }
  strcpy(cp, buf);
  return cp;
}

```


### 実行結果
```
$ ./psh2_malloc
Arg[0] ? ls
Arg[1] ? -a
Arg[2] ? -l
Arg[3] ? -a
Arg[4] ? -a
Arg[5] ? -a
Arg[6] ? -a
Arg[7] ? -a
Arg[8] ? -a
Arg[9] ? -a
Arg[10] ? -a
Arg[11] ? -a
Arg[12] ? -a
Arg[13] ? -a
Arg[14] ? -a
Arg[15] ? -a
Arg[16] ? -a
Arg[17] ? -a
Arg[18] ? -a
Arg[19] ? -a
Arg[20] ? -a
Arg[21] ? -a
Arg[22] ? -a
Arg[23] ? -a
Arg[24] ? -a
Arg[25] ? 
合計 40
drwxrwxr-x 2 taichi84 taichi84  4096 12月  4 01:09 .
drwxrwxr-x 5 taichi84 taichi84  4096 12月  4 00:36 ..
-rw-rw-r-- 1 taichi84 taichi84  5827 12月  4 01:09 8.3.md
-rwxrwxr-x 1 taichi84 taichi84 16640 12月  4 01:08 psh2_malloc
-rw-rw-r-- 1 taichi84 taichi84  1591 12月  4 01:08 psh2_malloc.c
child exited with status 0, 0
```


