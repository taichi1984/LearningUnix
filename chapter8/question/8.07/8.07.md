# 研究課題8.7
## 課題内容
**execのエラー** execが子プロセスで失敗すると、プログラムはexitを呼び出す。
しかし、exit呼び出しは極端な感じがする。なぜ、関数からエラーコードを返すだけに留めないのか、
理由を説明しなさい。


## 予想
そもそもexecを呼び出すということは、プロセスを書き換えるということ。
失敗した場合は、execのどの段階で失敗したのか、execを呼び出したユーザは知ることができない。
そのため、適切なエラー処理が難しいため。（エラーのタイミングによっては元のプロセスが書き換えられている可能性があるため。)

execが呼ばれるということは元のプロセスは消滅する前提になっているため、
戻り値で何かを行うようにはできていない。
書換が行われたあとのプロセスのエラーと書換が行われる前のプロセスのエラーの両方に対して
エラー処理を書くのは関数では難しい。


## 答え
### 正しい理由（これが核心）
**exec** が成功した場合、呼び出し元のコードは完全に消滅するため

「関数に戻る」という設計自体が成立しない。

つまり：

exec 成功 ⇒ プログラム本体が入れ替わる → return 先の関数フレームが消える

exec 失敗 ⇒ 今のプロセスは“exec に失敗した子プロセス”であり、役割を終えている → exit で死ぬべき

この二つの性質があるから、

「exec に失敗したら return してエラー処理する」
→ そもそも exec を呼ぶコード構造と相性が悪い

### まとめ
exec は成功すればプロセスのコードやデータ空間を完全に置き換えるため、
呼び出し元の関数フレームは消えてしまい、戻り値で呼び出し元に戻るという設計が成り立たない。
一方、fork → exec の構造では、子プロセスは exec の成功を前提にして動作するため、
exec が失敗した子プロセスはもはや役割がなく、正常に実行を続けると親（シェルなど）のロジックを複製してしまう危険がある。
よって、exec 失敗時に関数へ return するのではなく、速やかに exit する必要がある。



