# 研究課題 3.1    
    
## 課題内容    
**d_name[]の長さ**  dirent構造体の定義において、配列chard_name[]の長さは、システムによって1だったり255だったりする。    
実際の長さはどうなっているのか？なぜこのような変な数字を使っているのか？なぜchar * と定義しないのか。これらの問いに答えなさい。    
    
## 自分の環境でdirent構造体を覗いてみる。    
    
```    
    
struct dirent    
  {    
#ifndef __USE_FILE_OFFSET64    
    __ino_t d_ino;    
    __off_t d_off;    
#else    
    __ino64_t d_ino;    
    __off64_t d_off;    
#endif    
    unsigned short int d_reclen;    
    unsigned char d_type;    
    char d_name[256];		/* We must not include limits.h! */    
  };    
```    
    
この内容になっている。char d_name[256]確保されている。    
    
unixで許されるファイル名の長さは255文字となっている。    
これ＋文字列の最後には終端文字の\0が入るため、合計で[256]バイト確保されるようになっている。    
    
## d_name[1]と定義されている構造体もあるらしいが、どういうことか？    
    
### 想定されること    
思いつく可能性はd_name[1]だけあれば、文字列を格納する先頭のポインタの場所は確保できるということ。    
これを利用して何かやってるのでは？    
    
### 実際はstruct hackを行っている。    
struct hackは構造体の最後に実長可変のデータをくっつけて（構造体定義としては可変長配列の長さは[1])１塊で確保するためのテクニック。  
  
構造体の配列領域を確保をするときに、構造体の長さ+ 実長可変のデータの領域を計算して、一括で領域を確保することにより  
、メモリの節約、ヒープ確保回数を減らすなどのメリットを享受するテクニック。    
    
### これだと構造体の可変長データの部分を長くしたときなどに、構造体の配列をまたメモリ確保をしなおす必要が出てくるのでは？    
    
その通り。なので、このテクニックは主に読込専用の構造体に使われる。    
カーネルにreaddir()を投げて、それが返してくる構造体の配列分の領域を確保できればいいのだ。  
ちなみにopendir() readdir()をするケースではopendir()がDIR構造体の内部バッファとして一括確保するときに行っている。  
  
### 結論  
僕の考えた想定は見当違い。(そもそも配列はあとからアドレスを変えられない。)　配列の最小定義をしたというのが正しい。    
  
システムごとによって実装方針の違いでシンプルにd_name[256]としている場合と    
メモリの節約のためにstruct hackなどの工夫をしていることがある。    
これらをどっちを取るかは、実装の単純さや互換性を取るか、メモリの効率などの性能面を取るかの取捨選択になる。    
    
## POSIXについて  
POSIXは readdir() の呼び方や d_name がヌル終端であることは保証するが、d_name の配列長や内部実装は規定していない。  
そのためコードを書く際は NAME_MAX+1 を使い、固定値に依存しないのが望ましい。  
  
