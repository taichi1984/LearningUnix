# 研究課題5.24
## 課題内容
**ロックのためにlink()を使う** ２つのプロセスが同時に同じファイルを更新しようとする状況は、
よくある競合の例である。例えば、あなたがあるシステムでパスワードを書き換えると、
passwdプログラムは/etc/passwdを書き換える。２人のユーザーが同時にパスワードを変更したときにはどうなるだろうか。
linkシステムコールの重要な機能を活用すれば、ファイルへの同時アクセスを防ぐことができる。
次のコードについて考えてみよう。

```
/*
* /etx/passwd.LCKというリンクを作ることを試みる。
* 成功した場合は0,ロック済みの場合は１，その他の問題があるときは２を返す。
*/ 

int lock_passwd()
{
    int rv = 0;
    if(link ("/etc/passwd","/etc/passwd.LCK") == -1)
        rv = ( errno == EEXIST ? 1 : 2 );
    return rv;
}

(a) 2つのプロセスがこのコードを同時に実行しても、片方しか成功しない。
linkシステムコールがファイルをロックするための便利な方法になるのはなぜか？

(b) このテクニックを使って、ファイルにテキスト行を追加する短いプログラムを書きなさい。
このプログラムは、リンクを張ろうとしなければならない。
リンク作成に失敗したら、プログラムはsleep(1)を使って１秒待ってから再試行する。
プログラムが永遠に待ち続けることがないようにしなさい。

(c) lock_passwdの高価を取り消すunlock_passwd関数を書きなさい。

(d) このサンプルは、プロセスが依存ファイルにロックをかけられるようにするが、
linkを使うと２つのプロセスが共に同じファイルをcreatするのを防げるのはなぜか。

(e) vipwコマンドについて調べなさい。vipwは、ロックのためにリンクを貼っているか。

```

## (a)linkシステムコールがファイルをロックするための便利な方法になるのはなぜか。
LinkシステムコールはLINKを作る。
このLINKの名前のつけかたを一定の規則にして、同じファイルには同じ名前のリンクしか作れないようにルールを作ることで
２つ目のリンクが動いた場合はすでにファイルがあるためEEXISTを返すようになる。

各プロセスにこの一定のルールでやりたい処理の前後に以下のような操作を行う。
以下は開いたファイル名+.LCKという名前のリンクを作ってロックファイルにするという規則で行う。

プロセスA
```
link("etc/passwd","/etc/passwd.LCK")リンクを作成　

やりたい処理を行う

unlink("/etc/passwd.LCK")リンクを解除
```

プロセスB
```
link("etc/passwd","/etc/passwd.LCK")リンクを作成　

やりたい処理を行う

unlink("/etc/passwd.LCK")リンクを解除
```

このようなプロセスAがやりたい処理を行うところで、何らかの待ちをして、容易に割り込める状態にあったとする。
その間は同ディレクトリにプロセスAの作った(passwd.LCK）が存在することになる。
その途中にプロセスBが実行された場合、最初のロックファイルを作る処理が必ずEEXISTのエラーを返す（すでにロックファイルが存在するため）
そのエラーが発生したら、それ以下の処理を行わないようにすれば、ロックファイルがある場合はそのファイルに触れないというような動きを作ることができる。

なおこれは完全にそのファイルをロックできるというよりかは、プログラムのルールとして最初にロックファイルを作り、
最後にロックファイルを消すというような決まりのもとで動いているプロセスに対してのみ有効なロックになる。
これをadvisory lock(助言的ロック、協調的ロック）といい、複数のプロセスが「お互いに約束して守る」方式でシステムが強制するわけではないロック方式となる。


## (b) このテクニックを使ってファイルにテキスト行を追加するプログラムを書く。
### ソースコード

```
/*
 *  ファイルロックのテスト
 *  第１引数のファイル名に　\n scanfで取得した任意の文字列を末尾に追加する。
 */
#include <errno.h>
#include <fcntl.h>
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>

int main(int ac, char *av[]) {
  char lockfile[FILENAME_MAX];
  char line[100];

  snprintf(lockfile, sizeof(lockfile), "%s.LCK", av[1]);

  while (1) {
    if (link(av[1], lockfile) == 0) {
      printf("追加したい文字列を入力してください\n");
      break;
    }

    if (errno == EEXIST) {
      printf("ファイルはロックされています。 , ロック解除待ち中...\n");
      sleep(1);
      continue;
    }
  }

  fgets(line, sizeof(line), stdin);

  FILE *fp;
  fp = fopen(av[1], "a");
  fprintf(fp, "%s", line);
  fclose(fp);

  unlink(lockfile);
}

```


### 実行結果

実行結果 プロセスA

```
$ ./addtext test1
追加したい文字列を入力してください //ここでプロセスBを起動
asfaskljklj

```

実行結果 プロセスB 

```
$ ./addtext test1
ファイルはロックされています。 , ロック解除待ち中...
ファイルはロックされています。 , ロック解除待ち中...
ファイルはロックされています。 , ロック解除待ち中...
ファイルはロックされています。 , ロック解除待ち中...
ファイルはロックされています。 , ロック解除待ち中...　//ここでプロセスA側の入力完了
追加したい文字列を入力してください
asdfsa
```

```
$ cat test1
asklsjdklfj
this is locked
this is locked 2
asdfsakjlk
asdfsalk
asfaskljklj  //以下２行がきちんと追加されている
asdfsa
```


