# 研究課題5.11
## 課題内容
**デバイスファイルと端末制御** 本文のサンプルは、tcgetattrとtcsetattrを呼び出すときに、
ファイルディスクリプタの値として0を使っている。第1引数はファイルディスクリプタで、
端末デバイスとの接続を参照する値なら何でも良い。
ファイルディスクリプタ１は、標準出力を参照する。そこで、ファイルディスクリプタで０ではなく１を使うようにsetechoとechostateを書き換えなさい。
この変更によってプログラムの処理内容にはどのような影響があるか。
標準入力と標準出力は、端末を参照することが多い。 echostate >> echostate.log を実行したときに、何が起きるかを説明しなさい。
ファイルディスクリプタとして0を使うことにメリットはあるか。

## ０ではなく１を使うようにしたらどのような変化があるか？
echostate0 (fdに0を使用)
echostate1 (fdに1を使用)
setecho0 (fdに0を使用)
setecho1 (fdに1を使用)

のプログラムを作って以下のコマンドで動作確認をした。

```
$ ./echostate0
 echo is on , since its bit is 1
$ ./echostate1
 echo is on , since its bit is 1
$ ./setecho0 n
$ # ./setecho0 y を打っている 
$ ./setecho1 n
$ # ./setecho0 y を打っている 

$ ./echostate1 >> echostate.log
tcgetattr: Inappropriate ioctl for device
$ ./echostate0 >> echostate.log
$ ls
echostate.log  echostate0.c  echostate1.c  setecho0.c  setecho1.c
echostate0     echostate1    setecho0      setecho1
$ cat echostate.log
 echo is on , since its bit is 1


```

基本的にechostateもsetechoもfdが１でも０でも動作は変わらない。
しかし、echostate0 >> echostate.logをやった場合と
echostate1 >> echostate.logをやった場合で動作の差が出た。

シェル上で標準出力で取得したものを標準出力に吐かせるようにしようと思ったらエラーが出た。
Inappropriate ioctl for deviceエラーはデバイスにあわせた適切なioctlが実行されていないときに出るエラーである。どういうことか？

## シェルのリダイレクトについて

```
$ program >> file
```

以上のコードはprogramの標準出力の内容をファイルに書き込む。
これはどういうことか？

プログラムが実行される前に標準出力が端末ではなくファイルになるということである。
つまり、プログラム内のtcgetattrがファイルに対して実行されることになるのだ。
当然ファイルにはtcgetattrで取得できる設定はないので、以上のエラーになる。

これを
```
$ ./echostate1 >> /dev/pts/0 # /dev/pts/0は実行しているのとは別の端末
```

で行うとどうなるのか？

```
$ ./echostate1 >> /dev/pts/0


## /dev/pts/0側で

 echo is off , since its bit is 0

```

エラーにならず、通常通り表示される。
これはリダイレクト先が端末なので、ioctlがエラーを吐かず問題なく実行されるからである。

## なぜ /dev/pts/0側のecho設定のbitは1のはずなのに、0と表示されてしまうのか？
シェルのリダイレクトは書き込み専用でリダイレクト先のファイルを開く。
書き込み専用で開いた端末からtcgetattrで読み込もうとしてしまうと、正しい属性が返らない可能性がある。（tcgetattrは読み書き可能で開いたときに状態を取れることを前提にしているので、O_WRONLYで開いたfdに対しては正しい属性が変えることを保証していない。)

## ファイルディスクリプタ0を使うメリット
ファイルディスクリプタ1は、シェルの都合上リダイレクトされて別のものを指してしまう可能性があるが、ファイルディスクリプタ０は基本的には端末を指していることが多い。
そのため、０を使うほうが安定して自分の端末を参照できる。




