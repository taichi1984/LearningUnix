# 研究課題8.05
## 課題内容
**forkと標準入出力** 次のコードについて考えてみよう。
main()
{
    FILE *fp;
    int pid;
    char msg1[] = "Testing 1 2 3 ..\n";
    char msg2[] = "Hello, hello \n";
    if( (fp = fopen("testfile2","w")) == NULL )
        return 0;
    fprintf(fp, "%s", msg1);
    
    if( (pid = fork() == -1)
        return 0;
    fprintf(fp, "%s" , msg2);
    fclose(fp);
    return 1;
    }

}

このプログラムをテストする。ファイルには、何個のメッセージが出力されるか。
結果を説明しなさい。このプログラムとforkdemo1.cの出力を比較しなさい。

## 出力の予想
```
Testing 1 2 3 ..
Hello, hello
Hello, hello
```

というふうになるはずである。
msg1 はforkの前に１回writeされただけなので、１回しか表示されないはずだ。

## 実際の出力

```
Testing 1 2 3 ..
Hello, hello 
Testing 1 2 3 ..
Hello, hello
```

ファイルディスクリプタで行った場合は2個目のTesting 1 2 3..は表示されなかったが
標準ライブラリのfopenで開き、fprintfをした場合はTesting 1 2 3..は表示される。
これはなぜだろうか？

fpはライブラリ側でなんらかのバッファリング処理が行われているのだろうか？
Testing 1 2 3 .. , Hello , hello の各行の最後に\nはあるので、flash自体はmsg1を出力した時点で行われているはずである。
なのに、Testing 1 2 3 ..が２度表示されるのだろうか？

## stdioのfopen,fprintfなどのバッファリングはフルバッファリング。
これはやはりバッファリングの関係で発生している問題である。
writeはバッファリングしないで、即カーネルに書き込むが、stdioはバッファリングを行う。
stdioのファイル入出力の仕様として、端末に対しては行バッファリングだが、ファイルに対してはフルバッファリングを行う。
その関係で、fflushやfcloseなどでflushするような関数を呼ばない限り、ファイルには書き込みが行われない。

上の例では、fcloseまで書き込みが行われないため、親プロセス、子プロセスの各プロセスがfclose()を呼んだときにカーネルがファイルに書き込む形になる。
故に、そこまで１回もflushしていないので、バッファにたまった２行分がどちらも出力されるということになっている。


