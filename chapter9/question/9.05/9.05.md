# プログラミング問題9.5
## 課題内容
**exit 3** exitコマンドがオプション引数を受け付けられるように、smsh1.cを書き換えなさい。
数値以外の引数(たとえば、exit left)は拒絶できるようにしなければならない。
このコマンドは、フローチャートのどこに当てはまるか。ロジックに新しい項目を追加する必要はあるか。
説明しなさい。

## フローチャート

元のフローチャートは以下の通り

シグナル無視
　　↓
コマンド取得
　　↓
　行分割
    ↓ 
   fork
    →　　親はwait  　　
　　 
　　→    子はシグナル有効可 →　execvp →　終了　→　最初に戻る

exitはbuiltinコマンドの一種として扱うため、builtinコマンドの判定が必要になる。
行分割のあとにコマンドの確認をして、exitする処理を追加するのがいいだろう。

元のフローチャートは以下の通り

シグナル無視
　　↓
コマンド取得
　　↓
　行分割
    ↓ 
   builtin コマンド判定、実行
　　↓
   fork
    →　　親はwait  　　
　　 
　　→    子はシグナル有効可 →　execvp →　終了　→　最初に戻る



## 第１案のソース
以下のようにしてみた。
```
int main() {
  char *cmdline, *prompt, **arglist;
  int result;
  char *end;
  void setup();

  prompt = DFL_PROMPT;
  setup();

  while ((cmdline = next_cmd(prompt, stdin)) != NULL) {
    if ((arglist = splitline(cmdline)) != NULL) {
      if (strcmp(arglist[0], "exit") == 0) {
        int status = 0;
        if (arglist[1] != NULL) {
          char *end;
          long v;

          int errno = 0;
          v = strtol(arglist[1], &end, 10);

          if (errno != 0 || *end != '\0') {
            fprintf(stderr, "exit: numeric argument required\n");
            continue;
          }
          status = (int)v;
        }
        exit(status);
      }
      result = execute(arglist);
      freelist(arglist);
    }
    free(cmdline);
  }
  return 0;
}
```

### 実行結果
```

$ ./smsh1
> exit
$ ./smsh1
> 
Segmentation fault (コアダンプ)


$ ./smsh1
> exit 3
```

exitは機能しているようだが、プロンプトに何も入力していなかった場合にSegmentation faultで落ちてしまう。
修正の必要があるようだ。

## 原因を探る
どうやら落ちている箇所は
```
      if (strcmp(arglist[0], "exit") == 0) {
```
の行である。

これは何も入力せずにsplitlineでarglistを作った場合、一つもリストの中身が作成されず末尾のNULLだけが作られるためである。
NULLが指す文字列は存在しないため、strcmpは存在しないものにアクセスして比較しようとするため、未定義動作となり、落ちたと考えられる。
そのため、コマンドを評価、実行するための条件をコマンドが入力されている場合、つまりarglist[0]がNULLでない場合という条件も追加するとよい。

## 修正案
```
#include "smsh.h"
#include <signal.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>

#define DFL_PROMPT "> "
int main() {
  char *cmdline, *prompt, **arglist;
  int result;
  char *end;
  void setup();

  prompt = DFL_PROMPT;
  setup();

  while ((cmdline = next_cmd(prompt, stdin)) != NULL) {
    if ((arglist = splitline(cmdline)) != NULL && arglist[0] != NULL) {
      if (strcmp(arglist[0], "exit") == 0) {
        int status = 0;
        if (arglist[1] != NULL) {
          char *end;
          long v;

          int errno = 0;
          v = strtol(arglist[1], &end, 10);
          if (errno != 0 || *end != '\0') {
            fprintf(stderr, "exit: numeric argument required\n");
            continue;
          }
          status = (int)v;
        }
        exit(status);
      }

      result = execute(arglist);
      freelist(arglist);
    }
    free(cmdline);
  }
  return 0;
}

void setup()
/*
 * 目的:シェルの初期化
 * 戻り値：なし、トラブルが起きたらfatal()を呼び出す。
 */
{
  signal(SIGINT, SIG_IGN);
  signal(SIGQUIT, SIG_IGN);
}

void fatal(char *s1, char *s2, int n) {
  fprintf(stderr, "Error: %s,%s\n", s1, s2);
  exit(n);
}
```

## 実行結果

```
$ ./smsh1
> 
> ls
9.05.md  execute.c  smsh.h  smsh1  smsh1.c  splitline.c
> exit 3
$ ./smsh1
> exit aa
exit: numeric argument required
> exit
$ 

```

## 改善点
exitはbuiltinコマンドなので、本来は直で処理を書くのではなく、builtinコマンドを処理する関数を作って
そのbuiltinコマンドが実行されたかどうかの結果次第でexecuteをするかどうかを決めるようにするときれいになる。
builtinコマンドが実行された　→　executeしない。
builtinコマンドが実行されない(builtinコマンドではない) →　executeする。

といった具合にするときれいになるだろう。

