# プログラミング課題7.10
## 課題内容
hello1.c のsleep呼び出しをusleep呼び出しに取り換えなさい。動きがスムーズだが早すぎない程度のインターバルを選びなさい。
また、メッセージが左右両端に近付くと遅くなり、画面中央に近付くと早くなるようにプログラムを書き換えなさい。
振り子やバネのような、単純で調和の取れた動きにどれだけ近付けられるか考えなさい。
次に、画面の右端が惑星で、メッセージが宇宙からその表面に落ちてくる場面を想像しなさい。
今度はそのように引力による加速をシミュレートするようにプログラムを書き換えなさい。
さらに、メッセージが惑星に衝突したときに、単語を別々の文字に分解して衝撃をシミュレートしなさい。

## 振り子のように動く文字のプログラムコード

```

/* hello6
 * 目的: メッセージを画面内で跳ね返らせる。
 * 　　　画面中央にきたら移動を早く、端に近くなったら遅くする。
 * 概要: 初期化、描画、入力待ち、終了
 */

#include <curses.h>
#include <stdio.h>
#include <unistd.h>

#define LEFTEDGE 10
#define RIGHTEDGE 100
#define ROW 10

int main() {
  char message[] = "Hello";
  char blank[] = "     ";
  int dir = +1;
  int pos = LEFTEDGE;
  int sleep_time = (RIGHTEDGE - pos) * 200;
  initscr();
  clear();

  while (1) {
    move(ROW, pos);
    addstr(message);
    move(LINES - 1, COLS - 1);
    refresh();
    usleep(sleep_time);
    move(ROW, pos);
    addstr(blank);
    pos += dir;

    if (pos >= RIGHTEDGE)
      dir = -1;
    if (pos <= LEFTEDGE)
      dir = +1;

    if (pos < (RIGHTEDGE + LEFTEDGE) / 2) {
      sleep_time = (100 - pos) * 500;
    } else {
      sleep_time = (pos) * 500;
    }
  }
}

```

## 右端に衝突して衝撃で文字が別々になるプログラムコード
```
/* hello7
 * 目的: メッセージを画面内で跳ね返らせる。
 * 　　　左から右に落下するようなイメージにし、右端に到達したら文字をバラバラにする。
 * 概要: 初期化、描画、入力待ち、終了
 */

#include <curses.h>
#include <stdio.h>
#include <unistd.h>

#define LEFTEDGE 10
#define RIGHTEDGE 100
#define ROW 20

int main() {
  char message[] = "Hello";
  char blank[] = "     ";
  int dir = +1;
  int pos = LEFTEDGE;
  int sleep_time = (RIGHTEDGE - pos) * 200;
  int break_flag = 0;
  int after_break_time = 0;
  char message_even[6] = "";
  char message_odd[6] = "";
  initscr();
  clear();

  while (1) {
    if (break_flag == 0) {
      move(ROW, pos);
      addstr(message);
      move(LINES - 1, COLS - 1);
      refresh();
      usleep(sleep_time);
      move(ROW, pos);
      addstr(blank);
      pos += dir;

      sleep_time = (100 - pos) * 500;
      if (pos >= RIGHTEDGE) {
        break_flag = 1;

        for (int i = 0; i < 6 - 1; i++) {
          if (i % 2 == 0) {
            message_even[i] = message[i];
            message_odd[i] = ' ';
          } else {
            message_odd[i] = message[i];
            message_even[i] = ' ';
          }

          message_even[5] = '\0';
          message_odd[5] = '\0';

          move(ROW, pos);
        }
      }
    } else {
      mvaddstr(ROW - after_break_time, pos, message_even);
      mvaddstr(ROW + after_break_time, pos, message_odd);
      after_break_time++;
      refresh();
      mvaddstr(ROW - after_break_time + 1, pos, blank);
      mvaddstr(ROW + after_break_time - 1, pos, blank);

      usleep(60000);
    }
  }
}
```
