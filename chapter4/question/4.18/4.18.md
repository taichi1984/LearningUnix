# 研究課題 4.18  
## 課題内容  
あなたのシステムのスーパーブロックの構造をマニュアルとヘッダファイルから学習しなさい。  
次に、ファイルシステムをオープンしてスーパーブロックを読み、  
明確で意味のわかる形式で設定を表示するプログラムを書きなさい。  
この練習問題は、utmpレコードとstat構造体を表示するために書いたプログラムと似たものになるはずだ。  
  
## スーパーブロックの構造を確認する。  
  
このシステムのファイルシステムであるext4のスーパーブロック構造体は以下の通り。  
重要な内容を見ていこう。  
  
```  
struct ext4_super_block {  
/*00*/	__le32	s_inodes_count;		/* Inodes count */  
	__le32	s_blocks_count_lo;	/* Blocks count */  
	__le32	s_r_blocks_count_lo;	/* Reserved blocks count */  
	__le32	s_free_blocks_count_lo;	/* Free blocks count */  
/*10*/	__le32	s_free_inodes_count;	/* Free inodes count */  
	__le32	s_first_data_block;	/* First Data Block */  
	__le32	s_log_block_size;	/* Block size */  
	__le32	s_log_cluster_size;	/* Allocation cluster size */  
/*20*/	__le32	s_blocks_per_group;	/* # Blocks per group */  
	__le32	s_clusters_per_group;	/* # Clusters per group */  
	__le32	s_inodes_per_group;	/* # Inodes per group */  
	__le32	s_mtime;		/* Mount time */  
/*30*/	__le32	s_wtime;		/* Write time */  
	__le16	s_mnt_count;		/* Mount count */  
	__le16	s_max_mnt_count;	/* Maximal mount count */  
	__le16	s_magic;		/* Magic signature */  
	__le16	s_state;		/* File system state */  
__le16	s_errors;		/* Behaviour when detecting errors */  
	__le16	s_minor_rev_level;	/* minor revision level */  
/*40*/	__le32	s_lastcheck;		/* time of last check */  
	__le32	s_checkinterval;	/* max. time between checks */  
	__le32	s_creator_os;		/* OS */  
	__le32	s_rev_level;		/* Revision level */  
/*50*/	__le16	s_def_resuid;		/* Default uid for reserved blocks */  
	__le16	s_def_resgid;		/* Default gid for reserved blocks */  
	/*  
	 * These fields are for EXT4_DYNAMIC_REV superblocks only.  
	 *  
	 * Note: the difference between the compatible feature set and  
	 * the incompatible feature set is that if there is a bit set  
	 * in the incompatible feature set that the kernel doesn't  
	 * know about, it should refuse to mount the filesystem.  
	 *  
	 * e2fsck's requirements are more strict; if it doesn't know  
	 * about a feature in either the compatible or incompatible  
	 * feature set, it must abort and not try to meddle with  
	 * things it doesn't understand...  
	 */  
	__le32	s_first_ino;		/* First non-reserved inode */  
	__le16  s_inode_size;		/* size of inode structure */  
	__le16	s_block_group_nr;	/* block group # of this superblock */  
	__le32	s_feature_compat;	/* compatible feature set */  
/*60*/	__le32	s_feature_incompat;	/* incompatible feature set */  
	__le32	s_feature_ro_compat;	/* readonly-compatible feature set */  
/*68*/	__u8	s_uuid[16];		/* 128-bit uuid for volume */  
/*78*/	char	s_volume_name[EXT4_LABEL_MAX] __nonstring; /* volume name */  
/*88*/	char	s_last_mounted[64] __nonstring;	/* directory where last mounted */  
/*C8*/	__le32	s_algorithm_usage_bitmap; /* For compression */  
	/*  
	 * Performance hints.  Directory preallocation should only  
	 * happen if the EXT4_FEATURE_COMPAT_DIR_PREALLOC flag is on.  
	 */  
	__u8	s_prealloc_blocks;	/* Nr of blocks to try to preallocate*/  
	__u8	s_prealloc_dir_blocks;	/* Nr to preallocate for dirs */  
	__le16	s_reserved_gdt_blocks;	/* Per group desc for online growth */  
	/*  
	 * Journaling support valid if EXT4_FEATURE_COMPAT_HAS_JOURNAL set.  
	 */  
/*D0*/	__u8	s_journal_uuid[16];	/* uuid of journal superblock */  
/*E0*/	__le32	s_journal_inum;		/* inode number of journal file */  
	__le32	s_journal_dev;		/* device number of journal file */  
	__le32	s_last_orphan;		/* start of list of inodes to delete */  
	__le32	s_hash_seed[4];		/* HTREE hash seed */  
	__u8	s_def_hash_version;	/* Default hash version to use */  
	__u8	s_jnl_backup_type;  
	__le16  s_desc_size;		/* size of group descriptor */  
/*100*/	__le32	s_default_mount_opts;  
	__le32	s_first_meta_bg;	/* First metablock block group */  
	__le32	s_mkfs_time;		/* When the filesystem was created */  
	__le32	s_jnl_blocks[17];	/* Backup of the journal inode */  
	/* 64bit support valid if EXT4_FEATURE_INCOMPAT_64BIT */  
/*150*/	__le32	s_blocks_count_hi;	/* Blocks count */  
	__le32	s_r_blocks_count_hi;	/* Reserved blocks count */  
	__le32	s_free_blocks_count_hi;	/* Free blocks count */  
	__le16	s_min_extra_isize;	/* All inodes have at least # bytes */  
	__le16	s_want_extra_isize; 	/* New inodes should reserve # bytes */  
	__le32	s_flags;		/* Miscellaneous flags */  
	__le16  s_raid_stride;		/* RAID stride */  
	__le16  s_mmp_update_interval;  /* # seconds to wait in MMP checking */  
	__le64  s_mmp_block;            /* Block for multi-mount protection */  
	__le32  s_raid_stripe_width;    /* blocks on all data disks (N*stride)*/  
	__u8	s_log_groups_per_flex;  /* FLEX_BG group size */  
	__u8	s_checksum_type;	/* metadata checksum algorithm used */  
	__u8	s_encryption_level;	/* versioning level for encryption */  
	__u8	s_reserved_pad;		/* Padding to next 32bits */  
	__le64	s_kbytes_written;	/* nr of lifetime kilobytes written */  
	__le32	s_snapshot_inum;	/* Inode number of active snapshot */  
	__le32	s_snapshot_id;		/* sequential ID of active snapshot */  
	__le64	s_snapshot_r_blocks_count; /* reserved blocks for active  
					      snapshot's future use */  
	__le32	s_snapshot_list;	/* inode number of the head of the  
					   on-disk snapshot list */  
#define EXT4_S_ERR_START offsetof(struct ext4_super_block, s_error_count)  
	__le32	s_error_count;		/* number of fs errors */  
	__le32	s_first_error_time;	/* first time an error happened */  
	__le32	s_first_error_ino;	/* inode involved in first error */  
	__le64	s_first_error_block;	/* block involved of first error */  
	__u8	s_first_error_func[32] __nonstring;	/* function where the error happened */  
	__le32	s_first_error_line;	/* line number where error happened */  
	__le32	s_last_error_time;	/* most recent time of an error */  
	__le32	s_last_error_ino;	/* inode involved in last error */  
	__le32	s_last_error_line;	/* line number where error happened */  
	__le64	s_last_error_block;	/* block involved of last error */  
	__u8	s_last_error_func[32] __nonstring;	/* function where the error happened */  
#define EXT4_S_ERR_END offsetof(struct ext4_super_block, s_mount_opts)  
	__u8	s_mount_opts[64];  
	__le32	s_usr_quota_inum;	/* inode for tracking user quota */  
	__le32	s_grp_quota_inum;	/* inode for tracking group quota */  
	__le32	s_overhead_clusters;	/* overhead blocks/clusters in fs */  
	__le32	s_backup_bgs[2];	/* groups with sparse_super2 SBs */  
	__u8	s_encrypt_algos[4];	/* Encryption algorithms in use  */  
	__u8	s_encrypt_pw_salt[16];	/* Salt used for string2key algorithm */  
	__le32	s_lpf_ino;		/* Location of the lost+found inode */  
	__le32	s_prj_quota_inum;	/* inode for tracking project quota */  
	__le32	s_checksum_seed;	/* crc32c(uuid) if csum_seed set */  
	__u8	s_wtime_hi;  
	__u8	s_mtime_hi;  
	__u8	s_mkfs_time_hi;  
	__u8	s_lastcheck_hi;  
	__u8	s_first_error_time_hi;  
	__u8	s_last_error_time_hi;  
	__u8	s_first_error_errcode;  
	__u8    s_last_error_errcode;  
	__le16  s_encoding;		/* Filename charset encoding */  
	__le16  s_encoding_flags;	/* Filename charset encoding flags */  
	__le32  s_orphan_file_inum;	/* Inode for tracking orphan inodes */  
	__le32	s_reserved[94];		/* Padding to the end of the block */  
	__le32	s_checksum;		/* crc32c(superblock) */  
};  
  
  
```  
  
## man ext4で重要な内容を確認する。  
全て使う情報なので、どれも重要であることは間違いないが、全てのメンバについて出力する物を作っていると非常に大変なので、最初のほうに出てくるいくつかのメンバに限定する。  
  
### __le32	s_inodes_count;		/* Inodes count */  
inodeの数  
### __le32	s_blocks_count_lo;	/* Blocks count */  
データブロックの数  
### __le32	s_r_blocks_count_lo;	/* Reserved blocks count */  
スーパーユーザー専用に確保されているブロック。  
  
### __le32	s_free_blocks_count_lo;	/* Free blocks count */  
未使用のデータブロックの数  
### __le32	s_free_inodes_count;	/* Free inodes count */  
未使用のinodeの数  
### __le32	s_first_data_block;	/* First Data Block */  
最初のデータブロックの番号  
### __le32	s_log_block_size;	/* Block size */  
データブロックのサイズ  
### __le32	s_log_cluster_size;	/* Allocation cluster size */  
クラスターサイズを表す指数値  
### __le32	s_blocks_per_group;	/* # Blocks per group */  
グループごとのブロックの数  
### __le32	s_clusters_per_group;	/* # Clusters per group */  
グループごとのクラスターの数  
### __le32	s_inodes_per_group;	/* # Inodes per group */  
グループごとのinodeの数  
### __le32	s_mtime;		/* Mount time */  
最後にマウントされた時刻  
### __le32	s_wtime;		/* Write time */  
最後にアンマウントされた時刻  
### __le16	s_mnt_count;		/* Mount count */  
ファイルシステムが何回マウントされたか。  
### __le16	s_max_mnt_count;	/* Maximal mount count */  
fsckを強制実行する前の最大マウント回数  
### __le16	s_magic;		/* Magic signature */  
ファイルシステム識別用のマジックナンバー  
### __le16	s_state;		/* File system state */  
ファイルシステムの状態  
### __le16	s_errors;		/* Behaviour when detecting errors */  
エラー発生時の挙動  
### __le16	s_minor_rev_level;	/* minor revision level */  
マイナーリビジョン番号  
### __le32	s_lastcheck;		/* time of last check */  
fsckを最後に実行した時刻  
### __le32	s_checkinterval;	/* max. time between checks */  
自動fsckの推奨間隔(秒)  
### __le32	s_creator_os;		/* OS */  
システムのOS  
### __le32	s_rev_level;		/* Revision level */  
リビジョンレベル  
### __le16	s_def_resuid;		/* Default uid for reserved blocks */  
予約ブロックを使えるユーザーのUID  
### __le16	s_def_resgid;		/* Default gid for reserved blocks */  
予約ブロックを使えるグループのGID	  
  
## 各メンバの型である__le16 __le32 __le64は何か？  
リトルエンディアン型の整数  
  
## ディスクにはどうやってアクセスするのか？  
/dev/sddで実際のディスクにアクセスできる。  
linuxは全てのものをファイルとして扱うことができるので、ディスクもファイルとして扱う。  
open、seek,read,closeシステムコールを用いて、アクセスしてみることにする。  
  
## ソースコード  
ext4_super_block構造体は#includeすることがかなり面倒だったため、内容をコピーして貼り付けた。  
そこから以下のような処理を行った。  
```  
#include <byteswap.h>  
#include <endian.h>  
#include <fcntl.h>  
#include <stdint.h>  
#include <stdio.h>  
#include <stdlib.h>  
#include <time.h>  
#include <unistd.h>  
  
typedef uint8_t __u8;  
typedef uint16_t __le16;  
typedef uint32_t __le32;  
typedef uint64_t __le64;  
  
#define EXT4_LABEL_MAX 16  
  
struct ext4_super_block {  
  /*00*/ __le32 s_inodes_count;      /* Inodes count */  
  __le32 s_blocks_count_lo;          /* Blocks count */  
  __le32 s_r_blocks_count_lo;        /* Reserved blocks count */  
  __le32 s_free_blocks_count_lo;     /* Free blocks count */  
  /*10*/ __le32 s_free_inodes_count; /* Free inodes count */  
  __le32 s_first_data_block;         /* First Data Block */  
  __le32 s_log_block_size;           /* Block size */  
  __le32 s_log_cluster_size;         /* Allocation cluster size */  
  /*20*/ __le32 s_blocks_per_group;  /* # Blocks per group */  
  __le32 s_clusters_per_group;       /* # Clusters per group */  
  __le32 s_inodes_per_group;         /* # Inodes per group */  
  __le32 s_mtime;                    /* Mount time */  
  /*30*/ __le32 s_wtime;             /* Write time */  
  __le16 s_mnt_count;                /* Mount count */  
  __le16 s_max_mnt_count;            /* Maximal mount count */  
  __le16 s_magic;                    /* Magic signature */  
  __le16 s_state;                    /* File system state */  
  __le16 s_errors;                   /* Behaviour when detecting errors */  
  __le16 s_minor_rev_level;          /* minor revision level */  
  /*40*/ __le32 s_lastcheck;         /* time of last check */  
  __le32 s_checkinterval;            /* max. time between checks */  
  __le32 s_creator_os;               /* OS */  
  __le32 s_rev_level;                /* Revision level */  
  /*50*/ __le16 s_def_resuid;        /* Default uid for reserved blocks */  
  __le16 s_def_resgid;               /* Default gid for reserved blocks */  
  /*  
   * These fields are for EXT4_DYNAMIC_REV superblocks only.  
   *  
   * Note: the difference between the compatible feature set and  
   * the incompatible feature set is that if there is a bit set  
   * in the incompatible feature set that the kernel doesn't  
   * know about, it should refuse to mount the filesystem.  
   *  
   * e2fsck's requirements are more strict; if it doesn't know  
   * about a feature in either the compatible or incompatible  
   * feature set, it must abort and not try to meddle with  
   * things it doesn't understand...  
   */  
  __le32 s_first_ino;               /* First non-reserved inode */  
  __le16 s_inode_size;              /* size of inode structure */  
  __le16 s_block_group_nr;          /* block group # of this superblock */  
  __le32 s_feature_compat;          /* compatible feature set */  
  /*60*/ __le32 s_feature_incompat; /* incompatible feature set */  
  __le32 s_feature_ro_compat;       /* readonly-compatible feature set */  
  /*68*/ __u8 s_uuid[16];           /* 128-bit uuid for volume */  
  /*78*/ char s_volume_name[EXT4_LABEL_MAX]; /* volume name */  
  /*88*/ char s_last_mounted[64];            /* directory where last mounted */  
  /*C8*/ __le32 s_algorithm_usage_bitmap;    /* For compression */  
  /*  
   * Performance hints.  Directory preallocation should only  
   * happen if the EXT4_FEATURE_COMPAT_DIR_PREALLOC flag is on.  
   */  
  __u8 s_prealloc_blocks;         /* Nr of blocks to try to preallocate*/  
  __u8 s_prealloc_dir_blocks;     /* Nr to preallocate for dirs */  
  __le16 s_reserved_gdt_blocks;   /* Per group desc for online growth */  
                                  /*  
                                   * Journaling support valid if EXT4_FEATURE_COMPAT_HAS_JOURNAL set.  
                                   */  
  /*D0*/ __u8 s_journal_uuid[16]; /* uuid of journal superblock */  
  /*E0*/ __le32 s_journal_inum;   /* inode number of journal file */  
  __le32 s_journal_dev;           /* device number of journal file */  
  __le32 s_last_orphan;           /* start of list of inodes to delete */  
  __le32 s_hash_seed[4];          /* HTREE hash seed */  
  __u8 s_def_hash_version;        /* Default hash version to use */  
  __u8 s_jnl_backup_type;  
  __le16 s_desc_size; /* size of group descriptor */  
  /*100*/ __le32 s_default_mount_opts;  
  __le32 s_first_meta_bg;  /* First metablock block group */  
  __le32 s_mkfs_time;      /* When the filesystem was created */  
  __le32 s_jnl_blocks[17]; /* Backup of the journal inode */  
  /* 64bit support valid if EXT4_FEATURE_INCOMPAT_64BIT */  
  /*150*/ __le32 s_blocks_count_hi; /* Blocks count */  
  __le32 s_r_blocks_count_hi;       /* Reserved blocks count */  
  __le32 s_free_blocks_count_hi;    /* Free blocks count */  
  __le16 s_min_extra_isize;         /* All inodes have at least # bytes */  
  __le16 s_want_extra_isize;        /* New inodes should reserve # bytes */  
  __le32 s_flags;                   /* Miscellaneous flags */  
  __le16 s_raid_stride;             /* RAID stride */  
  __le16 s_mmp_update_interval;     /* # seconds to wait in MMP checking */  
  __le64 s_mmp_block;               /* Block for multi-mount protection */  
  __le32 s_raid_stripe_width;       /* blocks on all data disks (N*stride)*/  
  __u8 s_log_groups_per_flex;       /* FLEX_BG group size */  
  __u8 s_checksum_type;             /* metadata checksum algorithm used */  
  __u8 s_encryption_level;          /* versioning level for encryption */  
  __u8 s_reserved_pad;              /* Padding to next 32bits */  
  __le64 s_kbytes_written;          /* nr of lifetime kilobytes written */  
  __le32 s_snapshot_inum;           /* Inode number of active snapshot */  
  __le32 s_snapshot_id;             /* sequential ID of active snapshot */  
  __le64 s_snapshot_r_blocks_count; /* reserved blocks for active  
                                       snapshot's future use */  
  __le32 s_snapshot_list;           /* inode number of the head of the  
                                       on-disk snapshot list */  
#define EXT4_S_ERR_START offsetof(struct ext4_super_block, s_error_count)  
  __le32 s_error_count;        /* number of fs errors */  
  __le32 s_first_error_time;   /* first time an error happened */  
  __le32 s_first_error_ino;    /* inode involved in first error */  
  __le64 s_first_error_block;  /* block involved of first error */  
  __u8 s_first_error_func[32]; /* function where the error happened  
                                */  
  __le32 s_first_error_line;   /* line number where error happened */  
  __le32 s_last_error_time;    /* most recent time of an error */  
  __le32 s_last_error_ino;     /* inode involved in last error */  
  __le32 s_last_error_line;    /* line number where error happened */  
  __le64 s_last_error_block;   /* block involved of last error */  
  __u8 s_last_error_func[32];  /* function where the error happened */  
#define EXT4_S_ERR_END offsetof(struct ext4_super_block, s_mount_opts)  
  __u8 s_mount_opts[64];  
  __le32 s_usr_quota_inum;    /* inode for tracking user quota */  
  __le32 s_grp_quota_inum;    /* inode for tracking group quota */  
  __le32 s_overhead_clusters; /* overhead blocks/clusters in fs */  
  __le32 s_backup_bgs[2];     /* groups with sparse_super2 SBs */  
  __u8 s_encrypt_algos[4];    /* Encryption algorithms in use  */  
  __u8 s_encrypt_pw_salt[16]; /* Salt used for string2key algorithm */  
  __le32 s_lpf_ino;           /* Location of the lost+found inode */  
  __le32 s_prj_quota_inum;    /* inode for tracking project quota */  
  __le32 s_checksum_seed;     /* crc32c(uuid) if csum_seed set */  
  __u8 s_wtime_hi;  
  __u8 s_mtime_hi;  
  __u8 s_mkfs_time_hi;  
  __u8 s_lastcheck_hi;  
  __u8 s_first_error_time_hi;  
  __u8 s_last_error_time_hi;  
  __u8 s_first_error_errcode;  
  __u8 s_last_error_errcode;  
  __le16 s_encoding;         /* Filename charset encoding */  
  __le16 s_encoding_flags;   /* Filename charset encoding flags */  
  __le32 s_orphan_file_inum; /* Inode for tracking orphan inodes */  
  __le32 s_reserved[94];     /* Padding to the end of the block */  
  __le32 s_checksum;         /* crc32c(superblock) */  
};  
  
int show_superblock(struct ext4_super_block *sb) {  
  
  time_t mtime;  
  time_t wtime;  
  time_t lastcheck;  
  
    
  
  printf("inodeの総数 : %d \n", sb->s_inodes_count);  
  printf("データブロックの数                       : %d \n",  
         sb->s_blocks_count_lo);  
  printf("スーパーユーザー専用のブロック           : %d \n",  
         sb->s_r_blocks_count_lo);  
  printf("未使用のデータブロックの数               : %d \n",  
         sb->s_free_blocks_count_lo);  
  printf("未使用のinodeの数                        : %d \n",  
         sb->s_free_inodes_count);  
  printf("最初のデータブロックの番号               : %d \n",  
         sb->s_first_data_block);  
  
  printf("データブロックのサイズを表す指数値       : %d \n",  
         sb->s_log_block_size);  
  
  printf("クラスターサイズを表す指数値             : %d \n",  
         sb->s_log_cluster_size); //何か処理すべき  
  
  printf("グループごとのブロック数                 : %d \n",  
         sb->s_blocks_per_group);  
  printf("グループごとのクラスター数               : %d \n",  
         sb->s_clusters_per_group);  
  printf("グループごとのinodeの数                  : %d \n",  
         sb->s_inodes_per_group);  
  mtime = sb->s_mtime;  
  printf("最後にマウントされた時刻                 : %s",  
         ctime(&mtime)); //時間の処理を行う  
  wtime = sb->s_wtime;  
  printf("最後にアンマウントされた時刻             : %s",  
         ctime(&wtime)); //時間の処理を行う  
  
  printf("ファイルシステムが何回マウントされたか   : %d \n", sb->s_mnt_count);  
  printf("fsckを強制実行する前の最大マウント回数   : %d \n",  
         sb->s_max_mnt_count);  
  
  printf("ファイルシステム識別用のマジックナンバー : 0x%X \n", sb->s_magic);  
  printf("ファイルシステムの状態                   : %d \n", sb->s_state);  
  printf("エラー発生時の挙動                       : %d \n", sb->s_errors);  
  
  printf("マイナーリビジョン番号                   : %d \n",  
         sb->s_minor_rev_level);  
    
  lastcheck = sb->s_lastcheck;  
  printf("fsckを最後に実行した時刻                 : %s",  
         ctime(&lastcheck)); //時間の処理を行う  
  printf("自動fsckの推奨間隔(秒)                   : %d \n",  
         sb->s_checkinterval);  
  printf("システムのOS                             : %d \n", sb->s_creator_os);  
  printf("リビジョンレベル                         : %d \n", sb->s_rev_level);  
  printf("予約ブロックを使えるユーザーのuid        : %d \n", sb->s_def_resuid);  
  printf("予約ブロックを使えるグループのgid        : %d \n", sb->s_def_resgid);  
  
  return 0;  
}  
  
int main(int ac, char *av[]) {  
  int fd;  
  struct ext4_super_block sb;  
  
  if ((fd = open("/dev/sdd", O_RDONLY)) == -1) {  
    perror("open");  
    exit(1);  
  }  
  
  if (lseek(fd, 1024, SEEK_SET) == -1) {  
    perror("seek");  
    exit(1);  
  }  
  
  if (read(fd, &sb, sizeof(sb)) == -1) {  
    perror("read");  
    exit(1);  
  }  
  
  show_superblock(&sb);  
  
  if (close(fd) == -1) {  
    perror("close");  
    exit(1);  
  }  
  
  return 0;  
}  
```  
## 実行結果  
```  
taichi84@DESKTOP-LFCUOR7:~/learning/unix_linux_programing/chapter4/question/4.18$ sudo ./sb1   
[sudo] taichi84 のパスワード:   
inodeの総数 : 16777216   
データブロックの数                       : 67108864   
スーパーユーザー専用のブロック           : 3355443   
未使用のデータブロックの数               : 62616928   
未使用のinodeの数                        : 16429173   
最初のデータブロックの番号               : 0   
データブロックのサイズを表す指数値       : 2   
クラスターサイズを表す指数値             : 2   
グループごとのブロック数                 : 32768   
グループごとのクラスター数               : 32768   
グループごとのinodeの数                  : 8192   
最後にマウントされた時刻                 : Wed Sep 17 22:15:47 2025  
最後にアンマウントされた時刻             : Thu Sep 18 00:16:09 2025  
ファイルシステムが何回マウントされたか   : 156   
fsckを強制実行する前の最大マウント回数   : 65535   
ファイルシステム識別用のマジックナンバー : 0xEF53   
ファイルシステムの状態                   : 1   
エラー発生時の挙動                       : 1   
マイナーリビジョン番号                   : 0   
fsckを最後に実行した時刻                 : Thu Apr 11 01:35:05 2019  
自動fsckの推奨間隔(秒)                   : 0   
システムのOS                             : 0   
リビジョンレベル                         : 1   
予約ブロックを使えるユーザーのuid        : 0   
予約ブロックを使えるグループのgid        : 0   
```  
