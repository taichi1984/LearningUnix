# 研究課題 3.9    
## 課題内容    
**端末のオーナー** ユーザーは、端末または端末エミュレーションプログラムを介してシステムに接続する。    
各端末は、/dev　ディレクトリにファイルとして姿を現す。ls -l /dev/tty* more を実行してみよう。    
このコマンドは、全ての端末デバイスとそのプロパティを表示する。    
通常のファイルとどうお湯に、端末を表すファイルはオーナーを持つ。    
端末のオーナーは、その端末でログインしているユーザーになっている。    
使われていない端末デバイスのオーナーは、rootである。    
端末のオーナーは、loginプログラムによって変更される。    
loginプログラムのソースコードを入手し、オーナーを変更するコードを探しなさい。    
ログアウトしたときに、オーナーをrootに戻すのはどのプログラムか。    
    
## /dev/tty* moreしてみる。    
    
```    
crw-rw-rw- 1 root tty     5,  0 Aug 12 20:09 /dev/tty    
crw--w---- 1 root tty     4,  0 Aug 12 19:51 /dev/tty0    
crw--w---- 1 root tty     4,  1 Aug 12 19:52 /dev/tty1    
crw--w---- 1 root tty     4, 10 Aug 12 19:51 /dev/tty10    
crw--w---- 1 root tty     4, 11 Aug 12 19:51 /dev/tty11    
crw--w---- 1 root tty     4, 12 Aug 12 19:51 /dev/tty12    
crw--w---- 1 root tty     4, 13 Aug 12 19:51 /dev/tty13    
crw--w---- 1 root tty     4, 14 Aug 12 19:51 /dev/tty14    
crw--w---- 1 root tty     4, 15 Aug 12 19:51 /dev/tty15    
crw--w---- 1 root tty     4, 16 Aug 12 19:51 /dev/tty16    
crw--w---- 1 root tty     4, 17 Aug 12 19:51 /dev/tty17    
crw--w---- 1 root tty     4, 18 Aug 12 19:51 /dev/tty18    
crw--w---- 1 root tty     4, 19 Aug 12 19:51 /dev/tty19    
crw--w---- 1 root tty     4,  2 Aug 12 19:52 /dev/tty2    
crw--w---- 1 root tty     4, 20 Aug 12 19:51 /dev/tty20    
crw--w---- 1 root tty     4, 21 Aug 12 19:51 /dev/tty21    
crw--w---- 1 root tty     4, 22 Aug 12 19:51 /dev/tty22    
crw--w---- 1 root tty     4, 23 Aug 12 19:51 /dev/tty23    
crw--w---- 1 root tty     4, 24 Aug 12 19:51 /dev/tty24    
crw--w---- 1 root tty     4, 25 Aug 12 19:51 /dev/tty25    
```    
    
自分の環境ではwslなので、直接の端末ではログインできてない。    
リモート端末を確認するため/dev/pts/* で試す    
    
```    
crw--w---- 1 taichi84 tty  136, 0 Aug 12 20:29 /dev/pts/0    
crw------- 1 taichi84 tty  136, 1 Aug 12 19:52 /dev/pts/1    
crw--w---- 1 taichi84 tty  136, 2 Aug 12 20:29 /dev/pts/2    
c--------- 1 root     root   5, 2 Aug 12 19:51 /dev/pts/ptmx    
```    
    
自分の端末を発見。使われていないものはrootになっている模様。    
    
## loginのソースコードを入手する。    
/etc/apt/source.list に以下の３行を追加する。    
    
```    
deb-src http://archive.ubuntu.com/ubuntu jammy main restricted universe multiverse    
deb-src http://archive.ubuntu.com/ubuntu jammy-updates main restricted universe multiverse    
deb-src http://archive.ubuntu.com/ubuntu jammy-security main restricted universe multiverse    
```    
aptをアップデート後、ソースコードを置きたいフォルダをカレントディレクトリにして以下を実行。    
    
```    
sudo apt update    
apt source login    
```    
    
以下のようなファイルが用意される。    
    
```    
shadow-4.8.1     
shadow_4.8.1-2ubuntu2.2.debian.tar.xz    
shadow_4.8.1-2ubuntu2.2.dsc    
shadow_4.8.1.orig.tar.xz    
```    
    
dpkgコマンドで全部まとめて展開してパッチ適用    
    
```    
dpkg-source -x shadow_4.8.1-2ubuntu2.2.dsc    
```    
    
/shadow-4.8.1/src/login.cを発見！    
    
    
## loginのソースコードを読んで、端末のオーナーを変更するコードを探す。    
### 関数プロトタイプ宣言からそれらしい名前の関数を探す。    
    
```    
/* local function prototypes */    
static void usage (void);    
static void setup_tty (void);    
static void process_flags (int argc, char *const *argv);    
static /*@observer@*/const char *get_failent_user (/*@returned@*/const char *user);    
static void update_utmp (const char *user,    
                         const char *tty,    
                         const char *host,    
```    
    
見た感じsetup_ttyが怪しい。    
    
### setup_ttyを読む    
    
```    
static void setup_tty (void)    
{    
	TERMIO termio;    
    
	if (GTTY (0, &termio) == 0) {	/* get terminal characteristics */    
		int erasechar;    
		int killchar;    
    
		/*    
		 * Add your favorite terminal modes here ...    
		 */    
		termio.c_lflag |= ISIG | ICANON | ECHO | ECHOE;  
		termio.c_iflag |= ICRNL;  
    
#if defined(ECHOKE) && defined(ECHOCTL)    
		termio.c_lflag |= ECHOKE | ECHOCTL;  
#endif    
#if defined(ECHOPRT) && defined(NOFLSH) && defined(TOSTOP)    
		termio.c_lflag &= ~(ECHOPRT | NOFLSH | TOSTOP);  
#endif    
#ifdef ONLCR    
		termio.c_oflag |= ONLCR;  
#endif    
    
		/* leave these values unchanged if not specified in login.defs */    
		erasechar = getdef_num ("ERASECHAR", (int) termio.c_cc[VERASE]);    
		killchar = getdef_num ("KILLCHAR", (int) termio.c_cc[VKILL]);    
		termio.c_cc[VERASE] = (cc_t) erasechar;    
		termio.c_cc[VKILL] = (cc_t) killchar;    
		/* Make sure the values were valid.    
		 * getdef_num cannot validate this.    
		 */    
		if (erasechar != (int) termio.c_cc[VERASE]) {    
			fprintf (stderr,    
			         _("configuration error - cannot parse %s value: '%d'"),    
			         "ERASECHAR", erasechar);    
			exit (1);    
		}    
		if (killchar != (int) termio.c_cc[VKILL]) {    
			fprintf (stderr,    
			         _("configuration error - cannot parse %s value: '%d'"),    
			         "KILLCHAR", killchar);    
			exit (1);    
		}    
    
		/*    
		 * ttymon invocation prefers this, but these settings    
		 * won't come into effect after the first username login     
		 */    
		(void) STTY (0, &termio);    
	}    
}    
```    
    
どうやら端末の設定をしているようだ。それらしき記述はない。    
    
### ソースコード内からchownシステムコールを呼んでいる場所があるか探す。    
    
nvimで以下を検索    
    
```    
chown    
```    
    
1225行目(main関数内)に以下の記述を発見    
    
```    
    
	chown_tty (pwd);    
    
```    
chownシステムコールではないが、関数名から推測する限り    
chown_tty(pwd);という関数がttyのオーナーを変更していそうだ。    
実際はどうなのかを確認してみるため、manページで探せるか見てみが見当たらず。    
#includeを確認してみる。    
    
```    
    
#include <config.h>    
    
#ident "$Id$"    
    
#include <errno.h>    
#include <grp.h>    
#ifndef USE_PAM    
#include <lastlog.h>    
#endif				/* !USE_PAM */    
#include <pwd.h>    
#include <signal.h>    
#include <stdio.h>    
#include <sys/stat.h>    
#include <sys/ioctl.h>    
#include <assert.h>    
#include "defines.h"    
#include "faillog.h"    
#include "failure.h"    
#include "getdef.h"    
#include "prototypes.h"    
#include "pwauth.h"    
/*@-exitarg@*/    
#include "exitcodes.h"    
    
```    
ライブラリ化されている<>で囲われているヘッダファイルの他にもいくらかのファイルがあるようだ。    
この中にchown_ttyの記載があるか確認したい。    
```    
/shadow-4.8.1/lib$ grep -R "chown_tty" .    
./prototypes.h:extern void chown_tty (const struct passwd *);    
```    
    
prototypes.hの中にありそうだ。    
    
```    
/* chowntty.c */    
extern void chown_tty (const struct passwd *);    
```    
    
prototype.hの中にこの関数定義を発見。コメントからするに実体はchowntty.cにある模様？    
    
```    
$ find -name chowntty.c    
    
./libmisc/chowntty.c    
```    
libmiscの中にあるようだ。    
    
```    
    
void chown_tty (const struct passwd *info)    
{    
	struct group *grent;    
	gid_t gid;    
    
	/*    
	 * See if login.defs has some value configured for the port group    
	 * ID.  Otherwise, use the user's primary group ID.    
	 */    
    
	grent = getgr_nam_gid (getdef_str ("TTYGROUP"));    
	if (NULL != grent) {    
		gid = grent->gr_gid;    
	} else {    
		gid = info->pw_gid;    
	}    
    
	/*    
	 * Change the permissions on the TTY to be owned by the user with    
	 * the group as determined above.    
	 */    
    
	if (   (fchown (STDIN_FILENO, info->pw_uid, gid) != 0)    
	    || (fchmod (STDIN_FILENO, (mode_t)getdef_num ("TTYPERM", 0600)) != 0)) {  
		int err = errno;    
    
		fprintf (stderr,    
		         _("Unable to change owner or mode of tty stdin: %s"),    
		         strerror (err));    
		SYSLOG ((LOG_WARN,    
		         "unable to change owner or mode of tty stdin for user `%s': %s\n",    
		         info->pw_name, strerror (err)));    
		if (EROFS != err) {    
			closelog ();    
			exit (EXIT_FAILURE);    
		}    
	}    
#ifdef __linux__    
	/*    
	 * Please don't add code to chown /dev/vcs* to the user logging in -    
	 * it's a potential security hole.  I wouldn't like the previous user    
	 * to hold the file descriptor open and watch my screen.  We don't    
	 * have the *BSD revoke() system call yet, and vhangup() only works    
	 * for tty devices (which vcs* is not).  --marekm    
	 */    
#endif    
}    
    
    
```    
    
ソースコードを見る限り,    
id( (fchown ... で始まるコードでttyのオーナーの変更をしていそうだ。    
これがオーナーを変更しているソースコードとみて間違いないだろう。    
    
## rootに戻すのはどのプログラムかも確認する。    
どうしても探せなかったので、chatgptに確認したところ、login.cの子プロセスが消滅したときの処理にあるらしい？    
    
