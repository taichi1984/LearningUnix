# プログラミング課題
## 課題内容
通常のシェルは、終わりのfiを読み込むまで制御構造全体の実行を先延ばしにする。(注意:ちなみにfiはfinalの略ではなく、ifを倒置したものである。)
本文とは全く異なる方法として、if構造のすべての行をまず３つの部分を持つデータ構造に読むことが考えられる。
第１の部分は条件コマンド、第２の部分はthen領域のコマンドのリスト、第３部分はelse領域のコマンドのリストである。
全体の構造をメモリに読み込んだら、条件コマンドを実行し、その結果に基づいてthenリストかelseリストを実行する。
この方法を使ってif制御構造を処理するsmshを書きなさい。解答は、入れ子上のifを処理できなければならない。

## 実行を先延ばしにするためにどうすればいいか？
実行を先延ばしにするためには、現在の１行毎の逐次実行型のsmshから、ifが来た場合は逐次実行をやめ、
if部をすべて読み込んでからif部をすべて実行して、そこからifでなければまた１行ずつ実行する仕組みにしないといけない。

## 現在のコード
###  現在のprocess.c
```
/* process.c
 * コマンド処理レイヤ
 *
 * process(char **arglist)関数は、メインループから呼び出され、
 * execute()関数の前に位置する。このレイヤは、主として、次の２つの処理を行う。
 * a) 組み込み関数 ( 例えば, exit() , set , = , read など）
 * b) 制御構造 (例えば、 if while ,forなど)
 *
 */

#include "smsh.h"
#include <stdio.h>

int is_control_command(char *);
int do_control_command(char **);
int ok_to_execute();

int process(char **args)
/*
 * 目的:ユーザーコマンドの処理
 * 戻り値:コマンドの処理結果
 * 詳細: 組み込みコマンドなら適切な関数を呼び出す、そうでなければexecute()する。
 * エラー: サブルーチンで処理されたものが上がってくる。
 */
{
  int rv = 0;

  if (args[0] == NULL)
    rv = 0;
  else if (is_control_command(args[0]))
    rv = do_control_command(args);
  else if (ok_to_execute())
    rv = execute(args);
  return rv;
}

```

### 現在のcontrol_flow.c
```
/* controlflow.c
 *
 * " if " 処理は、if_stateとif_resultの２個の状態変数を使って行う。
 */

#include "smsh.h"
#include <stdio.h>
#include <string.h>

enum states {
  NEUTRAL,
  IF_SUCCEEDED,
  IF_FAILED,
  SKIPPING_THEN,
  DOING_THEN,
  SKIPPING_ELSE,
  DOING_ELSE
};

static int if_state = NEUTRAL;
static int last_stat = 0;

int syn_err(char *);

int ok_to_execute()
/*
 * 目的 : シェルがコマンドを実行すべきかどうかを判断する。
 * 戻り値: イエスなら１，ノーなら0
 * 詳細 : THEN_BLOCK内にいて、if_resultがSUCCESSならイエス
 *        THEN_BLOCK内にいて、if_resultがFAILならノー
 *        WANT_THENなら構文エラー(shは異なる)
 */
{
  int rv = 1; /*デフォルトは真 */

  if (if_state == IF_SUCCEEDED || if_state == IF_FAILED) {
    syn_err("then expected");
    rv = 0;
  } else if (if_state == DOING_THEN)
    rv = 1;
  else if (if_state == SKIPPING_THEN)
    rv = 0;
  else if (if_state == SKIPPING_ELSE)
    rv = 0;
  else if (if_state == DOING_ELSE)
    rv = 1;

  return rv;
}

int is_control_command(char *s)
/*
 * コマンドがシェル制御コマンドかどうかを報告するbool関数
 * 戻り値: 0 か 1
 */
{
  return (strcmp(s, "if") == 0 || strcmp(s, "then") == 0 ||
          strcmp(s, "fi") == 0) ||
         strcmp(s, "else") == 0;
}

int do_control_command(char **args)
/*
 * 目的 : "if" , "then " , "fi" を処理する -- 状態を変更するかエラーを検出する。
 * 戻り値 : OK なら0、構文エラーなら-1
 * メモ : I would have put returns all over the place , Barry says "no"
 */
{
  char *cmd = args[0];
  int rv = -1;

  if (strcmp(cmd, "if") == 0) {
    if (if_state != NEUTRAL)
      rv = syn_err("if unexpected");
    else {
      last_stat = process(args + 1);
      if_state = (last_stat == 0 ? IF_SUCCEEDED : IF_FAILED);
      rv = 0;
    }
  } else if (strcmp(cmd, "then") == 0) {
    if (if_state != IF_FAILED && if_state != IF_SUCCEEDED)
      rv = syn_err("then unexpected");
    else {
      if (if_state == IF_SUCCEEDED)
        if_state = DOING_THEN;
      if (if_state == IF_FAILED)
        if_state = SKIPPING_THEN;
      rv = 0;
    }
  } else if (strcmp(cmd, "else") == 0) {
    if (if_state != DOING_THEN && if_state != SKIPPING_THEN) {
      rv = syn_err("else unexpected");
    } else {
      if (if_state == DOING_THEN)
        if_state = SKIPPING_ELSE;
      if (if_state == SKIPPING_THEN)
        if_state = DOING_ELSE;
      rv = 0;
    }
  } else if (strcmp(cmd, "fi") == 0) {
    if (if_state == IF_SUCCEEDED || if_state == IF_FAILED ||
        if_state == NEUTRAL) {
      rv = syn_err("fi unexpected");
    } else {
      if_state = NEUTRAL;
      rv = 0;
    }
  } else
    fatal("internal error processing:", cmd, 2);
  return rv;
}

int syn_err(char *msg)
/* 目的:制御構造内の構文エラーを処理する。
 *  詳細:状態をNEUTRALにリセットする。
 *  戻り値: 対話的モードなら1、スクリプト内では、fatal呼び出しになる。
 */
{
  if_state = NEUTRAL;
  fprintf(stderr, "syntax error : %s\n", msg);
  return -1;
}

```

## 要件の整理
### ifの処理
ifが来た場合、実行を待たなければならないため、if ~~~ fi までの間を一気にパースする必要がある。
現在のdo_control_commandは１行１行を確認して実行可能かを判断して戻り値を返し、ok_to_executeで実行可否を判定して実行しているだけなので、
まずはif〜fiまでをparseして格納しておくだけの仕組みを作る必要がある。

### if_block構造体の作成
```
typedef struct {
  char ***args;
  int cap;
  int size;
} args_block;

typedef struct if_block {
  args_block if_part;
  args_block then_part;
  args_block else_part;
} if_block;

```

このようなif_block構造体に１行ごとの配列を格納し、 capとsizeをうまく使ってメモリを動的に確保する仕組みを作る必要がある。

### 今読んでいるところはどこか？というstate machineの作成
```
enum states {
  NEUTRAL,
  IF_BLOCK,
  THEN_BLOCK,
  ELSE_BLOCK,
};
```

ifの外を読んでいる場合は(つまり初期状態とfiのあと)はNEUTRAL
ifがきたら、状態をIF_BLOCKに変更して、if_blockのif_partにifを除いて格納
thenがきたら状態をTHEN_BLOCKに変更して、if_blockのthen_partにthenを除いて格納
elseがきたら状態をELSE_BLOCKに変更して、if_blockのelse_partにelseを除いて格納

これでifの中身を３つのパートにわける。

### if文用の実行関数の用意
exec_if_block(if_block *ifb);というような関数を作る。

```
exec_if_block(if_block *ifb){
    if(execute(ifb->if_part)){
        execute(ifb->then_part);
    }else{
        execute(ifb->else_part);
    }
}
```

というようなイメージの関数を作り、条件に応じて実行するようにする。
この時点ではexecuteはifb->then_partを受け付けない(char 二重ポインタは受け付けるが三重ポインタは受け付けない仕様)なので、
順次実行するための仕組みが必要になる。

### 各構造体を実行するための関数

```
void exec_args_block(args_block args){
    for(int i = 0; i < size; i++){
        execute(args[i]);
}

void exec_if_block(if_block *ifb){
    if(exec_args_block){
        exec_args_block(ifb->then_part);
    }else{
        exec_args_block(ifb->else_part);
    }
}

```

### do_control_commandの改善
これはifがきたら、if_block ifbを用意して、parse_if_blockとexec_if_blockをifbを渡して実行するだけの関数にする。
これでifの判定実行は可能になる。(1段階のみ、ネスト非対応)


## ifをどうやって入れ子に対応させるか。
args_blockは、 *** args は格納できるが、if_blockは格納できない。
そのため、現在の構造体では入れ子にしていくのは難しい。この問題を解決するには、if_blockもしくは**arglistを格納する構造体が欲しい。
コマンドを行ごとではなく、意味（１行のコマンドや、if_blockなど）の意味ごとに格納できる構造体が必要だ。

### stmt(statement)の導入
if文と普通のコマンド文両方をうまく格納できる構造体、stmtとそのstmtの配列であるstmt_blockを用意する。
if_blockの各partをstmt_blockに変更する。

```
typedef enum { STMT_CMD, STMT_IF } stmt_type;

struct if_block;

typedef struct {
  stmt_type type;
  union {
    char **cmd;
    struct if_block *ifb;
  };
} stmt;

typedef struct {
  stmt *stmts;
  int cap;
  int size;
} stmt_block;

typedef struct if_block {
  stmt_block if_part;
  stmt_block then_part;
  stmt_block else_part;
} if_block;

```
 
stmt_typeでそのstmtがただのコマンドなのか、それともif_blockなのかを情報として持たせる。
そしてparse_if_blockで、各条件ごとにparseし、else_blockやthen_blockでifが来た場合に再帰的にparse_if_blockを呼ぶようにする。

実行の際も今までargsに対応していたものをstmt_blockやstmtに対応したものに書き換える。
そうすることで、ifのネスト構造を再帰的に探索し、実行することができるようになる。
またstmtが状態を持つことで必要がなくなった、ok_to_executeやdo_control_commandやis_control_commandなどは削除する。

## 完成コード

### smsh2.c
```

#include "smsh.h"
#include <signal.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>

#define DFL_PROMPT "> "
int main() {
  char *cmdline, *prompt, **arglist;
  int result, process(char **);
  char *end;
  void setup();

  prompt = DFL_PROMPT;
  setup();

  while ((cmdline = next_cmd(prompt, stdin)) != NULL) {
    if ((arglist = splitline(cmdline)) != NULL) {
      result = process(arglist);
      freelist(arglist);
    }
    free(cmdline);
  }
  return 0;
}

void setup()
/*
 * 目的:シェルの初期化
 * 戻り値：なし、トラブルが起きたらfatal()を呼び出す。
 */
{
  signal(SIGINT, SIG_IGN);
  signal(SIGQUIT, SIG_IGN);
}

void fatal(char *s1, char *s2, int n) {
  fprintf(stderr, "Error: %s,%s\n", s1, s2);
  exit(n);
}

```

### splitline.c
```

/* splitline.c - smshのためにコマンドを呼んで解析する関数。
 *
 *   char *next_cmd(char *prompt , FILE *fp)
 *   char **splitline(char *str);
 */

#include "smsh.h"
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

char *next_cmd(char *prompt, FILE *fp)
/*
 * 目的：fpから次のコマンド行を読み出す。
 * 戻り値：コマンド行を保持する動的に確保した文字列。
 * エラー：EOFならNULL(本当はエラーではない)
 *         emalloc()からfatalを呼び出す。
 * メモ  : BUFSIZ単位でメモリを確保する。
 */
{
  char *buf;        /*バッファ*/
  int bufspace = 0; /*サイズ合計*/
  int pos = 0;      /*現在位置*/
  int c;            /*入力文字*/

  printf("%s", prompt); /* ユーザーにプロンプトを出力する */
  while ((c = getc(fp)) != EOF) {
    /* need space ?*/
    if (pos + 1 >= bufspace) {
      if (bufspace == 0)
        buf = emalloc(BUFSIZ);
      else
        buf = erealloc(buf, bufspace + BUFSIZ);
      bufspace += BUFSIZ;
    }
    if (c == '\n')
      break;

    buf[pos++] = c;
  }
  if (c == EOF && pos == 0)
    return NULL;
  buf[pos] = '\0';
  return buf;
}

/**
** splitline( 行を解析して文字列配列に分割する )
**/
#define is_delim(x) ((x) == ' ' || (x) == '\t')

char **splitline(char *line)
/*
 * 目的：行を空白区切りにトークンに分割する。
 * 戻り値: トークンのコピーを指す末尾がNULLのポインタ配列。
 * 　　　　行にトークンが含まれていない場合はNULL
 * 動作  : 配列を準にチェックし、文字列を探してコピーを作る。
 * メモ  :
 * strtok()を使えば簡単だが、あとでクォートに対応するつもりなので、strtok()は使わない。
 */
{
  char *newstr(char *, int);
  char **args;
  int spots = 0;    /*テーブルの要素数*/
  int bufspace = 0; /*テーブルのバイト数*/
  int argnum = 0;   /*使った要素の数*/
  char *cp = line;  /*文字列のpos*/
  char *start;
  int len;

  if (line == NULL)
    return NULL;

  args = emalloc(BUFSIZ);
  bufspace = BUFSIZ;
  spots = BUFSIZ / sizeof(char *);

  while (*cp != '\0') {
    while (is_delim(*cp))
      cp++;
    if (*cp == '\0')
      break;

    /* 配列が充分なスペースを持つようにする(+1はNULLの分) */
    if (argnum + 1 >= spots) {
      args = erealloc(args, bufspace + BUFSIZ);
      bufspace += BUFSIZ;
      spots += (BUFSIZ / sizeof(char *));
    }

    /* 先頭にマークをつけ、単語の末尾を探す。*/
    start = cp;
    len = 1;
    while (*++cp != '\0' && !(is_delim(*cp)))
      len++;
    args[argnum++] = newstr(start, len);
  }
  args[argnum] = NULL;
  return args;
}

/*
 * 目的：文字列のコンストラクタ
 * 戻り値: 文字列、NLにはならない。
 */
char *newstr(char *s, int l) {
  char *rv = emalloc(l + 1);

  rv[l] = '\0';
  strncpy(rv, s, l);
  return rv;
}

void freelist(char **list)
/*
 *  目的:splitlineが返したリストを開放する。
 *  戻り値：なし
 *  動作：リスト内の全ての文字列を開放して、リストを開放する。
 */
{
  char **cp = list;
  while (*cp)
    free(*cp++);
  free(list);
}

void *emalloc(size_t n) {
  void *rv;
  if ((rv = malloc(n)) == NULL)
    fatal("out of memory", "", 1);
  return rv;
}

void *erealloc(void *p, size_t n) {
  void *rv;
  if ((rv = realloc(p, n)) == NULL)
    fatal("realloc() failed", "", 1);
  return rv;
}
```

### execute.c
```
/* execute.c - smshがコマンドを実行するために使うコード*/

#include <signal.h>
#include <stdio.h>
#include <stdlib.h>
#include <sys/wait.h>
#include <unistd.h>

int execute(char *argv[])
/*
 * 目的:引数を渡してプログラムを起動する。
 * 戻り値:waitを介して、返された終了ステータス。エラーの場合は-1。
 * エラー:fork()かwait()がエラーを起こしたときには-1
 */
{
  int pid;
  int child_info = -1;

  if (argv[0] == NULL)
    return 0;

  if ((pid = fork()) == -1)
    perror("fork");
  else if (pid == 0) {
    signal(SIGINT, SIG_DFL);
    signal(SIGQUIT, SIG_DFL);
    execvp(argv[0], argv);
    perror("cannot execute command");
    exit(1);
  } else {
    if (wait(&child_info) == -1)
      perror("wait");
  }
  return child_info;
}

```

### process.c
```

/* process.c
 * コマンド処理レイヤ
 *
 * process(char **arglist)関数は、メインループから呼び出され、
 * execute()関数の前に位置する。このレイヤは、主として、次の２つの処理を行う。
 * a) 組み込み関数 ( 例えば, exit() , set , = , read など）
 * b) 制御構造 (例えば、 if while ,forなど)
 *
 */

#include "smsh.h"
#include "stmt.h"
#include <stdio.h>
#include <string.h>

int is_control_command(char *);
int do_control_command(char **);
int ok_to_execute();
int parse_if_block(if_block *ifb, char **args);
int exec_if_block(if_block *ifb);

int process(char **args)
/*
 * 目的:ユーザーコマンドの処理
 * 戻り値:コマンドの処理結果
 * 詳細: 組み込みコマンドなら適切な関数を呼び出す、そうでなければexecute()する。
 * エラー: サブルーチンで処理されたものが上がってくる。
 */
{
  int rv = 0;

  if (args[0] == NULL)
    return 0;

  if (strcmp(args[0], "if") == 0) {
    if_block ifb;
    parse_if_block(&ifb, args);
    exec_if_block(&ifb);
  }

  else {
    rv = execute(args);
  }
  return rv;
}
```

### controlflow.c
```

/* controlflow.c
 *
 * " if " 処理は、if_stateとif_resultの２個の状態変数を使って行う。
 */

#include "smsh.h"
#include "stmt.h"
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#define INIT_CAP 4

enum states {
  NEUTRAL,
  IF_BLOCK,
  THEN_BLOCK,
  ELSE_BLOCK,
};

int syn_err(char *, int if_state);
int exec_if_block(if_block *ifb);

void stmt_block_init(stmt_block *blk) {
  blk->cap = INIT_CAP;
  blk->size = 0;
  blk->stmts = malloc(sizeof(stmt) * blk->cap);
}

int stmt_push(stmt_block *blk, stmt s) {
  if (blk->size >= blk->cap) {
    blk->cap *= 2;
    blk->stmts = realloc(blk->stmts, sizeof(stmt) * blk->cap);
  }
  blk->stmts[blk->size++] = s;
  return 0;
}

int exec_block(stmt_block *blk) {
  for (int i = 0; i < blk->size; i++) {
    stmt *s = &blk->stmts[i];
    if (s->type == STMT_CMD) {
      execute(s->cmd);
    } else if (s->type == STMT_IF) {
      exec_if_block(s->ifb);
    }
  }
  return 0;
}

int exec_if_block(if_block *ifb) {
  int status;
  if (execute(ifb->if_part.stmts[0].cmd) == 0) {
    status = exec_block(&ifb->then_part);
  } else {
    status = exec_block(&ifb->else_part);
  }
  return status;
}

char **parse_if_block(if_block *ifb, char **args)
/*
 * 目的 : "if" , "then " , "fi" を処理する --
 * 状態を変更するかエラーを検出する。 戻り値 : OK なら0、構文エラーなら-1 メモ
 * : I would have put returns all over the place , Barry says "no"
 */
{
  char *cmdline;
  char **arglist = args;
  int if_state = NEUTRAL;

  stmt_block_init(&ifb->if_part);
  stmt_block_init(&ifb->then_part);
  stmt_block_init(&ifb->else_part);

  while (arglist != NULL) {
    if ((if_state == THEN_BLOCK || if_state == ELSE_BLOCK) &&
        strcmp(arglist[0], "if") == 0) {
      if (if_state == THEN_BLOCK) {

        if_block *nested = malloc(sizeof(if_block));
        arglist = parse_if_block(nested, arglist);

        stmt s = (stmt){.type = STMT_IF, .ifb = nested};
        stmt_push(&ifb->then_part, s);

        continue;
      }
      if (if_state == ELSE_BLOCK) {
        if_block *nested = malloc(sizeof(if_block));
        arglist = parse_if_block(nested, arglist);

        stmt s = (stmt){.type = STMT_IF, .ifb = nested};
        stmt_push(&ifb->else_part, s);

        continue;
      }
    } else if (if_state == NEUTRAL && strcmp(arglist[0], "if") == 0) {
      if_state = IF_BLOCK;
      if (arglist[1] == NULL) {
        syn_err("missing if condition", if_state);
        break;
      }
      stmt s = (stmt){.type = STMT_CMD, .cmd = &arglist[1]};
      stmt_push(&ifb->if_part, s);
    } else if (strcmp(arglist[0], "then") == 0) {
      if (if_state != IF_BLOCK) {
        syn_err("then unexpected", if_state);
        break;
      }
      if (ifb->if_part.size == 0) {
        syn_err("missing if condition", if_state);
        break;
      }
      if_state = THEN_BLOCK;
    } else if (strcmp(arglist[0], "else") == 0) {
      if (if_state != THEN_BLOCK) {
        syn_err("else unexpected", if_state);
        break;
      } else {
        if (if_state == THEN_BLOCK)
          if_state = ELSE_BLOCK;
      }
    } else if (strcmp(arglist[0], "fi") == 0) {
      if (if_state != THEN_BLOCK && if_state != ELSE_BLOCK) {
        syn_err("fi unexpected", if_state);
        return NULL;
      }

      cmdline = next_cmd(">", stdin);
      if (!cmdline)
        return NULL;

      arglist = splitline(cmdline);
      return arglist;

    } else {
      if (if_state == IF_BLOCK) {
        if (ifb->if_part.size > 0) { // 条件は１コマンドのみ許可
          syn_err("multiple if conditions", if_state);
          break;
        }
      }
      if (if_state == THEN_BLOCK) {
        stmt s = (stmt){.type = STMT_CMD, .cmd = arglist};
        stmt_push(&ifb->then_part, s);
      }
      if (if_state == ELSE_BLOCK) {
        stmt s = (stmt){.type = STMT_CMD, .cmd = arglist};
        stmt_push(&ifb->else_part, s);
      }
    }
    cmdline = next_cmd(">", stdin);
    if (!cmdline) {
      arglist = NULL;
      break;
    }

    arglist = splitline(cmdline);
    if (!arglist) {
      break;
    }
  }

  return arglist;
}

int syn_err(char *msg, int if_state)
/* 目的:制御構造内の構文エラーを処理する。
 *  詳細:状態をNEUTRALにリセットする。
 *  戻り値: 対話的モードなら1、スクリプト内では、fatal呼び出しになる。
 */
{
  if_state = NEUTRAL;
  fprintf(stderr, "syntax error : %s\n", msg);
  return -1;
}
```

### smsh.h
```

#define YES 1
#define NO 0
#include <stddef.h>
#include <stdio.h>

char *next_cmd(char* , FILE*);
char **splitline(char *);
void freelist(char **);
void *emalloc(size_t);
void *erealloc(void * , size_t);
int execute(char **);
void fatal(char *,char * ,int);

int process(char **args);


```

### stmt.h
```

#ifndef STMT_H
#define STMT_H

typedef enum { STMT_CMD, STMT_IF } stmt_type;

struct if_block;

typedef struct {
  stmt_type type;
  union {
    char **cmd;
    struct if_block *ifb;
  };
} stmt;

typedef struct {
  stmt *stmts;
  int cap;
  int size;
} stmt_block;

typedef struct if_block {
  stmt_block if_part;
  stmt_block then_part;
  stmt_block else_part;
} if_block;

#endif
```

## 実行結果

```

$ cat testsentence
if ls
then
  echo "this is outer then "
  if ls ../
  then
    echo "this is inner then"
  else
    echo "this is inner else"
  fi
else
echo "this is else statement"
fi

$ cat testsentence | ./smsh2
9.9.md	controlflow.c  execute.c  process.c  smsh.h  smsh2  smsh2.c  splitline.c  stmt.h  testsentence
"this is outer then "
9.01  9.02  9.03  9.04	9.05  9.06  9.07  9.08	9.09
"this is inner then"

$ cat testsentence2
if ls 
then
  echo "this is outer then "
  if ls fail
  then
    echo "this is inner then"
  else
    echo "this is inner else"
  fi
else
echo "this is else statement"
fi

$ cat testsentence2 | ./smsh2
9.9.md	controlflow.c  execute.c  process.c  smsh.h  smsh2  smsh2.c  splitline.c  stmt.h  testsentence	testsentence2
"this is outer then "
ls: 'fail' にアクセスできません: そのようなファイルやディレクトリはありません
"this is inner else"

$ cat testsentence3
if ls fail 
then
  echo "this is outer then "
  if ls fail
  then
    echo "this is inner then"
  else
    echo "this is inner else"
  fi
else
echo "this is else statement"
fi

$ cat testsentence3 | ./smsh2
ls: 'fail' にアクセスできません: そのようなファイルやディレクトリはありません
"this is else statement"
$ 
```

入れ子のifがきちんと動いているのを確認できる。
プロンプトの表示に多少問題があるが（見やすいように実行結果を修正済み）そこの問題さえ解決できれば
ifの入れ子に関しては論理的には問題なく動いているようだ。

## まとめと感想
細かいバグの修正はまだ残っているが、概ね機能は満たせているので学習範囲はここまでにする。
今回は構造体内でのunionの使い方や、nestに対応させるための構造体の定義、構造体に応じた書き換え、状態機械(state machine)のについての学習。
ポインタへの更に深い理解、C言語の指示付き初期化子の理解など、多くのことを覚えた。

## 今回使ったもので、名前付きで覚えるべき重要な概念
### 構文表現
AST(抽象構文木)

### 構文解析
Recursive Descent Parsing（再帰下降構文解析）

### 制御
State Machine (状態機械)

### 実行モデル
Parse / Executeの２段階モデル
Deferred Execution (遅延実行)

### デザインパターン
Compositeパターン（今回のstmt)
Interpreter パターン（ASTを作りノードごとに意味を定義して再帰的に評価する)

### C言語仕様
Tagged Union(判別共用体)
Designated Initializer(指示付き初期化子)

### その他
Control Structure Desugaring



