# ファイルモードとパーミッションについて

## stat()で取れる、st_modeとはなんなのか？
st_modeは16ビットの情報である。16ビットの部分文字列の中に別々の属性が符号化されている。

```

[_][_][_][_][u][g][s][r][w][x][r][w][x][r][w][x]
|   タイプ  |　|  |  |ユーザー|グループ|その他 |
             |   |  |
             |   |  +____ スティッキービット
             |   +____ sgid
             +_______suid 



```

### ファイルタイプ
最初の４ビットはファイルタイプを表す。


| 文字  | 意味            | 説明例                       |
| --- | ------------- | ------------------------- |
| `-` | 通常ファイル        | テキストファイルや実行ファイルなど         |
| `d` | ディレクトリ        | フォルダ                      |
| `l` | シンボリックリンク     | 別ファイルやディレクトリへの参照          |
| `c` | キャラクタデバイス     | `/dev/null` など、1文字単位のデバイス |
| `b` | ブロックデバイス      | `/dev/sda` など、ブロック単位のデバイス |
| `p` | 名前付きパイプ（FIFO） | プロセス間通信用の特殊ファイル           |
| `s` | ソケット          | UNIXドメインソケットなど            |
| `D` | ドア（Solarisのみ） | Solaris特有のIPCメカニズム        |

4ビットは1と0から構成される16種類のパターンを格納できる(2^{4})
現在は少なくとも上記の７種類(Solaris入れて8種類)のファイルタイプがある。

### suid 
5ビット目 set-user-ID １なら属性をオン。0ならオフとなっている。

### sgid
6ビット目 set-group-ID １なら属性をオン。0ならオフとなっている。

### スティッキービット
7ビット目。
ファイル・ディレクトリの制御に使われる特殊なパーミッションビットの一つ。
特にディレクトリに設定したときに意味を持つ。
ディレクトリのスティッキービットをオンにすると、そのディレクトリの中のファイルはオーナーユーザー以外には削除できなくなる。

### パーミッションビット(user, group , other)
8～16ビット目
ユーザー、グループ、その他の人のためのパーミッションビット。
ユーザー、グループ、その他の人それぞれ３ビットの領域があり、８種類の内容を表現できる。(2^{3})
各１ビット目が読み取り、２ビット目が書き込み、３ビット目が実行になっており、１なら許可、０なら不許可になっている。



## サブフィールドコーディング
大きな文字列の部分フィールドに特別な意味をパッキングするのはよく見られるテクニック。
これをサブフィールドコーディングという。

```
例

617-495-4204   市外局番、市内局番、番号
027-93-1111   社会保障番号
128.103.33.100   IPアドレス

```

212-333-4444という電話番号の市外局番が212かどうかはどうやって調べるのか？
最初の３桁の数字を見て、それが212という文字列になっているかどうかをチェックすればいい。
もしくは ** 最初の３桁分の数字以外を0にして、212-000-0000と比較するという方法もある。**

このように数字を０に置き換えて、部分フィールドだけが見えるようにすることをマスキング:maskingと呼ぶ。
一連のマスクを使えば、st_modeをls -l が表示する文字列に変換できる。

### 知識１:マスキングのコンセプト
値のマスキングとは、数値に含まれるビットを０に変えて、部分フィールドだけが残るようにすること。

### 知識2 :整数とは、ビットを並べたものに過ぎない。
整数は、コンピューターでは、ビットシーケンスとして格納されている。

```
215 = [1][1][0][1][0][1][1][1]

  左のビットから128,64,32,16,8,4,2,1 となっている。
1ビットで２種類の数値を表せるので8ビットで2^{8}個の数字を表現することが可能。


```

### 知識3:マスキングのテクニック
 ビット単位のAND演算(&演算子)を使えばよい。

```
      [1][0][0][0][0][0][0][1][1][0][1][1][0][1][0][0]
＆    [0][0][0][0][0][0][0][0][1][0][1][1][0][0][0][0]

=     [0][0][0][0][0][0][0][0][1][0][1][1][0][0][0][0]

このようにすることで、元の数値の１だった部分がマスクによって0に置き換わる
もちろん&演算なので取り出したい部分の場所を１にしておいても、元が０ならきちんと０で取れる。

```

### 知識4 : 8進数を使う
 2進法で特に16ビットや32ビットのような長いマスクを操作するのは難しい。
長い２進数は、３桁ごとに区切って、その３桁ずつを１個の８進数に置き換えるとわかりやすい。

```
3桁の2進数は8進数で表せる。

[1][1][1] = 7
[1][1][0] = 6
[1][0][1] = 5
[1][0][0] = 4 
[0][1][1] = 3 
[0][1][0] = 2 
[0][0][1] = 1 
[0][0][0] = 0

```

## マスキングを使ってファイルタイプを解読する。
ファイルタイプはst_modeの最初の4ビットに符号化されている。
マスクを使えば情報をデコードできる。

上位4桁以外が0になるようにマスキングをして、得られた結果と次のファイルタイプを表すコードと比較すればよい

```
#define  S_IFMT     0170000   /* ファイルのタイプ */
#define  S_IFREG    0100000   /* 通常 */
#define  S_IFDIR    0040000   /* ディレクトリ */
#define  S_IFBLK    0060000   /* ブロックデバイス */
#define  S_IFCHR    0020000   /* キャラクタデバイス */
#define  S_IFIFO    0010000   /* FIFO( 名前付きパイプ ) */
#define  S_IFLNK    0120000   /* シンボリックリンク */
#define  S_IFSOCK   0140000   /* ソケット */ 

```

S_IFMTというシンボルは最初の4ビットだけを残すためのマスクで、0170000という値になっている。

つまりこんな感じで使う。

```
if((info.st_mode & S_IFMT) == 0040000)
        printf("this is a directory.\n");

```

ちなみにマスクしてテストを書きたくなければ、sys/stat.h に定義されている次のマクロを使えばいい。

```
#define S_ISFIFO(m) (((m) & (0170000)) == (0010000))
#define S_ISDIR(m) (((m) & (0170000)) == (0040000))
#define S_ISCHR(m) (((m) & (0170000)) == (0020000))
#define S_ISBLK(m) (((m) & (0170000)) == (0060000))
#define S_ISREG(m) (((m) & (0170000)) == (0100000))


if( S_ISDIR(info.st_mode) )
    printf("this is a directory.");

```






