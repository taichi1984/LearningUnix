# プログラミング課題 2.15  
  
## 課題内容  
** ファイル破壊の防止 ** 標準版のcpは、何も言わずに既存のファイルを書き換えてしまう。  
つまり、file2という名前のファイルが既にあるときに、次のように入力すると、  
  
```  
$ cp file1 file2  
```  
file2 にもともと格納されていた内容は破壊されてしまう。しかし、標準版のcpは、  
ファイルを上書きする前にそれでよいか同かを尋ねる-i オプションをサポートしている。  
cp1.cにもその機能を追加しなさい。  
  
## cp -i file1 file2 を確認する。  
  
```  
  
$ cat file1  
this is file 1  
  
$ cat file2  
this is file 2  
  
$ cp -i file1 file2  
cp: overwrite 'file2'? n  
  
$ cat file2  
this is file 2  
  
$ cp -i file1 file2  
cp: overwrite 'file2'? y  
$ cat file2  
this is file 1  
  
```  
  
-i オプションをつけるとcp:overwrite 'file2'? と聞かれyと入力で上書き、nと入力でキャンセルのようだ。試しにaで打ってみたところ、キャンセルされた様子だったので、yと入力したら上書き、それ以外を入力した場合をキャンセルという仕様だという前提で考えていく。  
  
## cp1の改良  
  
```  
  
#include <fcntl.h>  
#include <stdio.h>  
#include <stdlib.h>  
#include <string.h>  
#include <unistd.h>  
  
#define BUFFERSIZE 4096  
#define COPYMODE 0644  
  
void oops(char *, char *);  
  
int main(int ac, char *av[]) {  
  
  int in_fd, out_fd, n_chars;  
  int interactive = 0; //-iオプションが指定されたか?  
  char buf[BUFFERSIZE];  
  char *src, *dst;  
  char choice;  
  
  /*-iオプションが設定されているかどうかの判定*/  
  if (ac == 4 && strcmp(av[1], "-i") == 0) {  
    interactive = 1;  
    src = av[2];  
    dst = av[3];  
  } else if (ac == 3) {  
    src = av[1];  
    dst = av[2];  
  } else {  
    fprintf(stderr, "usage: %s source destination\n", *av);  
    exit(1);  
  }  
  /* -i オプションが付与されているかつdstファイルが存在する場合の処理 */  
  if (interactive && access(dst, F_OK) == 0) {  
    printf("cp: overwrite \'%s\'?", av[3]);  
    scanf("%c", &choice);  
    if (choice != 'y' && choice != 'Y') {  
      printf("Not overwritten.\n");  
      exit(0);  
    }  
  }  
  
  if ((in_fd = open(src, O_RDONLY)) == -1)  
    oops("Cannot open ", src);  
  if ((out_fd = creat(dst, COPYMODE)) == -1)  
    oops("Cannot creat ", dst);  
  
  while ((n_chars = read(in_fd, buf, BUFFERSIZE)) > 0)  
    if (write(out_fd, buf, n_chars) != n_chars)  
      oops("Write error to ", av[2]);  
  
  if (n_chars == -1)  
    oops("Read error from ", av[1]);  
  
  if (close(in_fd) == -1 || close(out_fd) == -1)  
    oops("Error closing files", "");  
}  
  
void oops(char *s1, char *s2) {  
  fprintf(stderr, "Error : %s ", s1);  
  perror(s2);  
  exit(1);  
}  
```  
  
実行結果  
```  
/* 確認画面でn（や他の文字）を入力したときに書き換わらないことを確認。*/  
$ ./cp_remake -i file1 file2  
cp: overwrite 'file2'?n  
$ cat file2  
this is file 2  
  
/* 確認画面でyを入力したときに書き換わることを確認*/  
$ ./cp_remake -i file1 file2  
cp: overwrite 'file2'?y  
$ cat file2  
this is file 1  
  
  
/* file2の内容を元に戻して、通常のcpが機能しているか確認*/  
$ echo "this is file 2" > file2  
$ cat file2  
this is file 2  
$ ./cp_remake file1 file2  
$ cat file2  
this is file 1  
  
```  
  
コマンドライン引数の処理さえできれば、そこまで難しい処理でもない。  
ポイントはaccess()関数で、ファイル名のファイルが存在するかしないかの確認をするところになる。  
あとは場合分けして、適切に流れを記述すればいいだけ。  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
