# プログラミング問題8.10
## 課題内容
**複数のSIGCHLD** 引数として整数を取り、それだけの数の子プロセスを作成するプログラムを書きなさい。
全ての子は5秒間眠って出力する。
親プロセスは、SIGCHLDハンドラをセットアップして、1秒に1回メッセージを出力するループに入る。
ハンドラはwaitを呼び出し、子のプロセスIDを出力して、カウンタをインクリメントする。
このカウンタが作った子の数になったら、プログラムは終了する。
子を様々な数にしてこのプログラムをテストしなさい。
数字を大きくすると、プログラムは1部の子に対応するシグナルを受け損なうように見える。
なぜ、シグナルを受け損なうことがあるのか、解決方法はあるのか、説明しなさい。


## なぜシグナルを受け損なうことがあるのか？
シグナルを受け損なう理由は、SIGCHLDの本質は子プロセスが死んだときに発生するシグナルではなく
１個以上の子プロセスになんらかの変更があった場合に、通知されるSIGNALだからである。
SIGCHLDは１個以上の変更があった場合に変更があったことを通知するだけで、子プロセス群に何が起こったのか、どのプロセスに変化があったのかは通知しない。
そして、SIGCHLDはその処理が終わって初めて、次の変化が通知されうる仕組みになっている。

つまり、ごく短時間（SIGCHLDの処理をする前）に複数の子プロセスに変化があった場合、SIGCHLDは１回しか発生しない。
これがシグナルを受け損なう理由となっている。

## 解決策
SIGCHLDのハンドラ内で、子プロセスの変化をwaitpidで回収できなくなるまでループさせ、画面にそのpidを表示する。
画面の表示に関してはハンドラ内ではprintfを使うのは危険なため、writeシステムコールで表示するようにする。

## プログラムコード


```
/* waitdemo_sigchld.c -
 * SIGCHLDを取得して、子がexitを呼び出したら、子の終了ステータスを報告するメッセージを出力して終了する。*/

#include <signal.h>
#include <stdio.h>
#include <stdlib.h>
#include <sys/wait.h>
#include <unistd.h>

#define DELAY 5
volatile sig_atomic_t sigchld_counter = 0;
volatile sig_atomic_t sigchld_flag = 0;

int main(int ac, char *av[]) {
  int newpid;
  void child_code(int), parent_code(int, int);
  void sigchld_handler(int);
  int num_of_child = 0;

  num_of_child = atoi(av[1]);

  printf("before : mypid is %d\n", getpid());

  signal(SIGCHLD, sigchld_handler);
  for (int i = 0; i < num_of_child; i++) {
    if ((newpid = fork()) == -1)
      perror("fork");
    else if (newpid == 0)
      child_code(DELAY);
  }

  if (newpid != -1 && newpid != 0) {
    parent_code(newpid, num_of_child);
  }
}

/*
 * 新プロセスは昼寝して終了
 */

void child_code(int delay) {
  printf("child %d here. will sleep for %d seconds\n", getpid(), delay);
  sleep(delay);
  printf("child (%d) done. about to exit\n", getpid());
  exit(17);
}

/*
 * 親は子が終了するのを待ち、メッセージを出力する
 */

void parent_code(int childpid, int num_of_child) {
  int wait_rv;
  int child_status;
  int high_8, low_7, bit_7;

  while (sigchld_counter < num_of_child) {
    printf("waiting...\n");
    sleep(1);
  }
}

void sigchld_handler(int signum) {
  int status;
  pid_t pid;

  while ((pid = waitpid(-1, &status, WNOHANG)) > 0) {
    sigchld_counter++;

    char buf[64];
    int len = snprintf(buf, sizeof(buf), "child %d exited\n", pid); // 本当は危険だが課題上しょうがないので、今回はsnprintfを使う。
    write(STDOUT_FILENO, buf, len);
  }
}

```

## 実行結果
```
before : mypid is 11398
child 11399 here. will sleep for 5 seconds
child 11401 here. will sleep for 5 seconds
child 11402 here. will sleep for 5 seconds
child 11403 here. will sleep for 5 seconds
child 11400 here. will sleep for 5 seconds
child 11404 here. will sleep for 5 seconds
child 11405 here. will sleep for 5 seconds
waiting...
child 11406 here. will sleep for 5 seconds
child 11407 here. will sleep for 5 seconds
child 11408 here. will sleep for 5 seconds
waiting...
waiting...
waiting...
waiting...
child (11399) done. about to exit
child (11401) done. about to exit
child (11402) done. about to exit
child (11403) done. about to exit
child (11400) done. about to exit
child (11404) done. about to exit
child (11405) done. about to exit
child 11399 exited
child 11401 exited
child 11402 exited
child 11403 exited
child (11406) done. about to exit
child (11407) done. about to exit
waiting...
child (11408) done. about to exit
child 11400 exited
child 11404 exited
waiting...
child 11405 exited
child 11407 exited
child 11406 exited
waiting...
child 11408 exited

```

これで問題なく、waitpidが動いて画面にpidが表示できているのを確認できた。
きちんとプログラムも最終的には終了できたので問題ないだろう。


