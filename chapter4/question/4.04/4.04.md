# 研究課題 4.4
## 課題内容
カーネルは、新しいファイルを作成するときに、空きinodeと空きディスクブロックを探さなければならないと本文で述べた。
では、カーネルはどのようにして空きブロックを見分けるのだろうか。カーネルはどのようにして空きiノードを見分けるのだろうか。
あなたのマシンのファイルシステムは、未使用のブロックやiノードを管理するためにどのような方法を使っているか、説明しなさい。

## 自分のマシンのファイルシステムは何か？
今動かしているマシンのファイルシステムの仕様は ext4になる。
このext4とカーネルの動作について調べていくことにする。

## 未使用のブロックやinodeを管理するためにどのような方法を使っているのか？
以下のRed Hat Enterprise Linuxのガイドにて、ext4に関する記述を確認。

[Red Hat Enterprise Linux ストレージ管理ガイド第５章](https://docs.redhat.com/ja/documentation/red_hat_enterprise_linux/7/html/storage_administration_guide/ch-ext4)

```
ext4 では、未使用のブロックグループと inode テーブルのセクションにそれぞれラベル付けが行なわれます。これにより、ファイルシステムの検査時にこれらを省略することができます。また、ファイルシステムの検査速度が上がるため、ファイルシステムが大きくなるほどその便宜性は顕著になります。

```

ext4では未使用のブロックグループとinodeにラベル付けが行われることによって管理しているようだ。
カーネルはこのラベルをもとに空きブロックやinodeを確認しているに違いない。

## カーネルのソースを確認
読める気はしないけどカーネルのソースコードを確認する。

linux-6.17-rc5/fs/ext4/mballoc.c

にext4_mb_new_blocksという関数がある。
これが未使用のブロックグループに割り当てる関数のようだ。
内容を少しずつ読み、推測していくことにした。

### 形式
```
ext4_fsblk_t ext4_mb_new_blocks(handle_t *handle,
				struct ext4_allocation_request *ar, int *errp)
```

handle_tは何か不明。
ext4_allocation_requestはファイルを割り当ててくれというリクエスト。
int errpはおそらく、エラー内容が入るポインタと思われる。

戻り値は ext4_fsblk_tなので、おそらくファイルブロックが返される。

### 最初の変数宣言

```
	struct ext4_allocation_context *ac = NULL;
	struct ext4_sb_info *sbi;
	struct super_block *sb;
	ext4_fsblk_t block = 0;
	unsigned int inquota = 0;
	unsigned int reserv_clstrs = 0;
	int retries = 0;
	u64 seq;
```

この内容をみて、名前から推測できるのは

struct ext4_allocation_context はおそらく、割り当てのコンテキストであるということ。
struct ext4_sb_info ext4のスーパーブロックに関する情報
struct super_block  はスーパーブロックの情報
ext4_fsblk_t  は最終的にブロックが格納されて、この関数はそれを返すであろうということ
unsigned int inquota は現時点では不明
unsigned int reserv_clstrs も不明
int retriesは割り当ての失敗時のリトライ回数と思われる。これが一定回数を超えると割り当て失敗になるのでは？
u64 seq　は現時点では不明

といったところ。

### 最初の処理

```
	might_sleep();
	sb = ar->inode->i_sb;
	sbi = EXT4_SB(sb);
```

might_sleepはスケジューラを呼び出してスリープする可能性があることをチェックするためのデバッグ用マクロ/関数だそうです。(Chatgpt調べ)
本筋の処理とはロジック的に関係ないので飛ばします。

sb = ar->inode->i_sb;
というコードによると、割り当てリクエストはinode情報をすでに持っており、そのinode情報にはスーパーブロックの情報が含まれている模様。
つまり、カーネルはファイルブロックの確保より、inodeの確保のほうを先に行っていると思われる。

sbi = EXT4_SB(sb);

はsb情報をもとに、ext4用の追加情報を取得するマクロを使って、sbiにext4用の追加情報を取得していると思われる。



```
trace_ext4_request_blocks(ar);
```

細かい調査は難しかったため、chatgptにより情報を取得した。
この関数は、ブロック割り当て要求の詳細をログに吐く関数ということのようだ。

### ここまでの情報をもとにinodeの確保の方法を見てみる。
さきにinodeを確保しているので、inodeの確保方法の関数も見てみよう。
この関数はfs/ext4/ialloc.cの中にある。

```
struct inode *__ext4_new_inode(struct mnt_idmap *idmap,
			       handle_t *handle, struct inode *dir,
			       umode_t mode, const struct qstr *qstr,
			       __u32 goal, uid_t *owner, __u32 i_flags,
			       int handle_type, unsigned int line_no,
			       int nblocks)
```

関数の形式として引数にstruct inode *dirというものが含まれている。
これは、親ディレクトリのだと考えられる。

この後のソースコードも少し追っていこう。

```

	struct super_block *sb;
	struct buffer_head *inode_bitmap_bh = NULL;
	struct buffer_head *group_desc_bh;
	ext4_group_t ngroups, group = 0;
	unsigned long ino = 0;
	struct inode *inode;
	struct ext4_group_desc *gdp = NULL;
	struct ext4_inode_info *ei;
	struct ext4_sb_info *sbi;
	int ret2, err;
	struct inode *ret;
	ext4_group_t i;
	ext4_group_t flex_group;
	struct ext4_group_info *grp = NULL;
	bool encrypt = false;

	/* Cannot create files in a deleted directory */
	if (!dir || !dir->i_nlink)
		return ERR_PTR(-EPERM);

	sb = dir->i_sb;
	sbi = EXT4_SB(sb);

```

なんやかんや変数が宣言されているが、
ここで注目したいのは struct super_block *sb;

とその後の
sb = dir->i_sb;
sbi = EXT4_SB(sb);

である。

似たような処理がファイルブロックでも行われていたはずだ。
ここからわかることは

ファイルを特定のディレクトリに作りたい場合、カーネルはディレクトリのinodeを取得し、inode割り当てをする関数に渡す。
inodeの割り当て関数は親ディレクトリのinodeからスーパーブロックの情報を取得し、その情報をもとに新しいinodeの割り当てを行った後、
新しく割り当てられたinodeの持っているスーパーブロックの情報をもとにファイルブロックを確保していると思われる。

では、inodeが空いているかどうかはどう確認するのか?

## inodeやファイルブロックはブロックグループごとに管理されている。
inodeの取得やファイルブロックの取得にはスーパーブロックの情報を使っているのはわかった。

では、そのスーパーブロックの情報を使ってどのように空きブロックを確保しているのか？

### inodeやファイルブロックはブロックグループごとに管理されている。
inodeやファイルブロックはブロックグループという単位で管理されており、
各ブロックグループはinodeやファイルブロックの使用状況を表すbitmapを持っている。
そのbitmapを走査することにより(0 = 未使用,1 = 使用中)、特定のinodeやファイルブロックが空いているかどうかを確認している。

### スーパーブロックは各ブロックグループへのポインタを持っているのか？
持っていない。
ポインタを持つ代わりに、各ブロックグループの管理情報をまとめた表である、グループディスクリプタテーブルを持っている。
グループごとに以下を記録している。

- ブロックビットマップのブロック番号
- inode ビットマップのブロック番号
- inode テーブルの開始ブロック番号
- そのグループの空きブロック数・空き inode 数　など

このテーブルの内容をもとに、ビットマップを走査して空き領域を探すことになる。
ビットマップを読んで、空きブロック／inodeを判定することになる。

## まとめ
カーネルは未使用のinodeやブロックを知るために、まずは親ディレクトリのinodeの情報を取得する。
親ディレクトリのinodeからスーパーブロックの情報を参照し、そのスーパーブロックが持つ管理情報を使うことになる。
スーパーブロックにあるグループディスクリプタ情報からinodeビットマップより空きinodeを探し、そこに割り当てる。
空きinodeの情報をもとにファイルブロックの確保を行う。その際もグループディスクリプタでファイルブロックのビットマップを走査し、空きファイルブロックを探し割り当てる。






