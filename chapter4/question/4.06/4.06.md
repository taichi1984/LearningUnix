# 研究課題4.6  
## 課題内容  
本文では、ディスクブロックの割り当てリストについて、iノードには10個の直接ブロック、１個の間接ブロック  
１個のダブル間接ブロック、１個のトリプル間接ブロックが含まれると説明した。  
しかし一部のバージョンのUnixは、異なる数値を使っている。  
  
(a) あなたが使っているシステムのディスクブロック割り当てリストは、どのような形式になっているか説明しなさい。  
ヘッダファイルには、詳細情報が含まれているはずだ。  
  
(b) あなたのシステムでは、データブロックのサイズはいくつになっているのか答えなさい。  
  
(c) あなたのシステムでは、間接ブロックを使わない最大のファイルは何か、答えなさい。  
  
(d) あなたのシステムで、ダブル間接ブロックを使わない最大のファイルは何か、  
その巨大ファイルは実際には何個のブロックを使っているのか、答えなさい。  
  
## (a) ディスクブロック割り当てリストはどのようになっているか、確認する。  
確認の方法としては、課題4.5でinodeという構造体があるのを確認した。  
inode構造体がどのように定義されているのか、ヘッダファイルを探して確認すればわかるはずだ。  
  
linuxのカーネルのフォルダで以下のコマンドを入力した  
```  
find -name inode.c  
  
./fs/afs/inode.c  
./fs/efivarfs/inode.c  
./fs/ramfs/inode.c  
./fs/ufs/inode.c  
./fs/orangefs/inode.c  
./fs/pstore/inode.c  
./fs/adfs/inode.c  
./fs/devpts/inode.c  
./fs/fuse/inode.c  
./fs/f2fs/inode.c  
./fs/nilfs2/inode.c  
./fs/coda/inode.c  
./fs/ceph/inode.c  
./fs/debugfs/inode.c  
./fs/openpromfs/inode.c  
./fs/qnx4/inode.c  
./fs/bfs/inode.c  
./fs/udf/inode.c  
./fs/erofs/inode.c  
./fs/fat/inode.c  
./fs/cramfs/inode.c  
./fs/autofs/inode.c  
./fs/bcachefs/inode.c  
./fs/xfs/scrub/inode.c  
./fs/isofs/inode.c  
./fs/ecryptfs/inode.c  
./fs/squashfs/inode.c  
./fs/tracefs/inode.c  
./fs/ext4/inode.c  
./fs/ocfs2/inode.c  
./fs/ntfs3/inode.c  
./fs/befs/inode.c  
./fs/qnx6/inode.c  
./fs/exfat/inode.c  
./fs/kernfs/inode.c  
./fs/affs/inode.c  
./fs/minix/inode.c  
./fs/gfs2/inode.c  
./fs/omfs/inode.c  
./fs/smb/client/inode.c  
./fs/ext2/inode.c  
./fs/hfsplus/inode.c  
./fs/inode.c  
./fs/configfs/inode.c  
./fs/proc/inode.c  
./fs/jfs/inode.c  
./fs/efs/inode.c  
./fs/overlayfs/inode.c  
./fs/btrfs/inode.c  
./fs/hpfs/inode.c  
./fs/nfs/inode.c  
./fs/hfs/inode.c  
./fs/hugetlbfs/inode.c  
./arch/s390/hypfs/inode.c  
./arch/powerpc/platforms/cell/spufs/inode.c  
./drivers/usb/gadget/legacy/inode.c  
./security/inode.c  
./kernel/bpf/inode.c  
  
  
```  
  
たくさんのinode.cが出てきた。  
今の自分のシステムはファイルシステムがext4なので、こちらのファイルを確認してみる。  
  
```  
  
#include <linux/fs.h>  
#include <linux/mount.h>  
#include <linux/time.h>  
#include <linux/highuid.h>  
#include <linux/pagemap.h>  
#include <linux/dax.h>  
#include <linux/quotaops.h>  
#include <linux/string.h>  
#include <linux/buffer_head.h>  
#include <linux/writeback.h>  
#include <linux/pagevec.h>  
#include <linux/mpage.h>  
#include <linux/rmap.h>  
#include <linux/namei.h>  
#include <linux/uio.h>  
#include <linux/bio.h>  
#include <linux/workqueue.h>  
#include <linux/kernel.h>  
#include <linux/printk.h>  
#include <linux/slab.h>  
#include <linux/bitops.h>  
#include <linux/iomap.h>  
#include <linux/iversion.h>  
  
#include "ext4_jbd2.h"  
#include "xattr.h"  
#include "acl.h"  
#include "truncate.h"  
  
#include <trace/events/ext4.h>  
  
  
static void ext4_journalled_zero_new_buffers(handle_t *handle,  
					    struct inode *inode,  
					    struct folio *folio,  
					    unsigned from, unsigned to);  
  
...  
  
```  
  
内容をみると、一番上の関数で既にstruct inodeが使われているため、以上のどこかのヘッダファイルでinode型の構造体が定義されているはずだ。  
  
```  
grep -rn "struct inode {" include/  
で構造体の定義を探したところ  
  
include/linux/fs.h:674:struct inode {  
  
と発見。fs.hの674行目にあるようだ。  
```  
### inodeの定義  
```  
struct inode {  
	umode_t			i_mode;  
	unsigned short		i_opflags;  
	kuid_t			i_uid;  
	kgid_t			i_gid;  
	unsigned int		i_flags;  
  
#ifdef CONFIG_FS_POSIX_ACL  
	struct posix_acl	*i_acl;  
	struct posix_acl	*i_default_acl;  
#endif  
  
	const struct inode_operations	*i_op;  
	struct super_block	*i_sb;  
	struct address_space	*i_mapping;  
  
#ifdef CONFIG_SECURITY  
	void			*i_security;  
#endif  
  
	/* Stat data, not accessed from path walking */  
	unsigned long		i_ino;  
	/*  
	 * Filesystems may only read i_nlink directly.  They shall use the  
	 * following functions for modification:  
	 *  
	 *    (set|clear|inc|drop)_nlink
	 *    inode_(inc|dec)_link_count
	 */  
	union {  
		const unsigned int i_nlink;  
		unsigned int __i_nlink;  
	};  
	dev_t			i_rdev;  
	loff_t			i_size;  
	time64_t		i_atime_sec;  
	time64_t		i_mtime_sec;  
	time64_t		i_ctime_sec;  
	u32			i_atime_nsec;  
	u32			i_mtime_nsec;  
	u32			i_ctime_nsec;  
	u32			i_generation;  
	spinlock_t		i_lock;	/* i_blocks, i_bytes, maybe i_size */  
	unsigned short          i_bytes;  
	u8			i_blkbits;  
	enum rw_hint		i_write_hint;  
	blkcnt_t		i_blocks;  
  
#ifdef __NEED_I_SIZE_ORDERED  
	seqcount_t		i_size_seqcount;  
#endif  
  
	/* Misc */  
	u32			i_state;  
	/* 32-bit hole */  
	struct rw_semaphore	i_rwsem;  
  
	unsigned long		dirtied_when;	/* jiffies of first dirtying */  
	unsigned long		dirtied_time_when;  
  
	struct hlist_node	i_hash;  
	struct list_head	i_io_list;	/* backing dev IO list */  
#ifdef CONFIG_CGROUP_WRITEBACK  
	struct bdi_writeback	*i_wb;		/* the associated cgroup wb */  
  
	/* foreign inode detection, see wbc_detach_inode() */  
	int			i_wb_frn_winner;  
	u16			i_wb_frn_avg_time;  
	u16			i_wb_frn_history;  
#endif  
	struct list_head	i_lru;		/* inode LRU list */  
	struct list_head	i_sb_list;  
	struct list_head	i_wb_list;	/* backing dev writeback list */  
	union {  
		struct hlist_head	i_dentry;  
		struct rcu_head		i_rcu;  
	};  
	atomic64_t		i_version;  
	atomic64_t		i_sequence; /* see futex */  
	atomic_t		i_count;  
	atomic_t		i_dio_count;  
	atomic_t		i_writecount;  
#if defined(CONFIG_IMA) || defined(CONFIG_FILE_LOCKING)
	atomic_t		i_readcount; /* struct files open RO */  
#endif  
	union {  
		const struct file_operations	*i_fop;	/* former ->i_op->default_file_ops */  
		void (*free_inode)(struct inode *);  
	};  
	struct file_lock_context	*i_flctx;  
	struct address_space	i_data;  
	union {  
		struct list_head	i_devices;  
		int			i_linklen;  
	};  
	union {  
		struct pipe_inode_info	*i_pipe;  
		struct cdev		*i_cdev;  
		char			*i_link;  
		unsigned		i_dir_seq;  
	};  
  
  
#ifdef CONFIG_FSNOTIFY  
	__u32			i_fsnotify_mask; /* all events this inode cares about */  
	/* 32-bit hole reserved for expanding i_fsnotify_mask */  
	struct fsnotify_mark_connector __rcu	*i_fsnotify_marks;  
#endif  
  
#ifdef CONFIG_FS_ENCRYPTION  
	struct fscrypt_inode_info	*i_crypt_info;  
#endif  
  
#ifdef CONFIG_FS_VERITY  
	struct fsverity_info	*i_verity_info;  
#endif  
  
	void			*i_private; /* fs or device private pointer */  
}  
  
```  
  
長いが以上のようになっている。  
今回探したいのでゃ直接ブロック、間接ブロック、ダブル間接ブロック、トリプル間接ブロックについてだ。  
それらしきメンバを探してたが、それらしきメンバは見当たらない。  
  
この内容はVFSのinode構造体であり、ファイルシステム固有の構造体の中も調べてみる必要がありそうだ。  
自分のファイルシステムはext4なので、ext4のinode構造体を探してみよう。  
  
  
ext4.hファイルの中にinode構造体を発見した。  
  
```  
struct ext4_inode {  
	__le16	i_mode;		/* File mode */  
	__le16	i_uid;		/* Low 16 bits of Owner Uid */  
	__le32	i_size_lo;	/* Size in bytes */  
	__le32	i_atime;	/* Access time */  
	__le32	i_ctime;	/* Inode Change time */  
	__le32	i_mtime;	/* Modification time */  
	__le32	i_dtime;	/* Deletion Time */  
	__le16	i_gid;		/* Low 16 bits of Group Id */  
	__le16	i_links_count;	/* Links count */  
	__le32	i_blocks_lo;	/* Blocks count */  
	__le32	i_flags;	/* File flags */  
	union {  
		struct {  
			__le32  l_i_version;  
		} linux1;  
		struct {  
			__u32  h_i_translator;  
		} hurd1;  
		struct {  
			__u32  m_i_reserved1;  
		} masix1;  
	} osd1;				/* OS dependent 1 */  
	__le32	i_block[EXT4_N_BLOCKS];/* Pointers to blocks */  
	__le32	i_generation;	/* File version (for NFS) */  
	__le32	i_file_acl_lo;	/* File ACL */  
	__le32	i_size_high;  
	__le32	i_obso_faddr;	/* Obsoleted fragment address */  
	union {  
		struct {  
			__le16	l_i_blocks_high; /* were l_i_reserved1 */  
			__le16	l_i_file_acl_high;  
			__le16	l_i_uid_high;	/* these 2 fields */  
			__le16	l_i_gid_high;	/* were reserved2[0] */  
			__le16	l_i_checksum_lo;/* crc32c(uuid+inum+inode) LE */  
			__le16	l_i_reserved;  
		} linux2;  
		struct {  
			__le16	h_i_reserved1;	/* Obsoleted fragment number/size which are removed in ext4 */  
			__u16	h_i_mode_high;  
			__u16	h_i_uid_high;  
			__u16	h_i_gid_high;  
			__u32	h_i_author;  
		} hurd2;  
		struct {  
			__le16	h_i_reserved1;	/* Obsoleted fragment number/size which are removed in ext4 */  
			__le16	m_i_file_acl_high;  
			__u32	m_i_reserved2[2];  
		} masix2;  
	} osd2;				/* OS dependent 2 */  
	__le16	i_extra_isize;  
	__le16	i_checksum_hi;	/* crc32c(uuid+inum+inode) BE */  
	__le32  i_ctime_extra;  /* extra Change time      (nsec << 2 | epoch) */
	__le32  i_mtime_extra;  /* extra Modification time(nsec << 2 | epoch) */
	__le32  i_atime_extra;  /* extra Access time      (nsec << 2 | epoch) */
	__le32  i_crtime;       /* File Creation time */  
	__le32  i_crtime_extra; /* extra FileCreationtime (nsec << 2 | epoch) */
	__le32  i_version_hi;	/* high 32 bits for 64-bit version */  
	__le32	i_projid;	/* Project ID */  
};  
  
```  
  
  
  
```  
  
	__le32	i_block[EXT4_N_BLOCKS];/* Pointers to blocks */  
  
```  
  
  
```  
/*  
 * Constants relative to the data blocks  
 */  
#define	EXT4_NDIR_BLOCKS		12  
#define	EXT4_IND_BLOCK			EXT4_NDIR_BLOCKS  
#define	EXT4_DIND_BLOCK			(EXT4_IND_BLOCK + 1)  
#define	EXT4_TIND_BLOCK			(EXT4_DIND_BLOCK + 1)  
#define	EXT4_N_BLOCKS			(EXT4_TIND_BLOCK + 1)  
```  
ブロックへのポインタと添え字の定数の定義を発見した。  
EXT4_N_BLOCKSは15という定数のようだ。  
これがこのシステムでのブロックリストの形式ということになる。  
これが(a)の答えになる。  
  
## (b)このシステムのデータブロックのサイズはいくつか？  
  
(b)の答えはデータブロックの1ブロックのサイズを求めればよい。  
これはstat -f / 等で簡単に調べることができる。  
  
```  
$ stat -f .  
  File: "."  
    ID: fedc9aa3bd65bc57 Namelen: 255     Type: ext2/ext3  
Block size: 4096       Fundamental block size: 4096  
Blocks: Total: 65778193   Free: 62526861   Available: 59167322  
Inodes: Total: 16777216   Free: 16432490  
```  
  
Fundamental block sizeは(4KB)4096バイトのようだ。  
  
## (c) 自分のシステムでは間接ブロックを使わない最大のファイルは何か？  
4KB　× 12ブロックなので、48KBのファイルである。  
  
## (d) 自分のシステムで、ダブル間接ブロックを使わない最大のファイルは何か その巨大ファイルは実際には何個のブロックを使っているのか。  
まず、直接ブロックが12ブロックなので、48KB使われている。  
あと4KB分のintが含まれている。int型は4バイトで4096 / 4 = 1024ブロック。  
間接ブロックには1024ブロック保存出来ることを考えると、1036ブロックを保存できる。  
1036ブロック* 4 なので、4144KB　= 約4MBのファイル（実際には1036個のブロックを使っている)となる。  
  
  
  
  
  
  
  
  
