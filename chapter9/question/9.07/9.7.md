# プログラミング課題9.7
## 課題内容
ok_to_execute関数は、現在の領域と現在の状態を管理するために、２つの状態変数を使っている。しかし、取れる値を増やせば、２つの変数ではなく１つの変数で垂らすことができる。次時の状態を考慮すれば良い。

NEUTRAL, IF_SUCCEEDED, IF_FAILED, SKIPPING_THEN, DOING_THEN,
SKIPPING_ELSE, DOING_ELSE

controlflow.c を書き換えて、この１変数システムを実装しなさい。

## もともとのソースコード

```

/* controlflow.c
 *
 * " if " 処理は、if_stateとif_resultの２個の状態変数を使って行う。
 */

#include "smsh.h"
#include <stdio.h>
#include <string.h>

enum states { NEUTRAL, WANT_THEN, THEN_BLOCK, ELSE_BLOCK };
enum resalts { SUCCESS, FAIL };

static int if_state = NEUTRAL;
static int if_result = SUCCESS;
static int last_stat = 0;

int syn_err(char *);

int ok_to_execute()
/*
 * 目的 : シェルがコマンドを実行すべきかどうかを判断する。
 * 戻り値: イエスなら１，ノーなら0
 * 詳細 : THEN_BLOCK内にいて、if_resultがSUCCESSならイエス
 *        THEN_BLOCK内にいて、if_resultがFAILならノー
 *        WANT_THENなら構文エラー(shは異なる)
 */
{
  int rv = 1; /*デフォルトは真 */

  if (if_state == WANT_THEN) {
    syn_err("then expected");
    rv = 0;
  } else if (if_state == THEN_BLOCK && if_result == SUCCESS)
    rv = 1;
  else if (if_state == THEN_BLOCK && if_result == FAIL)
    rv = 0;
  else if (if_state == ELSE_BLOCK && if_result == SUCCESS)
    rv = 0;
  else if (if_state == ELSE_BLOCK && if_result == FAIL)
    rv = 1;

  return rv;
}

int is_control_command(char *s)
/*
 * コマンドがシェル制御コマンドかどうかを報告するbool関数
 * 戻り値: 0 か 1
 */
{
  return (strcmp(s, "if") == 0 || strcmp(s, "then") == 0 ||
          strcmp(s, "fi") == 0) ||
         strcmp(s, "else") == 0;
}

int do_control_command(char **args)
/*
 * 目的 : "if" , "then " , "fi" を処理する -- 状態を変更するかエラーを検出する。
 * 戻り値 : OK なら0、構文エラーなら-1
 * メモ : I would have put returns all over the place , Barry says "no"
 */
{
  char *cmd = args[0];
  int rv = -1;

  if (strcmp(cmd, "if") == 0) {
    if (if_state != NEUTRAL)
      rv = syn_err("if unexpBected");
    else {
      last_stat = process(args + 1);
      if_result = (last_stat == 0 ? SUCCESS : FAIL);
      if_state = WANT_THEN;
      rv = 0;
    }
  } else if (strcmp(cmd, "then") == 0) {
    if (if_state != WANT_THEN)
      rv = syn_err("then unexpected");
    else {
      if_state = THEN_BLOCK;
      rv = 0;
    }
  } else if (strcmp(cmd, "else") == 0) {
    if (if_state != THEN_BLOCK) {
      rv = syn_err("else unexpected");
    } else {
      if_state = ELSE_BLOCK;
      rv = 0;
    }
  } else if (strcmp(cmd, "fi") == 0) {
    if (if_state != THEN_BLOCK && if_state != ELSE_BLOCK) {
      rv = syn_err("fi unexpected");
    } else {
      if_state = NEUTRAL;
      rv = 0;
    }
  } else
    fatal("internal error processing:", cmd, 2);
  return rv;
}

int syn_err(char *msg)
/* 目的:制御構造内の構文エラーを処理する。
 *  詳細:状態をNEUTRALにリセットする。
 *  戻り値: 対話的モードなら1、スクリプト内では、fatal呼び出しになる。
 */
{
  if_state = NEUTRAL;
  fprintf(stderr, "syntax error : %s\n", msg);
  return -1;
}

```

## どのような変更を加えるべきか。
状態変数であるstatesに状態をまず増やす。
その後、ok_to_execute関数の戻り値をif_stateのみで戻せるように変更。
do_control_commandで状態の管理を修正していけば良い。

### ソースコード
```

/* controlflow.c
 *
 * " if " 処理は、if_stateとif_resultの２個の状態変数を使って行う。
 */

#include "smsh.h"
#include <stdio.h>
#include <string.h>

enum states {
  NEUTRAL,
  IF_SUCCEEDED,
  IF_FAILED,
  SKIPPING_THEN,
  DOING_THEN,
  SKIPPING_ELSE,
  DOING_ELSE
};

static int if_state = NEUTRAL;
static int last_stat = 0;

int syn_err(char *);

int ok_to_execute()
/*
 * 目的 : シェルがコマンドを実行すべきかどうかを判断する。
 * 戻り値: イエスなら１，ノーなら0
 * 詳細 : THEN_BLOCK内にいて、if_resultがSUCCESSならイエス
 *        THEN_BLOCK内にいて、if_resultがFAILならノー
 *        WANT_THENなら構文エラー(shは異なる)
 */
{
  int rv = 1; /*デフォルトは真 */

  if (if_state == IF_SUCCEEDED || if_state == IF_FAILED) {
    syn_err("then expected");
    rv = 0;
  } else if (if_state == DOING_THEN)
    rv = 1;
  else if (if_state == SKIPPING_THEN)
    rv = 0;
  else if (if_state == SKIPPING_ELSE)
    rv = 0;
  else if (if_state == DOING_ELSE)
    rv = 1;

  return rv;
}

int is_control_command(char *s)
/*
 * コマンドがシェル制御コマンドかどうかを報告するbool関数
 * 戻り値: 0 か 1
 */
{
  return (strcmp(s, "if") == 0 || strcmp(s, "then") == 0 ||
          strcmp(s, "fi") == 0) ||
         strcmp(s, "else") == 0;
}

int do_control_command(char **args)
/*
 * 目的 : "if" , "then " , "fi" を処理する -- 状態を変更するかエラーを検出する。
 * 戻り値 : OK なら0、構文エラーなら-1
 * メモ : I would have put returns all over the place , Barry says "no"
 */
{
  char *cmd = args[0];
  int rv = -1;

  if (strcmp(cmd, "if") == 0) {
    if (if_state != NEUTRAL)
      rv = syn_err("if unexpected");
    else {
      last_stat = process(args + 1);
      if_state = (last_stat == 0 ? IF_SUCCEEDED : IF_FAILED);
      rv = 0;
    }
  } else if (strcmp(cmd, "then") == 0) {
    if (if_state != IF_FAILED && if_state != IF_SUCCEEDED)
      rv = syn_err("then unexpected");
    else {
      if (if_state == IF_SUCCEEDED)
        if_state = DOING_THEN;
      if (if_state == IF_FAILED)
        if_state = SKIPPING_THEN;
      rv = 0;
    }
  } else if (strcmp(cmd, "else") == 0) {
    if (if_state != DOING_THEN && if_state != SKIPPING_THEN) {
      rv = syn_err("else unexpected");
    } else {
      if (if_state == DOING_THEN)
        if_state = SKIPPING_ELSE;
      if (if_state == SKIPPING_THEN)
        if_state = DOING_ELSE;
      rv = 0;
    }
  } else if (strcmp(cmd, "fi") == 0) {
    if (if_state == IF_SUCCEEDED || if_state == IF_FAILED ||
        if_state == NEUTRAL) {
      rv = syn_err("fi unexpected");
    } else {
      if_state = NEUTRAL;
      rv = 0;
    }
  } else
    fatal("internal error processing:", cmd, 2);
  return rv;
}

int syn_err(char *msg)
/* 目的:制御構造内の構文エラーを処理する。
 *  詳細:状態をNEUTRALにリセットする。
 *  戻り値: 対話的モードなら1、スクリプト内では、fatal呼び出しになる。
 */
{
  if_state = NEUTRAL;
  fprintf(stderr, "syntax error : %s\n", msg);
  return -1;
}

```
## 実行結果



```
> if ls -a
.  ..  9.7.md  controlflow.c  execute.c  process.c  smsh  smsh.h  smsh2.c  splitline.c
> then
> ls
9.7.md	controlflow.c  execute.c  process.c  smsh  smsh.h  smsh2.c  splitline.c
> else
> ls
> fi
> if ls test
ls: 'test' にアクセスできません: そのようなファイルやディレクトリはありません
> then 
> ls
> else
> ls
9.7.md	controlflow.c  execute.c  process.c  smsh  smsh.h  smsh2.c  splitline.c
> fi

```

正しく動いているようだ。

## 状態変数を減らすべきか、増やすべきか。
状態変数を増やした場合、do_control_commandの内容は２つの状態でケースわけできるので、整理しやすいが
ok_to_executeの条件式が２つの条件の検証をしないといけないので、少し複雑になる。
逆に状態変数を減らした場合は、ok_to_executeの条件式が andやorがいらなくなるのでスッキリするが、
do_control_commandの状態の変更の条件式が少し複雑になる。
どちらがいいかはこの規模では好みの問題かもしれないが、このような言語処理系の複雑さが増してきたときは
考えて選ぶ必要が出てくる可能性がある。


