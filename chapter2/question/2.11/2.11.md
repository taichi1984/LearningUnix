# プログラミング課題 2.11      
      
## 課題内容      
　標準のcpは、ファイルを自分自身にコピーしようとしたときに、どのように動作するか。      
例えば、cp file1 file1 とするとどうなるか答えなさい。また、どのような動作が正しいと思うか、述べなさい。      
cp1.cを書き換えて、そのような状況を適切に処理できるようにしなさい。      
      
## 実際にcp file1 file1 をしてみる      
```      
$ cp sample.txt sample.txt      
cp: 'sample.txt' and 'sample.txt' are the same file      
      
```      
      
同じファイルですよというエラーが出て、終了する。      
これは、正しい動作だと思います。無駄なく問題なく動いていると思う。      
      
## 自作したcp1を書き替えずに実行してみた。      
```      
$  cp1 sample.txt sample.txt      
```      
      
コマンドライン上では何も起こらず、ファイルの中身を確認したところ、ファイルの中身が消えていた。      
これは非常にまずい動作なので、エラーを吐いて終了するようにしなければならない。      
      
## cp1を通常のcpと同じように、エラーを吐いて終了するように書き換える。      
      
```      
#include <fcntl.h>      
#include <stdio.h>      
#include <stdlib.h>      
#include <string.h>      
#include <unistd.h>      
      
#define BUFFERSIZE 4096      
#define COPYMODE 0644      
      
void oops(char *, char *);      
      
int main(int ac, char *av[]) {      
      
  int in_fd, out_fd, n_chars;      
  char buf[BUFFERSIZE];      
      
  if (ac != 3) {      
    fprintf(stderr, "usage: %s source desination\n", *av);      
    exit(1);      
  }      
  /* ファイル名を比較し、コピー元とコピー先が同じ場合は終了するように以下のコードを追記*/      
  if (strcmp(av[1], av[2]) == 0) {      
    fprintf(stderr, "cp1 : \'%s\' and \'%s\' are the same file", av[1], av[2]);      
    exit(1);      
  }      
      
  if ((in_fd = open(av[1], O_RDONLY)) == -1)      
    oops("Cannot open ", av[1]);      
  if ((out_fd = creat(av[2], COPYMODE)) == -1)      
    oops("Cannot creat ", av[2]);      
      
  while ((n_chars = read(in_fd, buf, BUFFERSIZE)) > 0)      
    if (write(out_fd, buf, n_chars) != n_chars)      
      oops("Write error to ", av[2]);      
      
  if (n_chars == -1)      
    oops("Read error from ", av[1]);      
      
  if (close(in_fd) == -1 || close(out_fd) == -1)    
    oops("Error closing files", "");      
}      
      
void oops(char *s1, char *s2) {      
  fprintf(stderr, "Error : %s ", s1);      
  perror(s2);      
  exit(1);      
      
}      
```      
      
実行結果      
      
```      
$ cat sample.txt      
      
# Sample Data File      
      
Name, Age, Country      
Alice, 30, USA      
Bob, 25, Canada      
Charlie, 35, UK      
Denise, 28, Australia      
Ethan, 40, Germany      
      
Lorem ipsum dolor sit amet, consectetur adipiscing elit.      
Vestibulum vehicula ex eu neque hendrerit, non efficitur lorem pulvinar.      
Nunc et ante ac sapien malesuada sodales eget nec magna.      
Quisque cursus ex sed dolor blandit finibus.      
      
-- End of File --      
      
$ ./cp1 sample.txt sample.txt      
cp1 : 'sample.txt' and 'sample.txt' are the same file      
      
      
$ cat sample.txt      
      
# Sample Data File      
      
Name, Age, Country      
Alice, 30, USA      
Bob, 25, Canada      
Charlie, 35, UK      
Denise, 28, Australia      
Ethan, 40, Germany      
      
Lorem ipsum dolor sit amet, consectetur adipiscing elit.      
Vestibulum vehicula ex eu neque hendrerit, non efficitur lorem pulvinar.      
Nunc et ante ac sapien malesuada sodales eget nec magna.      
Quisque cursus ex sed dolor blandit finibus.      
      
-- End of File --      
      
```      
      
このようにサンプルテキストが消えたりすることもなく、同じファイル名なら警告が出て、なにもせず終了しているようだ。      
      
## 結論      
コマンドライン引数から、第１引数と第２引数に当たるファイル名を取得し比較して、同じだったらエラーメッセージを出し、      
プログラムを終了させるだけで問題なく達成できる。      
    
    
## 発展版    
上記の引数比較のcp1では、第１引数と第２引数の書き方次第では、バリデーションを通ってしまい、やはりファイルの内容が消えてしまう。    
例. cp1 sample.txt ./sample.txt など    
    
この状況を回避するために、ファイルの比較をしっかり行ったバージョンが次のものになる。    
    
### ソースコードと実行結果    
    
```    
    
/* 文字列比較だけではなく、完全に同じファイルであることを確認できる完全版*/    
    
#include <fcntl.h>    
#include <stdio.h>    
#include <stdlib.h>    
#include <sys/stat.h>    
#include <unistd.h>    
    
#define BUFFERSIZE 4096    
#define COPYMODE 0644    
    
void oops(char *, char *);    
    
int main(int ac, char *av[]) {    
    
  struct stat stat1, stat2;    
  int in_fd, out_fd, n_chars;    
  char buf[BUFFERSIZE];    
    
  if (ac != 3) {    
    fprintf(stderr, "usage: %s source desination\n", *av);    
    exit(1);    
  }    
  /* 完全なファイル比較はこうなる。 */    
  if (stat(av[1], &stat1) == -1)    
    oops("Cannot stat ", av[1]);    
    
  if (stat(av[2], &stat2) == -1)    
    oops("Cannot stat ", av[2]);    
    
  if (stat1.st_ino == stat2.st_ino && stat1.st_dev == stat2.st_dev) {    
    fprintf(stderr, "cp1 : \'%s\' and \'%s\' are the same file\n", av[1],    
            av[2]);    
    exit(1);    
  }    
    
  /* ファイル名だけで比較した場合の比較    
  if (strcmp(av[1], av[2]) == 0) {    
    fprintf(stderr, "cp1 : \'%s\' and \'%s\' are the same file\n", av[1],    
            av[2]);    
    exit(1);    
  }    
  */    
    
  if ((in_fd = open(av[1], O_RDONLY)) == -1)    
    oops("Cannot open ", av[1]);    
  if ((out_fd = creat(av[2], COPYMODE)) == -1)    
    oops("Cannot creat ", av[2]);    
    
  while ((n_chars = read(in_fd, buf, BUFFERSIZE)) > 0)    
    if (write(out_fd, buf, n_chars) != n_chars)    
      oops("Write error to ", av[2]);    
    
  if (n_chars == -1)    
    oops("Read error from ", av[1]);    
    
  if (close(in_fd) == -1 || close(out_fd) == -1)  
    oops("Error closing files", "");    
}    
    
void oops(char *s1, char *s2) {    
  fprintf(stderr, "Error : %s ", s1);    
  perror(s2);    
  exit(1);    
}    
    
```    
    
実行結果    
    
```    
    
$ ./cp2 sample.txt ./sample.txt    
    
cp1 : 'sample.txt' and './sample.txt' are the same file    
    
```    
    
表記の仕方が違ってもきちんと同じファイルであることを認識し、エラーメッセージを表示している。    
    
    
### stat(char *pathname , struct stat *statbuf)システムコール    
#include <sys/stat.h>でインクルードできる。    
ファイルやディレクトリの情報を取得するための超重要な関数。    
調べたいファイルのパスを第１引数にして、情報を書き込むためのstat型ポインタを第２引数にする。    
戻り値は成功すれば０、失敗すれば-1になる。    
    
主なメンバーは以下の通り。    
    
```    
struct stat {    
    dev_t     st_dev;     // デバイスID（ファイルが存在するデバイス）    
    ino_t     st_ino;     // inode番号（ファイルの実体を識別）    
    mode_t    st_mode;    // パーミッションとファイルタイプ    
    nlink_t   st_nlink;   // ハードリンクの数    
    uid_t     st_uid;     // 所有者のユーザーID    
    gid_t     st_gid;     // 所有グループのID    
    off_t     st_size;    // ファイルサイズ（バイト単位）    
    time_t    st_atime;   // 最終アクセス時刻    
    time_t    st_mtime;   // 最終更新時刻    
    time_t    st_ctime;   // inodeの更新時刻（chmodやchown時など）    
    ...    
};    
    
```    
    
    
    
    
