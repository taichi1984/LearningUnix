# 研究課題5.7
## 課題内容
**renameはどのような仕組みなのか?** renameシステムコールは、アトミックな処理である。
何らかのUnixカーネルコードを見て、カーネルが競合や衝突を処理しているところをすべて探しなさい。
Linuxカーネルコードのコメントは非常に言葉数が多くて面白い。

## renameシステムコールのカーネルコードを調べる。
renameシステムコールが書かれているソースコードはfs/namei.c
その中のvfs_rename関数が実際にrenameが行われている関数。
アトミック性を保証するための処理が書かれている関数は
vfs_rename関数とそのvfs_rename関数を読んでいる、do_renameat2関数であるようだ。

vfs_rename関数のコメントには、この関数のロックが非常にややこしいことを説明している。
ソースコードとコメントを読んでも実際なぜこうなるかは現時点ではわからないが、ここでアトミックな処理を確保しているのは間違いないだろう。

## vfs_renameのコメントから行われている処理を読み解く
コメントは英語だったため、Chatgpt翻訳をしたものを以下に転載する。
```
/**
 * vfs_rename - ファイルシステムオブジェクトの名前を変更する
 * @rd:		&struct renamedata 情報へのポインタ
 *
 * 呼び出し元は複数の mutex を保持していなければならない――詳細は lock_rename() を参照。
 *
 * vfs_rename が、ソースまたは宛先のいずれかで破棄すべき委譲（delegation）を発見した場合、
 * -EWOULDBLOCK を返し、delegated_inode に inode への参照を返す。
 * 呼び出し元はその後、その委譲を破棄してリトライする必要がある。
 * 委譲の破棄には長時間かかる可能性があるため、呼び出し元は実行する前にすべてのロックを解放すべきである。
 *
 * 代わりに、呼び出し元が delegated_inode に NULL を渡すこともできる。
 * これは基盤となるファイルシステムが NFS にエクスポートされないことを想定している呼び出し元には適切かもしれない。
 *
 * 名前空間操作の中でも最悪なのがディレクトリの rename だ。「倒錯的」ではまだ言い足りない。
 * UCB の誰かがとんでもない旅をしていたのだろう…。
 * 問題点：
 *
 *	a) ループ生成に陥る可能性がある。
 *	b) 競合の可能性――2つの無関係な rename が組み合わさってループを作り出すことがある。
 *	   これが 4.4BSD がしくじった点である。現行の修正策：sb->s_vfs_rename_mutex での直列化。
 *	   もっと正確にできるかもしれないが、それは別の話。
 *	c) 最大で4つのオブジェクトをロックする必要がある――親ディレクトリ2つ、被害者（存在すれば）、
 *	   そしてソース（それが非ディレクトリか、または異なる親に移動するサブディレクトリの場合）。
 *	   しかもこれは、親に対して ->i_rwsem を取得した後（その時点まで対象が存在するか分からない）。
 *	   解決策：inode のロック順序を賢く扱うこと。
 *	   我々は、ツリーのトポロジーが ->s_vfs_rename_mutex の下でしか変化しないこと、
 *	   かつ移動対象の親がロックされることに依拠している。
 *	   したがって、ディレクトリはツリー順序（祖先が先）でランク付けし、
 *	   非ディレクトリはそれらの後にランク付けする。
 *	   これは、rename 以外は「親をロック→lookup→子をロック」で動作し、
 *	   rename は ->s_vfs_rename_mutex の下で行われるために機能する。
 *	   しかしこれは、->lookup() を持つ任意のオブジェクトが 1 つ以上の dentry を持たないという
 *	   前提に依存している。もし「ハイブリッド」オブジェクトが現れるなら、
 *	   それに対して link(2) が存在しないことを確実にしなければならない。
 *	d) fhandle から dentry への変換がタイミング悪く発生する可能性がある――つまり対象を削除しているときに。
 *	   解決策：fhandle_to_dentry コード内で ->i_rwsem を取得しなければならない。
 *	   [FIXME - 現在の nfsfh.c は親に対する ->i_rwsem に依存しており、これは機能はするが、
 *	    非常に過剰なロックを招いている]
 */

```

## 問題点と解決策
### ループ生成に陥る可能性があること。
ディレクトリのrenameで自分の子孫の中に移動してしまうケースがあると、ループ構造ができあがる。
カーネル側でこうならないように検証する必要がある。

### 競合の可能性があること。
２つの無関係なrenameが組み合わさってループを作り出すことがある。
現行の修正策は：sb->s_vfs_rename_mutex での直列化。という対処をしているがもっといい対処法があるかもしれない模様。
このsb->s_vfs_rename_mutexがどういう処理をしているのかは不明だが、これが処理を直列化しているのは間違いない。

### 最大で４つのオブジェクトをロックする必要があること
古い名前のファイルと新しい名前のファイルとその両方の親ディレクトリをロックする必要がある。

これはinodeのロック順序を賢く扱うことで対処している模様。
詳細はコメントに書いてあるが、現時点ではまだ理解できていない。

### fhandle から dentry への変換がタイミング悪く発生する可能性がある――つまり対象を削除しているときに。
この内容に関しては、よくわからない。fhandleからdentryに変換しているタイミングが悪いと問題が起こるようだ。
renameのもとのソース側を削除しているときにこの変換のタイミングがかぶると問題が起こる模様。


