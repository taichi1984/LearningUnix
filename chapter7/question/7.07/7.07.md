# 研究課題7.7
## 課題内容
**非同期入力を使っているときのブロックと再帰** 非同期入力を使うバージョンのbounceは、２つのシグナルハンドラを持つ。
プログラムが、SIGALRMハンドラ内にいるときにSIGIOが届いたらどうなるのか。逆の場合はどうか。
これらの２つのハンドラが互いに相手の処理を妨害することはあるか。
ハンドラでシグナルを処理するときには、シグナルをブロックする必要があるか。
再帰呼出しはどうか。プログラムがSIGIOを処理しているときに、新しい文字が届くと問題が起きるか。
可能な組み合わせをすべてリストアップし、発生する可能性のある問題を網羅しなさい

## SIGALRMハンドラとSIGIOハンドラがお互いに割り込みをかけたらどうなるか？
### SIGALRMの実行中にSIGIOハンドラが割り込みをかけた場合
SIGALRMの実行は割り込まれ、SIGIOの処理が実行される。
本来SIGALRMが３秒の時間がかかったとしても、SIGIOが途中で割り込んできたら、SIGIOによる処理が行われる。
SIGALRM側がsleepをかけていた場合はSIGIOが終わった直後にsleepの次の処理から再開されるので、ボタンを押すたびに文字列が動くように見えるという結果になる。

### SIGIOハンドラ実行中にSIGALRMが割り込みをかけた場合
SIGIOハンドラ実行中にSIGALRM代わりこみをかけた場合、SIGIOをsleepなどで止めていたとしても、SIGALRMの処理が終わった直後にsleepの次の処理から再度開始される。
そのため、たとえばsleep(3)でSIGIOの完了を待ったとしても、SIGALRMの処理が終わった瞬間にsleep(3)以降の処理が行われるため、SIGALRMのタイミングで動作が操作が行われているように感じる。操作感的にはSIGALRMがくるまでラグが発生するような感じになる。


## 発生する可能性のある問題はなにか？
### グローバル変数の破壊による表示位置の異常

```

/* bounce_async.c
 * 目的 : ユーザー制御のアニメーション、　fdに対してO_ASYNCを指定する
 * 注意 : set_ticker()はSIGALRMを送り、ハンドラはアニメーションを実現する。
 * キーボードはSIGIOを送り、mainはpause()を呼び出すだけである。
 * コンパイル : gcc bounce_async.c set_ticker.c -l ncurses -o bounce_async
 *
 */

#include <curses.h>
#include <fcntl.h>
#include <signal.h>
#include <stdio.h>
#include <string.h>
#include <unistd.h>

/* ゲームの状態 */

#define MESSAGE "hello"
#define BLANK "     "

int row = 10;
int col = 0;
int dir = 1;
int delay = 200;
int done = 0;
void set_ticker(int);

int main(void) {
  void on_alarm(int);
  void on_input(int);
  void enable_kbd_signals();

  initscr();
  crmode();
  noecho();
  clear();

  signal(SIGIO, on_input);
  enable_kbd_signals();
  signal(SIGALRM, on_alarm);
  set_ticker(delay);

  move(row, col);
  addstr(MESSAGE);

  while (!done)
    pause();

  endwin();
}

void on_input(int signum) {
  int c = getch();
  sleep(3);
  if (c == 'Q' || c == EOF)
    done = 1;
  else if (c == ' ')
    dir = -dir;
}

void on_alarm(int signum) {
  signal(SIGALRM, on_alarm);
  mvaddstr(row, col, BLANK);
  col += dir;
  mvaddstr(row, col, MESSAGE);
  refresh();

  if (dir == -1 && col <= 0)
    dir = 1;
  else if (dir == 1 && col + strlen(MESSAGE) >= COLS)
    dir = -1;
}

void enable_kbd_signals() {
  int fd_flags;
  fcntl(0, F_SETOWN, getpid());
  fd_flags = fcntl(0, F_GETFL);
  fcntl(0, F_SETFL, (fd_flags | O_ASYNC));
}

```
カーソル位置や移動方向は各種possion関係のグローバル変数で管理している。
割り込みのタイミング次第でdirの方向がおかしくなったりする可能性があり、表示位置に異常が発生する可能性が考えられる。

### SIGIO中にSIGIOで割り込んだ場合
割り込みを行うためにSIGIO中にsleepなどを行っていた場合、割り込んだ回数だけsleepがスタックするので、処理が非常に重くなったように感じられる。
これは実際にSIGIOの処理が重かった感じは溜まった分だけ重くなるということなのでパフォーマンスが低下することが考えられる。

### 割り込みの種類を問わず
再入安全でない処理がハンドラ内で行われていた場合は、動作が乱れる、フリーズするなどの恐れは常にある。

