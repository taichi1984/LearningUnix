# 研究課題8.4
## 課題内容
**forkとファイルディスクリプタ** 次のコードについて考えてみよう
main()
{
    int fd;
    int pid;
    char msg1[] = "Testing 1 2 3 .. \n";
    chat msg2[] = "Hello, hello\n";

    if( (fd = creat("testfile",0644) == -1)
        return 0;
    if( write(fd,msg1,strlen(msg1)) == -1)
        return 0;

    if( (pid = fork()) == -1)
        return 0;
    
    if(write(fd,msg2,strlen(msg2)) == -1)
        return 0;
    
    close(fd);
    return 1;
}

このプログラムをテストする。forkを呼び出したあと、両プロセスは同じ出力ファイルに同じ現在位置のファイルディスクリプタを持っている。
ファイルには、何個のメッセージが出力されるか。出力の行数から、ファイルディスクリプタやファイルとファイルディスクリプタの結びつきについて
何が言えるか、答えなさい。

## 処理の流れを予想して結果を考える。
以下のように表示されると予測します。
```
Testing 1 2 3 .. 
Hello, hello
Hello, hello
```

write自体はアトミックな処理のため、親プロセスのwriteが書かれている途中で子プロセスが割り込むことはない。
fdは最初にcreatされたファイルに接続されているが、これが子プロセスにもコピーされる。
fork()のあと、親プロセスと子プロセス、どちらが先にwrite(fd,msg2,strlen(msg2) を実行するかは不明だが、
片方が実行された時点でfdの指すファイル上の位置は移動するため、上記のように表示されるはずだ。

## 実際の実行結果
```
Testing 1 2 3 .. 
Hello, hello
Hello, hello
```

予想通りの結果になった。ファイルディスクリプタの実体自体はカーネルが管理し、変数fdはファイルディスクリプタの整数IDを保持しているだけのため、
fdが共有される形になったので、3行目が書かれる処理の際にはすでにfdの指す位置は2回目のwriteで次に進んでおり、
2行目のHello, helloは上書きされることなく、次の行にもう一つ書き込まれたのだ。


