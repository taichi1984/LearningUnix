# 研究課題5.24
## 課題内容
**ロックのためにlink()を使う** ２つのプロセスが同時に同じファイルを更新しようとする状況は、
よくある競合の例である。例えば、あなたがあるシステムでパスワードを書き換えると、
passwdプログラムは/etc/passwdを書き換える。２人のユーザーが同時にパスワードを変更したときにはどうなるだろうか。
linkシステムコールの重要な機能を活用すれば、ファイルへの同時アクセスを防ぐことができる。
次のコードについて考えてみよう。

```
/*
* /etx/passwd.LCKというリンクを作ることを試みる。
* 成功した場合は0,ロック済みの場合は１，その他の問題があるときは２を返す。
*/ 

int lock_passwd()
{
    int rv = 0;
    if(link ("/etc/passwd","/etc/passwd.LCK") == -1)
        rv = ( errno == EEXIST ? 1 : 2 );
    return rv;
}

(a) 2つのプロセスがこのコードを同時に実行しても、片方しか成功しない。
linkシステムコールがファイルをロックするための便利な方法になるのはなぜか？

(b) このテクニックを使って、ファイルにテキスト行を追加する短いプログラムを書きなさい。
このプログラムは、リンクを張ろうとしなければならない。
リンク作成に失敗したら、プログラムはsleep(1)を使って１秒待ってから再試行する。
プログラムが永遠に待ち続けることがないようにしなさい。

(c) lock_passwdの高価を取り消すunlock_passwd関数を書きなさい。

(d) このサンプルは、プロセスが依存ファイルにロックをかけられるようにするが、
linkを使うと２つのプロセスが共に同じファイルをcreatするのを防げるのはなぜか。

(e) vipwコマンドについて調べなさい。vipwは、ロックのためにリンクを貼っているか。

```

## (a)linkシステムコールがファイルをロックするための便利な方法になるのはなぜか。
LinkシステムコールはLINKを作る。
このLINKの名前のつけかたを一定の規則にして、同じファイルには同じ名前のリンクしか作れないようにルールを作ることで
２つ目のリンクが動いた場合はすでにファイルがあるためEEXISTを返すようになる。

各プロセスにこの一定のルールでやりたい処理の前後に以下のような操作を行う。
以下は開いたファイル名+.LCKという名前のリンクを作ってロックファイルにするという規則で行う。

プロセスA
```
link("etc/passwd","/etc/passwd.LCK")リンクを作成　

やりたい処理を行う

unlink("/etc/passwd.LCK")リンクを解除
```

プロセスB
```
link("etc/passwd","/etc/passwd.LCK")リンクを作成　

やりたい処理を行う

unlink("/etc/passwd.LCK")リンクを解除
```

このようなプロセスAがやりたい処理を行うところで、何らかの待ちをして、容易に割り込める状態にあったとする。
その間は同ディレクトリにプロセスAの作った(passwd.LCK）が存在することになる。
その途中にプロセスBが実行された場合、最初のロックファイルを作る処理が必ずEEXISTのエラーを返す（すでにロックファイルが存在するため）
そのエラーが発生したら、それ以下の処理を行わないようにすれば、ロックファイルがある場合はそのファイルに触れないというような動きを作ることができる。

なおこれは完全にそのファイルをロックできるというよりかは、プログラムのルールとして最初にロックファイルを作り、
最後にロックファイルを消すというような決まりのもとで動いているプロセスに対してのみ有効なロックになる。
これをadvisory lock(助言的ロック、協調的ロック）といい、複数のプロセスが「お互いに約束して守る」方式でシステムが強制するわけではないロック方式となる。


## (b) このテクニックを使ってファイルにテキスト行を追加するプログラムを書く。
### ソースコード

```
/*
 *  ファイルロックのテスト
 *  第１引数のファイル名に　\n scanfで取得した任意の文字列を末尾に追加する。
 */
#include <errno.h>
#include <fcntl.h>
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>

int main(int ac, char *av[]) {
  char lockfile[FILENAME_MAX];
  char line[100];

  snprintf(lockfile, sizeof(lockfile), "%s.LCK", av[1]);

  while (1) {
    if (link(av[1], lockfile) == 0) {
      printf("追加したい文字列を入力してください\n");
      break;
    }

    if (errno == EEXIST) {
      printf("ファイルはロックされています。 , ロック解除待ち中...\n");
      sleep(1);
      continue;
    }
  }

  fgets(line, sizeof(line), stdin);

  FILE *fp;
  fp = fopen(av[1], "a");
  fprintf(fp, "%s", line);
  fclose(fp);

  unlink(lockfile);
}

```


### 実行結果

実行結果 プロセスA

```
$ ./addtext test1
追加したい文字列を入力してください //ここでプロセスBを起動
asfaskljklj

```

実行結果 プロセスB 

```
$ ./addtext test1
ファイルはロックされています。 , ロック解除待ち中...
ファイルはロックされています。 , ロック解除待ち中...
ファイルはロックされています。 , ロック解除待ち中...
ファイルはロックされています。 , ロック解除待ち中...
ファイルはロックされています。 , ロック解除待ち中...　//ここでプロセスA側の入力完了
追加したい文字列を入力してください
asdfsa
```

```
$ cat test1
asklsjdklfj
this is locked
this is locked 2
asdfsakjlk
asdfsalk
asfaskljklj  //以下２行がきちんと追加されている
asdfsa
```

## (c) lock_passwdの効果を取り消すunlock_passwd関数を書く。

まずlock_passwdはこちら。
```
int lock_passwd()
{
    int rv = 0;
    if(link ("/etc/passwd","/etc/passwd.LCK") == -1)
        rv = ( errno == EEXIST ? 1 : 2 );
    return rv;
}

```
これを使ってロックして解除するコードを書いたものが以下。
```
#include <errno.h>
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>

int lock_passwd() {
  int rv = 0;
  if (link("/etc/passwd", "/etc/passwd.LCK") == -1)
    rv = (errno == EEXIST ? 1 : 2);
  return rv;
}

int unlock_passwd() {
  if (unlink("/etc/passwd.LCK") == -1) {
    perror("unlink");
    exit(1);
  }
  return 0;
}

int main(void) {
  printf("lockしました\n");
  unlock_passwd();
  printf("unlockしました\n");

  return 0;
}

```

### 実行結果
```
$ sudo ./lockpasswd
lockしました
unlockしました
```

### passwdのロックをアンロックできるコードは以下の関数になる。
```
int unlock_passwd() {
  if (unlink("/etc/passwd.LCK") == -1) {
    perror("unlink");
    exit(1);
  }
}
```

## (d) linkを使うと２つのプロセスが共に同じファイルをcreatするのを防げるのはなぜか
linkはもとのファイルがないとハードリンクを作ることが出来ない。
つまり単純にlinkをプロセスの最初に書いて、防ぐことは出来ない。
理屈上はlinkはatomicな処理なので、ほとんどのファイルに対する操作をロックできることになるが
creatに関しては、もとのファイルが存在せず、完璧に新規作成される場合にはもとのファイルにリンクを貼ることが出来ない（プログラムがかけない）

つまりlinkを使っても２つのプロセスが共に同じファイルをcreatするのは防げない。そもそもlinkが有効ではないので、そのプログラムがかけない。
通常creatを複数同時に行うようなことのないようにするためには以下のコードを書くべきである。

```
open(path, O_CREAT | O_EXCL , mode)
```

open()システムコールに O_CREATをつけることでcreatの動作にし、 O_EXCLをつけることですでに同名のファイルがあった場合は、
失敗するようにフラグを立てておく（EEXIST)のが正解。
この操作もatomicにできている。

## (e)vipwコマンドについて調べなさい。vipwは、ロックのためにリンクを使っているか。

vipwコマンドはpasswdの内容を編集するプログラム。manページにはそれ以外には編集に使うエディタのことしか書かれていない。

実際の挙動は以下のようになっている。

1. vipwで編集中には/etcディレクトリには、passwd-lockファイルとpasswd-editファイルが追加される。
2. 実際に２つのプロセスでvipwを起動したときの挙動は以下の通り

プロセスAがvipwで編集作業中にプロセスBがvipwを実行すると
プロセスAが作業を終えてプロセスを終了させるまで、プロセスBは待機状態になる。
プロセスBが作業を終えてプロセスを終了すると、プロセスBは解除され編集するためのテキストエディタが立ち上がる。

ここから推測できることは、linkシステムコールを使って、passwd-lockファイルにてロックを行っている可能性は非常に高い。
それに加えて、編集中にシステムが落ちたときなどの破壊に備えて、passwd-editファイルを作り、編集はそちらで行い編集中の作業を保持すると共に
実際に編集が終わったあとに保存することにより、もとのファイルも壊さないような工夫もなされているという印象がある。


### 実際にstrace vipwで確認してみる。

いろいろあったが以下のような記述の場所で、待ちが発生している。

```
openat(AT_FDCWD, "/etc/.pwd.lock", O_WRONLY|O_CREAT|O_CLOEXEC, 0600) = 3
rt_sigaction(SIGALRM, {sa_handler=0x73d614f64f50, sa_mask=~[], sa_flags=SA_RESTORER, sa_restorer=0x73d614e45330}, {sa_handler=SIG_DFL, sa_mask=[], sa_flags=0}, 8) = 0
rt_sigprocmask(SIG_UNBLOCK, [ALRM], [], 8) = 0
alarm(15)                               = 0
fcntl(3, F_SETLKW, {l_type=F_WRLCK, l_whence=SEEK_SET, l_start=0, l_len=0}
```

実際のロックはfcntlで行っているようだ。
これはlinkによるテクニックでロックをしているのではなく、ロックのための専門のシステムコールということになる。
linkでロックするというのは仕組み上可能ではあるが、実際は以下のようなロック用のシステムコールが用意されている。


| 関数             | 種類       | 特徴                                    |
| -------------- | -------- | ------------------------------------- |
| `fcntl()`      | POSIXロック | 最も古典的で標準的。範囲指定ができる。ファイル記述子ごとのロック。     |
| `flock()`      | BSDロック   | 単純。ファイル全体にロック。プロセス単位で管理。              |
| `lockf()`      | POSIX簡易版 | 実装的には `fcntl()` のラッパ。使いやすいが機能は同じ。     |
| `open(O_EXCL)` | 原始的ロック   | ファイルの新規作成を原子的に行うことで排他を実現（実際はロックではない）。 |


実際にvipwではこれらのロックAPIを使っているのでlinkを使っているわけではない。



