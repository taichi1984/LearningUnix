# プログラミング課題　2.12    
    
## 課題内容    
** ファイル対API ** 私たちは処理効率を上げるためにutmplib.cを作ったが、実はこれには副産物がある。    
その副産物とは、データファイルを関数セット(API)に置き換えたということだ。このAPIはログインユーザーを表すものでは    
ないものも含め、全てのutmp構造体を返す。しかし、whoコマンドが必要とするものは、アクティブセッションを表すレコードだけである。    
アクティブセッションを表すレコードだけを返すように、utmplib.cを書き換えなさい。    
この変更は、who3.cの他のソースコードファイルにどのような影響を与えるか説明しなさい。    
このような変更はそもそも良い考えだといえるか。結論と理由を述べなさい。    
    
## utmplib.cとwho3.c の改良    
    
```    
    
/* utmpファイルからの読み出しをバッファリングするための関数*    
 *  含まれる関数は次の通り    
 *    
 *  utmp_open( file_name ) ファイルをオープンする。    
 *   ファイルをオープンする。エラーの時には-1を返す。    
 *  utmp_next( ) - 次の構造体を指すポインタを返す。    
 *    eofのときにはNULLを返す。    
 *   utmp_close() - ファイルを閉じる    
 *    
 *   一度の読み出しでNRECS個の構造体を読み出し、バッファから構造体を１つずつ提供する。*/    
    
#include <fcntl.h>    
#include <stdio.h>    
#include <sys/types.h>    
#include <unistd.h>    
#include <utmp.h>    
    
#define NRECS 16    
#define NULLUT ((struct utmp *)NULL)    
#define UTSIZE (sizeof(struct utmp))    
    
static char    
    utmpbuf[NRECS *    
            UTSIZE]; // メモリ領域、NRECS個の構造体を一次保存するバッファ    
static int num_recs;     //格納してある個数    
static int cur_rec;      // 次のレコード番号    
static int fd_utmp = -1; //読み出し先    
    
int utmp_reload();    
    
int utmp_open(char *filename) {    
  fd_utmp = open(filename, O_RDONLY);    
  cur_rec = num_recs = 0;    
  return fd_utmp;    
}    
    
struct utmp *utmp_next() {    
  struct utmp *recp;    
    
  while (    
      1) { // ここにループを追加することによって、USER_PROCESSを発見するか、全てのutmpを確保するまで、繰り返す(次のレコードを探し続ける。)。    
    if (fd_utmp == -1)    
      return NULLUT;    
    if (cur_rec == num_recs && utmp_reload() == 0)    
      return NULLUT;    
    
    recp = (struct utmp *)&utmpbuf[cur_rec * UTSIZE];    
    cur_rec++;    
    
    if (recp->ut_type ==    
        USER_PROCESS) // USER_PROCESSであればreturnでループから抜けつつ戻り値を返す。    
      return recp;    
  }    
}    
    
int utmp_reload() {    
  int amt_read;    
    
  amt_read = read(fd_utmp, utmpbuf, NRECS * UTSIZE);    
    
  num_recs = amt_read / UTSIZE;    
  cur_rec = 0;    
  return num_recs;    
}    
    
void utmp_close() {    
  if (fd_utmp != -1)    
    close(fd_utmp);    
}    
    
```    
    
who3.c側の改良    
    
```    
/* whoのutmplib.c側でUSER_PROCESSのみ判別させているのバージョン *    
 */    
#include "utmplib.c"    
#include <fcntl.h>    
#include <stdio.h>    
#include <stdlib.h>    
#include <time.h>    
#include <unistd.h>    
#include <utmp.h>    
    
#define SHOWHOST    
void show_info(struct utmp *utbufp);    
void showtime(long timeval);    
    
int main() {    
    
  struct utmp *utbufp;    
    
  if (utmp_open(UTMP_FILE) == -1) {    
    perror(UTMP_FILE);    
    exit(1);    
  }    
    
  while ((utbufp = utmp_next()) != ((struct utmp *)NULL))    
    show_info(utbufp);    
  utmp_close();    
  return 0;    
}    
void show_info(struct utmp *utbufp) {    
 /* if (utbufp->ut_type != USER_PROCESS)    
    return; この部分はutmplib.cが受け持つようになったため不要なので削除*/    
  printf("%-8.8s", utbufp->ut_name);    
  printf("%-8.8s", utbufp->ut_name);    
  printf(" ");    
  printf("%-8.8s", utbufp->ut_line);    
  printf(" ");    
  showtime(utbufp->ut_time);    
    
#ifdef SHOWHOST    
  printf("(%s)", utbufp->ut_host);    
#endif    
  printf("\n");    
}    
    
void showtime(long timeval) {    
  time_t t = (time_t)timeval;    
  char *cp = ctime(&timeval);    
  printf("%12.12s", cp + 4);    
}    
```    
    
show_info()にあったut_typeがUSER_PROCESSであるかを判別する文を削除しても    
きちんとUSER_PROCESSのみ出すようになる。    
    
### この変更はよいと思うか？    
この変更を行ったことにより、utmp_lib.cで出来ることは、utmpレコード全てを返す機能から  
ut_typeがUSER_PROCESSのutmpレコードを返すライブラリに機能が変わってしまった。    
この変更によって、使う側にとっては便利になったものの、ライブラリの汎用性は損なわれている。    
変更に伴いutmp_next()関数の名前も実態にそぐわないものになった。    
    
もしC言語ではなく、オブジェクト指向機能のある言語で設計で、utmpの情報を得るクラスの機能として    
utmpのレコードのリストを返すような関数が、引数によって、USER_PROCESSのレコードのみのリストを返したり  
全部のレコードのリストを返したり、使い分けられるような設計ならばいい作りのクラスになる。  
そのような柔軟な設計であれば、今回のフィルタ処理も自然にみえる。  
  
しかし現状のutmp_next()のような次の構造体返す関数に、  
USER_PROCESSに限定する処理を組み込むのは不自然。    
utmp_next() の引数でフィルタ条件を指定できる設計であれば、汎用性を保ったまま柔軟に使えた。  
  
モジュールの責務を分離する観点から見ても、utmp_next()が次の構造体を返すようにしつつ、使う側で表示するレコードを制御するのが自然。    
その場合、who3.cの25行目のshowinfoをするところで、show_infoをするかどうかをutbufp->ut_type == USER_PROCESS　ならばshowinfo(utbufp)をするのがよいだろう。    
    
    
    
      
    
    
