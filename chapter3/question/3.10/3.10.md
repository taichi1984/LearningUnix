# プログラミング課題 3.10  
## 課題内容  
ls1.cに列分け表示機能を追加しなさい。標準版のlsを試して、列分け表示が何をするのか調べなさい。  
列の幅は、リストに含まれるファイルの長さによって変わることがわかるはずだ。また、列はできる限り  
同じ長さになるようになっている。そして、表示の幅は、端末ウィンドウの幅によって決まる。  
lsは端末ウィンドウの幅をどのようにして調べているのか？  
  
## ls1.cをチェック  
  
```  
  
/** ls1.c  
 *  目的 : ディレクトリ( 複数の場合も含む) の内容をリストアップする。  
 *  動作 :  
 * 引数がない場合には、"."、そうでなければ引数のディレクトリに含まれるファイルを出力する。  
 *  
 */  
#include <dirent.h>  
#include <stdio.h>  
  
void do_ls(char[]);  
  
int main(int ac, char *av[]) {  
  if (ac == 1) {  
    do_ls(".");  
  } else {  
    while (--ac) {  
      printf("%s: \n", *++av);  
      do_ls(*av);  
    }  
  }  
  return 0;  
}  
  
void do_ls(char dirname[])  
/*  
 *  dirnameというディレクトリのファイルをリストアップする。  
 */  
{  
  DIR *dir_ptr;  
  struct dirent *direntp;  
  
  if ((dir_ptr = opendir(dirname)) == NULL)  
    fprintf(stderr, "ls1: cannot open %s \n", dirname);  
  else {  
    while ((direntp = readdir(dir_ptr)) != NULL)  
      printf("%s\n", direntp->d_name);  
    closedir(dir_ptr);  
  }  
}  
```  
## 列の揃え方をどうするか？  
フォーマット修飾子を使って、その列の長さを設定すればよい。  
列分け表示をする場合は、同じ列の横幅は全て同じ幅にする必要があるので、その列で最も長いファイル名にあわせる必要が出てくる。  
あらかじめ最も長い行の長さはファイルを何個表示できるのかを計算することで、それにあわせた表示に全行整える必要が出てくる。  
  
## ロジックを考える  
### 第１案  
端末の幅は何文字入力可能か調べる。  
最も長いファイル名の文字数を数えて計算しそこから何ファイル前後に移動した場合、１行の最大表示量を超えるか計算する。  
これの最も長いパターンが、１行に表示できる最大のファイル数になる。  
これをもとファイル名を格納する二次元配列を用意。[行数][列数]のもの。  
列毎に最も長いファイル名の長さを取得し、その列の幅にする（%ndのnの数値を決定する。)  
  
２次元配列を順番に表示  
１行終わったら、改行する。  
  
⇒　動的な２次元配列の確保などが非常に難しく、ChatGPTに教えてもらいながら妥協案に変更  
  
### 第２案  
端末の幅は何文字入力可能か調べる。  
最も長いファイル名の文字数を数えて、それを列の幅の基準とする。  
ファイル名のポインタ配列を用意。  
端末の横幅 / ファイル名の列幅　で１行の列数を計算。  
ファイル数　/ 1行のファイル数で行数を計算。  
２重ループで表示する。  
  
  
## 端末の幅を調べる  
端末の幅を調べるのはioctl()を使っている。  
端末の幅を調べるコードは以下の通り。  
  
```  
#include <stdio.h>  
#include <sys/ioctl.h>  
#include <unistd.h>  
  
int main(void) {  
  struct winsize w;  
  if (ioctl(STDOUT_FILENO, TIOCGWINSZ, &w) == -1) {  
    perror("ioctl");  
    return 1;  
  }  
  printf("Rows : %d, Cols %d \n", w.ws_row, w.ws_col);  
  return 0;  
}  
  
```  
実行結果は以下  
  
```  
$ ./ioctl  
Rows : 51, Cols 209  
```  
colsが横幅、rowsが縦幅になる。  
数字は端末の文字セル数になる。  
  
## 第２案での実装してみた  
  
```  
/** ls1cols.c  
 *  目的 : ディレクトリ( 複数の場合も含む) の内容をリストアップする。  
 *  動作 :  
 * 引数がない場合には、"."、そうでなければ引数のディレクトリに含まれるファイルを出力する。  
 *  
 */  
#define _POSIX_C_SOURCE 200809L  
  
#include <dirent.h>  
#include <stdio.h>  
#include <stdlib.h>  
#include <string.h>  
#include <sys/ioctl.h>  
#include <unistd.h>  
  
void do_ls(char[]);  
  
int main(int ac, char *av[]) {  
  if (ac == 1) {  
    do_ls(".");  
  } else {  
    while (--ac) {  
      printf("%s: \n", *++av);  
      do_ls(*av);  
    }  
  }  
  return 0;  
}  
  
void do_ls(char dirname[])  
/*  
 *  dirnameというディレクトリのファイル名を返す。  
 */  
{  
  DIR *dir_ptr;  
  struct dirent *direntp;  
  char **filename;  
  int num_of_file = 0;  
  int i = 0;  
  int j = 0;  
  struct winsize w;  
  int max_of_filename = 0;  
  
  /*ファイルの数を数える*/  
  if ((dir_ptr = opendir(dirname)) == NULL) {  
    fprintf(stderr, "ls1: cannot open %s \n", dirname);  
    return;  
  
  } else {  
    while ((direntp = readdir(dir_ptr)) != NULL) {  
      num_of_file++;  
    }  
  }  
  
  /* 文字列ポインタの配列を確保*/  
  
  filename = malloc(num_of_file * sizeof(char *));  
  if (!filename) {  
    perror("malloc");  
    closedir(dir_ptr);  
    return;  
  }  
  
  rewinddir(dir_ptr);  
  /*ファイル名のポインタをfilenameに順番に格納*/  
  i = 0;  
  while (i < num_of_file && (direntp = readdir(dir_ptr)) != NULL) {  
    filename[i] = strdup(direntp->d_name);  
  
    if (filename[i] == NULL) {  
      perror("strdup failed");  
      for (j = 0; j < i; j++)  
        free(filename[j]);  
      free(filename);  
      closedir(dir_ptr);  
      return;  
    }  
    i++;  
  }  
  
  closedir(dir_ptr);  
  
  /*端末の幅を取得*/  
  
  if (ioctl(STDOUT_FILENO, TIOCGWINSZ, &w) == -1) {  
    perror("ioctl");  
    return;  
  }  
  
  printf("端末の横の長さ : %d \n ", w.ws_col);  
  
  /* 最も長いファイルの長さを測る */  
  for (j = 0; j < num_of_file; j++) {  
    if (strlen(filename[j]) >= max_of_filename)  
      max_of_filename = strlen(filename[j]);  
  }  
  printf("最も長いファイル長 %d\n", max_of_filename);  
  
  /* 表示 */  
  
  const int padding_spaces = 2;  
  const int terminal_width = (w.ws_col > 0) ? w.ws_col : 80;  
  int column_width = max_of_filename + padding_spaces;  
  
  int column_count = (terminal_width + padding_spaces) / column_width;  
  if (column_width < 1)  
    column_count = 1;  
  
  int row_count = (num_of_file + column_count - 1) / column_count;  
  int row_index = 0;  
  int column_index = 0;  
  int index_in_array;  
  for (row_index = 0; row_index < row_count; row_index++) {  
    for (column_index = 0; column_index < column_count; column_index++) {  
      index_in_array = row_index + column_index * row_count;  
      if (index_in_array < num_of_file) {  
        printf("%-*s", column_width, filename[index_in_array]);  
      }  
    }  
    putchar('\n');  
  }  
  
  for (j = 0; j < num_of_file; j++) {  
    free(filename[j]);  
  }  
  free(filename);  
}  
  
```  
  
### 学びポイント  
**filenameを宣言しchar型のポインタのポインタをmallocで確保することで、実体がない理論上の文字列の配列を用意し  
実体のポインタを格納していくことで文字列の配列として扱える。  
  
ioctlを使うことで、端末のウィンドウに関する情報を取得できる()  
  
２次元配列を使わずに、１次元配列をindexを上手く使って走査することにより、２次元配列っぽく使える。  
  
フォーマット指定子の数値の部分に変数を使いたい場合は %*dや%-*sなどとすることした上で第２引数から左から順に指定していくことによって、指定できる。  
  
  
  
